{"questions":{"01bf58a4-cceb-4dc3-9e93-6197f3a3e47d":{"region":{"central":false,"northeast":false,"south":true,"north":false},"deleted":false,"solution":"Answer: \"3\"","imageUrls":[],"tags":["data-structure"],"createdAt":{"_seconds":1533106809,"_nanoseconds":0},"note":"- **Category:** Data structure\n- **Author:** คูน\n- **Time-limit:** 20 วินาที\n- ภาคใต้ตอบถูก 0/7 ทีม","updatedAt":{"_seconds":1535329881,"_nanoseconds":426000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"หากเราใส่ค่า 9, 2, 3, 4, 18, 11, 20 ตามลำดับ เข้าไปใน binary search tree ที่เดิมไม่มีข้อมูลอยู่เลย โดยไม่มี rebalancing ของต้นไม้  \n\nจงหาความสูง (height) ของต้นไม้ผลลัพธ์\n\n**หมายเหตุ:** กำหนดให้ binary search tree ที่มี node เดียวมีความสูงเท่ากับ 0","archived":true},"026d6638-49ab-4deb-9825-7d23e03a3e57":{"region":{"south":false,"north":true,"central":true,"northeast":false},"deleted":true,"solution":"ยังไม่รู้","imageUrls":[],"tags":["counting","math"],"createdAt":{"_seconds":1536116864,"_nanoseconds":492000000},"note":"จิได้มาจากพี่ทศ\nเค้าบอกว่าข้อนี้คิดได้สองแบบ  จะเขียนโปรแกรมก็ได้\nหรือจะใช้ math แบบตู้มเดียวได้คำตอบเลยก็ได้\n","updatedAt":{"_seconds":1536599177,"_nanoseconds":319000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"audition":false,"national":false,"regional":true},"statement":"จงหาจำนวนเต็มบวกที่น้อยที่สุดที่\n- หาร 2 เหลือเศษ 1\n- หาร 3 เหลือเศษ 2\n- หาร 4 เหลือเศษ 3\n- หาร 5 เหลือเศษ 4\n- หาร 6 เหลือเศษ 5\n- หาร 7 เหลือเศษ 6\n- หาร 8 เหลือเศษ 7\n- หาร 9 เหลือเศษ 8\n- หาร 10 เหลือเศษ 9","archived":false},"02af54a3-189b-41c7-a0d9-a2c6b2c20588":{"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"Answer: `((())`","imageUrls":[],"tags":["code-peeking","data-structure"],"createdAt":{"_seconds":1533106806,"_nanoseconds":0},"note":"- **Category:** Using data structure to achieve other tasks\n- **Author** คูน","updatedAt":{"_seconds":1536575218,"_nanoseconds":120000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":true},"round":{"national":false,"regional":false,"audition":true},"statement":"พิจารณา pseudocode ต่อไปนี้\n\n```pseudocode\ninput: character stream I\noutput: printed string\n\nS := empty stack\nfor each character c in stream I \n    if c == ‘(‘\n        S.push(‘(‘)\n    else if c == ‘)’ and stack S is not empty\n        S.pop()\n    else \n        print(“unbalanced”) and exit\n    end\nend\n\nprint(“balanced”)\n```\n\nข้อมูลในข้อใดต่อไปนี้ทำให้ psudocode แสดงค่า `\"balanced\"`?\n\n1. `((())`\n2. `())(()`\n3. `(()()))`\n4. `(()))()`\n5. `((())()))`","archived":true},"0362e1f4-9e02-4f52-9ec4-310130ee341a":{"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"Depth First Search","imageUrls":[],"tags":["algorithms","graph-algorithms"],"createdAt":{"_seconds":1533106810,"_nanoseconds":0},"note":"- **Category:** Algorithms\n- **Author:** คูน","updatedAt":{"_seconds":1536575244,"_nanoseconds":317000000},"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"audition":true,"national":false,"regional":false},"statement":"อัลกอริทึมใดที่สามารถหา cycle ของกราฟได้อย่างมีประสิทธิภาพที่สุด?\n\n1. Depth First Search\n2. Breadth First Search\n3. Prim’s Minimum Spanning Tree Algorithm\n4. Kruskal’s Minimum Spanning Tree Algorithm\n5. Dijkstra’s Shortest Path Algorithm","archived":true},"03efdaf6-298d-4733-8b82-9c3c7ca24f55":{"createdAt":{"_seconds":1535332483,"_nanoseconds":345000000},"note":"- จิ copy จาก codility\n- [เอก, Aof] ver ละ","updatedAt":{"_seconds":1537767455,"_nanoseconds":658000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"regional":false,"audition":true,"national":false},"statement":"ประพจน์ใดกล่าวถูกต้องบ้างเกี่ยวกับโปรแกรมดังต่อไปนี้\n```pseudocode\nfunction f(A):\n    # A is a 0-indexed array of integers\n    n := A.length()\n    for i := 0 to n-2 do:\n        if A[i] > A[i+1] then:\n            swap A[i] with A[i+1]\n        end\n    end\n    return A     \n```\n\n- ประพจน์ P: มีค่าค่าหนึ่งใน output array ซึ่งเมื่อลบออกจาก array ดังกล่าว จะทำให้ array ผลลัพธ์เป็น sorted array\n- ประพจน์ Q: สำหรับ input array A ใด ๆ ที่มีขนาด N จะได้ว่า `f(A)[N-1] = max(A)`\n- ประพจน์ R: สำหรับ input array A ใด ๆ ที่มีขนาด N จะได้ว่า `f(A)[0] = min(A)`\n\n#### ตัวเลือก\n\n1. ประพจน์ P เท่านั้นที่ถูกต้อง\n1. ประพจน์ Q เท่านั้นที่ถูกต้อง\n1. ประพจน์ R เท่านั้นที่ถูกต้อง\n1. ประพจน์ P และ Q เท่านั้นที่ถูกต้อง\n1. ประพจน์ P และ R เท่านั้นที่ถูกต้อง\n1. ประพจน์ Q และ R เท่านั้นที่ถูกต้อง\n1. ถูกต้องทั้งสามประพจน์\n1. ผิดทั้งสามประพจน์","archived":true,"region":{"central":true,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"ประพจน์ Q เท่านั้นที่ถูกต้อง / สำหรับ input array A ใด ๆ ที่มีขนาด N จะได้ว่า `f(A)[N-1] = max(A)`","imageUrls":[],"tags":["propose-north-audition"]},"04fb423b-0612-40d7-86d5-01b8aec03b0c":{"updatedAt":{"_seconds":1541099013,"_nanoseconds":711000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"regional":false,"audition":false,"national":true},"statement":"เริ่มจากพิจารณารูปที่กำหนดให้ เป็นพื้นที่สี่เหลี่ยมผืนผ้าขนาด $8 \\times 5$ หน่วย ซึ่งที่แบ่งพื้นที่ภายในเป็นชิ้นส่วน TETRISⓡ จำนวน 10 ชิ้น ด้วยการขีดเส้นปากกา (เส้นสีน้ำเงินทึบภายในกรอบสี่เหลี่ยม) ดังรูป พบว่าความยาวเส้นปากกาดังกล่าวคือ 35 หน่วย … หากรูปนี้่ถูกแบ่งเป็นชิ้นส่วน TETRIS ในรูปแบบที่ต่างออกไป อาจจะมีความยาวเส้นปากการวมดังกล่าว มากกว่าหรือน้อยกว่า 35 หน่วยก็ได้\n\nโจทย์ข้อนี้ให้พิจารณาพื้นที่สี่เหลี่ยมผืนผ้าขนาด $12 \\times 9$ หน่วย หากเราใช้ปากกขีดเส้น**ภายใน**กรอบสี่เหลี่ยม เพื่อแบ่งให้พื้นที่ว่างในกรอบเป็นชิ้นส่วน TETRIS จำนวน 27 ชิ้น\n\nถามว่าความยาวของเส้นที่ลากด้วยปากกาดังกล่างมีความยาวน้อยที่สุดและมากที่สุดคือกี่หน่วย? (สองคำถาม)\n\n**หมายเหตุ:** ความยาวของเส้นปากกา เรานับเฉพาะเส้นที่คั่นระหว่างชิ้นส่วน TETRIS สองชิ้น และไม่นับเส้นกรอบ","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F04fb423b-0612-40d7-86d5-01b8aec03b0c%2Ftetrix.png?alt=media&token=52f112d2-7d0a-4310-beb5-22f570b58b5a"],"tags":["counting","hard-math","used"],"createdAt":{"_seconds":1533106836,"_nanoseconds":0},"note":"- **Author:** เพลน\n- should be paired with [sum of contiguous primes problem](/questions/b74852c9-ff92-413f-893d-5ceab44ba365)\n- 90, 114 > Ju (คิดมือ)\n- Aof: เคสน้อยสุดได้ 90   "},"054d9f0c-7ee2-4672-9689-3e55c518830a":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":true,"solution":"AVG = 100.5,  MEDIAN = 100.5,  SUM=10050","imageUrls":[],"tags":[],"createdAt":{"_seconds":1537841378,"_nanoseconds":945000000},"note":"- จิ : ลองวาดใน excel","updatedAt":{"_seconds":1537841795,"_nanoseconds":183000000},"format":{"choices":false,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":true,"audition":false,"national":false},"statement":"กำหนดให้มีตัวเลขตั้งแต่ 1 ถึง 250 เรียงจากมากไปน้อย ดังตัวอย่าง\n\n250,249,248, .. , 1\n\nและกำหนดให้มีฟังก์ชัน `sort-inplace(L, p, q)` ซึ่งจะจัดเรียงจำนวนใน Array L จากน้อยไปมาก **เฉพาะระหว่างตำแหน่ง `p` และ `q`**\n\nมีการรันคำสั่งต่อไปนี้\n ```\n    sort-inplace(L, 0, 99)\n    sort-inplace(L, 150, 249)\n    sort-inplace(L, 50, 199)\n ```\n\nจงหาว่า  ในตัวเลข 100 ตำแหน่งแรก มีค่า Average, Median, SUM เท่าไหร่?","archived":false},"0a68a706-91a1-4b4f-8174-b8536c50e56a":{"createdAt":{"_seconds":1533106851,"_nanoseconds":0},"note":"แตกจากข้อ rand7 ของคูณ","updatedAt":{"_seconds":1536543158,"_nanoseconds":129000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true},"round":{"audition":true,"national":false,"regional":false},"statement":"กำหนด `rand7()` เป็นฟังก์ชันที่สุ่มจำนวนเต็มในช่วงตั้งแต่ 1 - 7 ด้วยความน่าจะเป็นเท่าๆกัน\n\nถ้าเราต้องการสุ่มจำนวนเต็มตั้งแต่ 1 - 11 ด้วยการคำนวนด้านล่าง จงหาว่าผลลัพธ์จากการสุ่มนี้ ผลลัพธ์ใดมีความน่าจะเป็นสูงสุด\n\n```pseudocode\n((rand7() + rand7()) mod 11) + 1\n````\n**หมายเหตุ:** `mod` คือการหารเอาเฉพาะเศษ (Modulo)\n\n1. 1\n2. 2\n3. 3\n4. 4\n5. 5\n6. 6\n7. 7\n8. 8\n9. 9\n10. 10\n11. 11\n12. ความน่าจะเป็นเท่าๆกันตั้งแต่ 1 - 11\n13. มีผลลัพธ์ที่มีความน่าจะเป็นสูงสุดมากกว่า 1 ผลลัพธ์\n","archived":true,"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"**' 9 '**","imageUrls":[],"tags":["probability","counting","propose-north-audition"]},"0adccecb-7d61-489e-adbd-f2c6b582ee50":{"region":{"northeast":true,"south":false,"north":false,"central":false},"deleted":false,"solution":"\"1\"","imageUrls":[],"tags":["cs-knowledge"],"createdAt":{"_seconds":1535332174,"_nanoseconds":306000000},"note":"- Easy multiple choice quickfire\n- จิ copy มาจาก codility","updatedAt":{"_seconds":1536575732,"_nanoseconds":427000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":true},"round":{"national":false,"regional":false,"audition":true},"statement":"สมมุติมี Array ของจำนวนเต็มที่เรียงลำดับแล้ว ขั้นตอนวิธีใดต่อไปนี้กระทำเร็วที่สุด\n\n1. ค้นหาตัวเลข 42 ว่าอยู่ใน Array หรือไม่\n2. นับว่ามีจำนวนตัวเลขที่แตกต่างกันกี่ตัว\n3. หาค่าเฉลี่ยของตัวเลขทั้งหมดใน Array\n4. นับว่ามีเลขคู่ทั้งหมดกี่ตัวใน Array\n5. ทุกคำตอบข้างต้นใช้เวลาเป็น linear เท่ากันหมด ดังนั้นทุกคำตอบข้างต้นใช้เวลาพอๆกัน\n","archived":true},"0ae1f08f-0078-44cb-93b7-39d716093525":{"imageUrls":[],"tags":[],"createdAt":{"_seconds":1534919562,"_nanoseconds":633000000},"note":"*Author :* อัท","updatedAt":{"_seconds":1534942973,"_nanoseconds":910000000},"format":{"choices":false,"coding":true,"ponder":false,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"นักพัฒนาที่ดินรายใหญ่ผู้มีงบประมาณไม่อั้น ต้องการที่จะซื้อที่ดินเพื่อนำไปเก็งกำไร โดยในการซื้อที่ดินนั้นมีเงื่อนไขว่า\n\n- จะซื้อเพียงครั้งเดียวต่อ 1 ข้อมูลแผนที่ โดยซื้อเป็นพื้นที่สี่เหลี่ยมผืนผ้าติดกัน ซึ่งอาจจะเป็นการรวมหลายแปลงให้เป็นสี่เหลี่ยมผืนผ้าก็ได้\n \n- ในการเลือกที่ดินแปลงใดบ้างนั้น จะพิจารณาจากมูลค่ารวมของทุกแปลงที่ทำการเลือกในครั้งนั้น\n \nเนื่องจากข้อมูลในการพิจรณาที่ดินดังกล่าวมีขนาดใหญ่มาก จึงต้องการให้ช่วยเขียนโปรแกรม เพื่อประเมินมูลค่าสูงสุดในการซื้อที่ดินบนแผนที่นั้นๆ โดยข้อมูลนำเข้ามีลักษณะดังนี้\n \n```\nT\nM1 N1\nD[0, 0] D[0, 1] ... D[0, N1]\nD[1, 0] D[1, 1] ... D[1, N1]\n...\nD[M1, 0] D[M1, 1] ... D[M1, N1]\nM2 N2\nD[0, 0] D[0, 1] ... D[0, N2]\nD[1, 0] D[1, 1] ... D[1, N2]\n...\nD[M2, 0] D[M2, 1] ... D[M2, N2]\nM3 N3\nD[0, 0] D[0, 1] ... D[0, N3]\nD[0, 0] D[0, 1] ... D[1, N3]\n...\nD[M3, 0] D[M3, 1] ... D[M3, N3]\n```\nโดย\n\n- T คือจำนวนแผนที่ที่จะให้ประเมิน และ $1 \\leq T \\leq 10000$\n- M, N คือขนาดของแผนที่ และ $1 \\leq M \\leq 10000$ และ $1 \\leq N \\leq 10000$\n- D คือมูลค่าของพื้นที่ และ $-100 \\leq D \\leq 100$\n \nต้องการข้อมูลส่งออกให้มีลักษณะดังนี้\n```x\nO1\nO2\n...\nOT\n```\nโดย\n- T คือจำนวนแผนที่ที่จะให้ประเมิน\n- O คือมูลค่าสูงสุดที่เป็นไปได้ในการทำการซื้อที่ดินในแผนที่นั้นๆ\n \n**ตัวอย่าง**\n \n*ข้อมูลนำเข้า*\n```\n2\n3 3\n1  0  0\n0 -1 0\n1 0 1\n4 4\n-1  0  0 -1\n0  1  1  0\n0  1 -1  0\n-1  0  1 -1\n```\n\n*ข้อมูลส่งออก*\n```\n2\n3\n```  \n*คำอธิบาย*\n\nแผนที่ 1 ควรจะซื้อพื้นที่ดังนี้ ซึ่งจะได้มูลค่ารวมเป็น 2\n``` \n1\n0\n1        หรือ       1 0 1\n```\nแผนที่ 2 ควรจะซื้อพื้นที่ดังนี้ ซึ่งจะได้มูลค่ารวมเป็น 3\n```\n1  1\n1 -1\n0  1\n ```","archived":false,"region":{"south":false,"north":true,"central":true,"northeast":true},"deleted":true,"solution":""},"0b6e3f52-9a8b-4482-8b75-978fc57f5f0c":{"format":{"quickfire":false,"choices":true,"coding":false,"ponder":true},"round":{"audition":true,"national":false,"regional":false},"statement":"ธนาคารกสิกรสาขา TechJam 2018 มี 1000 ชั้น ติดเลขไว้ตั้งแต่ 1 ถึง 1000 เจ้าหน้าที่ต้องเตรียมเลขโดด 0 ถึง 9 ไว้เพื่อนำมาติดตามชั้นต่างๆ โดยเลข 2 หลักต้องใช้เลข 2 ตัว เช่น 10 ต้องเตรียมเลข 1 กับ 0 อย่างละ 1 ตัว \n\nอยากทราบว่าเจ้าหน้าที่ต้องเตรียมเลข 9 กี่ตัว เพื่อนำมาติดให้ครบ 1000 ชั้น\n\n1. 20\n2. 30\n3. 33\n4. 90\n5. 99\n6. 100\n7. 109\n8. 300\n9. 900\n10. 1000\n11. 1019\n12. 1109\n13. 1199\n14. 1800\n15. 2700\n","archived":true,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"Answer: \"300\"","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1533106812,"_nanoseconds":0},"note":"- **Category:** Counting & corner cases\n- **Author:** คูน\n","updatedAt":{"_seconds":1536575354,"_nanoseconds":416000000}},"10006ecc-bb8f-4600-9c6d-6fffc7aad3c7":{"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"national":false,"regional":true,"audition":false},"statement":"นายเคเป็นผู้เข้าแข่งขัน TechJam Code Squad ที่กำลังสำรวจเสร็จทางไปแข่ง ซึ่งจะต้องผ่านหมู่บ้านหนึ่งที่มีผังหมู่บ้านเป็นระเบียบ โดยบ้านและถนนต่างๆถูกวางผังเป็นรูปสี่เหลี่ยมจัตุรัส ขนาด 5x5 ดังรูป\n\nนายเค ต้องการทราบว่า **มีกี่เส้นทาง** ที่ตนจะสามารถเดินทางไปแข่งขัน TechJam ได้  โดยมีเงื่อนไขต่อไปนี้\n- ไม่มีการเดินย้อนหรือเดินอ้อม จะเดินไปหาจุดหมายด้วยระยะทางที่สั้นที่สุดเท่านั้น\n- ไม่สามารถเดินทะลุบ้านได้\n- บ้านหลังหนึ่งมีสุนัขดุมากตามรูป นายเคจะไม่เดินรอบบ้านหลังนี้\n\n","archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":false,"solution":"164","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F10006ecc-bb8f-4600-9c6d-6fffc7aad3c7%2F1536207386089.jpg?alt=media&token=7ded7790-aeb6-4b95-bf8d-2db52a635f05"],"tags":["counting","small-coding","dynamic-programming"],"createdAt":{"_seconds":1536080140,"_nanoseconds":798000000},"note":"- recycled\n- verified by Plane","updatedAt":{"_seconds":1536576166,"_nanoseconds":789000000}},"195117f6-aefb-464c-9b5d-f0388d588ab4":{"round":{"national":false,"regional":false,"audition":true},"statement":"จงพิจารณาโปรแกรมดังต่อไปนี้แล้ววิเคราะห์หา time complexity ของฟังก์ชัน `weird` เมื่อกำหนดให้ข้อมูลนำเข้าคือ Array ที่มีความยาว $N$ \n\n```pseudocode\nfunction weird(A):\n    n := A.length()\n    weird_recursive(A, 0, n)\nend\n\nfunction weird_recursive(A, lo, hi):\n    if hi - lo ≤ 30 then:\n        order(A, lo, hi)\n        return\n    end\n    segment := ceiling((hi - lo) / 6)\n    weird_recursive(A, lo, lo + 3*segment)\n    weird_recursive(A, lo + segment, lo + 4*segment)\n    weird_recursive(A, lo + 2*segment, lo + 5*segment)\n    weird_recursive(A, lo + 3*segment, hi)\n    order(A, lo, lo + 4*segment)\nend\n\nfunction order(A, lo, hi):\n    for i := lo to hi-2 do:\n        for j := i + 1 to hi-1 do:\n            if A[i] > A[j] then swap A[i] and A[j]\n        end\n    end\nend\n```\n\n**หมายเหตุ:** ฟังก์ชัน `celing` ปัดเศษทศนิยมขึ้นเป็นจำนวนเต็มถัดไปที่ใกล้ที่สุด\n\n#### ตัวเลือก\n\n1. $O(N)$\n1. $O(N \\log N)$\n1. $O(N \\log^2 N)$\n1. $O(N \\log \\log N)$\n1. $O(N^{1.262})$\n1. $O(N \\sqrt{N})$\n1. $O(N^2)$\n1. $O(N^2 \\log N)$\n1. $O(N^2 \\log^2 N)$\n1. $O(N^2 \\log \\log N)$\n1. $O(N^2 \\sqrt{N})$\n1. $O(N^{2.710})$\n1. $O(N^3)$\n1. $O(N^3 \\log N)$\n1. $O(N^3 \\log^2 N)$\n1. $O(N^3 \\log \\log N)$\n1. $O(N^{3.419})$\n1. $O(2^N)$\n1. $O(2^N \\cdot N)$\n1. $O(2^N \\cdot N^2)$\n1. $O(4^N)$\n1. $O(4^N \\cdot N)$\n1. $O(4^N \\cdot N^2)$\n1. $O(N!)$","archived":false,"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":true,"solution":"$O(N^2 \\log N)$","imageUrls":[],"tags":["code-peeking","big-o-analysis"],"createdAt":{"_seconds":1537525100,"_nanoseconds":562000000},"note":"- **Author:** เพลน\n    - ข้อนี้อาจจะยากเกินไป หากคาดหวังให้ผู้เข้าแข่งขันรู้จัก Master Theorem \n    - ตัวเลือกดูไม่สวยและน่าสับสน\n    - แต่ข้อดีคือ ฟังก์ชันนี้ sort ได้จริง","updatedAt":{"_seconds":1537547672,"_nanoseconds":618000000},"format":{"quickfire":false,"choices":true,"coding":false,"ponder":true}},"1cfa4a37-94f7-4102-816d-d06308bfade4":{"note":"","updatedAt":{"_seconds":1537349980,"_nanoseconds":664000000},"format":{"choices":false,"coding":true,"ponder":false,"quickfire":false},"round":{"regional":true,"audition":false,"national":false},"statement":"# max-perimeter\n\n### Background\n\nคุณทำงานเป็นช่างไม้ และได้รับคำสั่งให้นำแท่งไม้ที่เหลือๆ อยู่มาทำเป็นของประดับบ้าน ที่มีรูปเป็นสามเหลี่ยมที่คุณสมบัติดังต่อไปนี้\n\n- สร้างขึ้นจากแท่งไม้ 3 ชิ้นจากไม้ที่เหลืออยู่ โดยใช้แท่งไม้แต่ละแท่งเพียงแค่หนึ่งครั้ง (ห้ามใช้ซ้ำ)\n- เป็นเครื่องแต่งบ้านรูปสามเหลี่ยม 2 มิติ ที่มีพื้นที่มากกว่า $0$ หน่วย\n\n#### ตัวอย่าง\n\n- สามเหลี่ยมที่สร้างจากแท่งไม้ $3$ $4$ และ $5$ จะมีพื้นที่ $6$ หน่วย (ตรงเงื่อนไข)\n- สามเหลี่ยมที่สร้างจากแท่งไม้ $1$ $1$ และ $2$ จะมีพื้นที่ $0$ หน่วย (ไม่ตรงเงื่อนไข)\n\n### Problem Statement\n\nจงเขียนโปรแกรมเพื่อหาค่า**ความยาวรอบรูป**สามเหลี่ยม ที่มีค่ามากที่สุดที่สามารถจะสร้างได้ จากแท่งไม้ที่เหลือทั้งหมด $N$ แท่ง ถ้าหากไม่สามารถสร้างสามเหลี่ยมได้เลยให้ตอบ $-1$ \n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มหนึ่งตัว $N$ บอกถึงจำนวนของแท่งไม้ทั้งหมดที่เหลืออยู่ทั้งหมด\n- บรรทัดที่ 2: มีจำนวนเต็ม $L_i$ ทั้งสิ้น $N$ ตัว บอกถึงความยาวของแท่งไม้แต่ละแท่งที่เหลืออยู่ ตั้งแต่แท่งที่ $1$ ถึงแท่งที่ $N$\n$$\n\\begin{aligned}\n& N \\\\\n& L_1\\; L_2\\; \\ldots\\; L_N  \\\\\n\\end{aligned}\n$$\n\n#### Output Format\n\n- จะเป็นความยาวรอบรูปสามเหลี่ยมที่มากที่สุดที่สร้างได้จากแท่งไม้ที่เหลืออยู่ (ตอบ $-1$ ในกรณีที่ไม่สามารถสร้างได้)\n\n## Example #1\n\n#### Input\n```plaintext\n5\n1 2 4 8 16\n```\n\n#### Output\n```plaintext\n-1\n```\n(หมายเหตุ: จะต้องตอบ $-1$ เนื่องจากไม่สามรถสร้างสามเหลี่ยมได้) \n\n### Example #2\n\n#### Input\n```plaintext\n5\n1 2 3 4 5\n```\n\n#### Output\n```plaintext\n12\n```\n(หมายเหตุ: จะต้องตอบ $12$ จากการนำไม้ยาว $3$ $4$ และ $5$ มาสร้างสามเหลี่ยม) \n\n### Example #3\n\n#### Input\n```plaintext\n7\n180 3 42 4 20 21 4\n```\n\n#### Output\n```plaintext\n45\n```\n(หมายเหตุ: จะต้องตอบ $45$ จากการนำไม้ยาว $4$ $20$ และ $21$ มาสร้างสามเหลี่ยม) \n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า จำนวนของแท่งไม้ $N$ จะอยู่ในช่วง $1 \\leq i \\leq N \\leq 100$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า จำนวนของแท่งไม้ $N$ จะอยู่ในช่วง $1 \\leq i \\leq N \\leq 200,\\!000$\n- ความยาวของแท่งไม้ $L_i$ จะอยู่ในช่วง $0 < L_i \\leq 10^6$","archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":false,"solution":"","imageUrls":[],"tags":["sorting","insight"],"createdAt":{"_seconds":1536321953,"_nanoseconds":962000000}},"1e995384-8029-473f-804b-59193177dc96":{"archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"D=31\n\nX=15886","imageUrls":[],"tags":[],"createdAt":{"_seconds":1541113416,"_nanoseconds":393000000},"note":"","updatedAt":{"_seconds":1541119554,"_nanoseconds":115000000},"format":{"coding":false,"ponder":false,"quickfire":false,"choices":false},"round":{"audition":false,"national":false,"regional":false},"statement":"นายเค กำลังออกแบบเกมอันหนึ่งให้เพื่อนๆเล่นกัน โดยให้เพื่อนแต่ละคนมีเงินเริ่มต้น 1 บาท  จากนั้นในแต่ละตา คนเล่นจะเลือกทำอย่างใดอย่างหนึ่งจาก actions 2 อย่างนี้\n\nA) เพิ่มเงินที่ตัวเองมีเป็นเท่าตัว\n\nB) เพิ่มเงินที่ตัวเองมีไปอีก 1 บาท\n\nโดยเกมจะกำหนดเป้าหมายเป็นจำนวนเต็ม X บาท ใครที่ทำให้เงินของตนเองมีค่าเท่ากับ X บาทได้พอดี ไม่ขาดไม่เกิน ก่อนคนอื่นก็จะชนะเกมนั้น\n\nหลังจากออกแบบแล้ว นายเคพบว่าเกมนี้สามารถหาคำตอบได้ด้วย Greedy algorithm จึงอยากปรับเปลี่ยนกฎเพื่อให้ตอบด้วย Greedy ไม่ได้ เค้าจึงได้เพิ่มทางเลือก action อย่างที่ 3 ดังนี้\n\nC) ลดเงินที่ตัวเองมีอยู่ออกไป D บาท\n\nถามว่าถ้ากำหนดค่า X=900 บาท แล้ว ค่า D น้อยที่สุดเป็นเท่าไหร่ ที่จะทำให้วิธี Greedy เดิมได้คำตอบที่ไม่ optimal\n\nและจากค่า D ข้างต้นนั้น ถ้ากำหนดให้ X<16000 บาท แล้วค่า X มากที่สุดที่คำตอบจากวิธี Greedy เดิมยังเป็นคำตอบที่ optimal ที่สุดคือเท่าไหร่"},"1ed4ed8f-1052-4011-9166-3cd107630838":{"updatedAt":{"_seconds":1538567748,"_nanoseconds":977000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"regional":true,"audition":false,"national":false},"statement":"สมมติว่าครอบครัวหนึ่ง มีลูกทั้งสิ้น 5 คน ชื่อ Dijkstra (D), Hopper (H), Lovelace (L), Neumann (N) และ Shannon (S) ซึ่งไม่เรียงลำดับใด ๆ ทั้งสิ้น\n\nต่อไปนี้จะเป็นคำบอกเล่าของแม่ 7 ประโยค ซึ่งมี 1 ประโยคเท่านั้นที่เป็นเท็จ \n\n1. Hopper มีอายุน้อยกว่า Shannon\n2. Dijkstra มีอายุน้อยกว่า Lovelace\n3. Shannon มีอายุน้อยกว่า Neumann\n4. Hopper มีอายุน้อยกว่า Dijkstra \n5. Lovelace มีอายุน้อยกว่า Shannon\n6. Shannon มีอายุน้อยกว่า Dijkstra\n7. Neumann มีอายุน้อยกว่า Lovelace\n\nจงหาว่า (a) ประโยคข้างต้นใดเป็นเท็จ และ (b) ใครเป็นพี่คนโต","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"- (a) ประโยค 5 เท็จ \"Lovelace มีอายุน้อยกว่า Shannon\"\n- (b) Lovelace เป็นพี่คนโต\n\n\n- [เพลน] ถ้าวาดกราฟโดยให้ลูกแต่ละคนแทนด้วยโหนด และเส้นเชื่อมแต่ละเส้น ลากจากคนที่อายุน้อยกว่าไปยังคนที่อายุมากกว่า (ตามคำให้การของแม่) ข้อมูลที่ conflicting จะเห็นไป cycle ครับ เราต้องลบ cycle ออกด้วยการลบเส้นเชื่อมออกหนึ่งเส้นครับ ซึ่งมี edge อันเดียวพอดีที่ทำแบบนั้นได้ \n- ข้อนี้ใช้ idea ของ graph cycle, topological ordering, directed acyclic graph ครับ","imageUrls":[],"tags":["logic-puzzle","graph-theory","60-sec"],"createdAt":{"_seconds":1538243385,"_nanoseconds":169000000},"note":"- **Author:** เพลน\n- Verified by Eak ใช้อยู่หลายนาที\n- Verified by Ju ใช้นาทีกว่าๆ"},"22702dc8-9a44-4f16-a675-5f72e36b46f1":{"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"national":false,"regional":false,"audition":true},"statement":"มีห้องทดลองที่มีหนูจำนวนมาก และมียาพิษที่รุนแรงมาก หนูทดลองดื่มแค่หยดเดียวไม่ว่าจะเจือจางแค่ไหน ก็จะตายใน 1 วันทันที\n\nแต่ปรากฏว่าขวดยาพิษถูกวางปนกับขวดน้ำเปล่า ทำให้แยกไม่ออกว่าขวดไหนเป็นยาพิษ\n\nถ้ามีขวดทั้งหมด 1,000 ขวด และมีเวลาจำกัดเพียงแค่ 1 วันเท่านั้น อยากทราบว่าต้องใช้หนูจำนวนน้อยที่สุดที่ตัว เพื่อให้รู้ว่ายาพิษคือขวดไหนภายใน 1 วัน โดยสมมติว่า: \n- หนูมีปริมาณไม่จำกัด และทุกตัวภูมิต้านทานเท่ากันหมด กินยาแล้วตายทุกตัว ในเวลา 1 วันเท่ากันหมด\n- ยาพิษและน้ำเปล่ามีปริมาณไม่จำกัด\n- ยาพิษไร้สี รส กลิ่น ไม่มีใครสามารถแยกกับน้ำเปล่าได้ โดยไม่ลองให้หนูกิน\n\n1. 1 ตัว\n2. 10 ตัว\n3. 100 ตัว\n4. 500 ตัว\n5. 999 ตัว\n6. 1,000 ตัว","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"Answer: \"10 ตัว\"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106823,"_nanoseconds":0},"note":"- Question is too well known","updatedAt":{"_seconds":1533106823,"_nanoseconds":0}},"22fa699f-bb4b-4212-aa65-8c245ffbe6cd":{"round":{"regional":false,"audition":true,"national":false},"statement":"สมมติว่าเราต้องการเขียนโปรแกรมเพื่อวิเคราะห์ข้อมูล $A[1 \\ldots n]$ ที่เป็น Array ของจำนวนเต็ม $N$ จำนวน โดยเราจะต้องรองรับ query operation ดังต่อไปนี้\n\n- เมื่อกำหนด ค่า $s$ และ $t$ ให้ โดยที่ $1 \\leq s \\leq t \\leq n$ แล้ว เราสามารถหาผมรวมของจำนวนที่อยู่ติดกันตั้งแต่ตำแหน่ง $s$ ถึง$t$ ได้ (หมายถึง $A[s] + A[s+1] + \\ldots + A[t]$)\n\nเทคนิคที่นิยมใช้แก้ปัญหาดังกล่าวมีชื่อว่า Prefix sum ซึ่งจะมีขั้นตอน Data pre-processing ดังต่อไปนี้\n- สร้าง Array ใหม่ $P[0 \\ldots n]$ โดยที่ $P[0] = 0$ และ $P[i] = P[i-1] + A[i]$ สำหรับ $1 \\leq i \\leq n$\n\nและเมื่อจะหาค่าของ $A[s] + A[s+1] + \\ldots + A[t]$ เราสามารถใช้การ\n\nข้อใดต่อไปนี้ถูกต้องสำหรับ\n\n\n\n\nสมมติว่าเราต้องการเขียนโปรแกรมเพื่อจัดการ Array ของข้อมูลจำนวนเต็ม $A[1 \\ldots n]$ โดยจะต้องรองรับ Operation ดังต่อไปนี้\n- $modify(A, i, value)$ — แก้ไขข้อมูล ณ ตำแหน่ง $i$ ของ $A$ ให้มีค่าเป็น $value$ (i.e. $A[i] := value$)\n- $sum(A, i, j, \\circ)$ — คำนวณผลรวม $A[i] + A[i+1] + \\ldots + A[j]$ \n\nเทคนิคที่ช่วยทำให้","archived":false,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":["data-structure"],"createdAt":{"_seconds":1537725969,"_nanoseconds":696000000},"note":"","updatedAt":{"_seconds":1537730049,"_nanoseconds":695000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":true}},"23373a31-c84f-463e-9a66-d8e08fa64aeb":{"note":"Counting\nVerified by อัท เพลน เอก\n- ภาคใต้ตอบถูก 1/7 ทีม","updatedAt":{"_seconds":1535330205,"_nanoseconds":345000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"ในเลขตั้งแต่ 1 ถึง 1000  ให้หาว่ามีเลขจำนวนกี่ตัวที่ผลรวมเลขโดดไม่มีเลข 1 อยู่ในผลรวมนั้น\n\nตัวอย่าง  \n- เลข 123 ได้ผลรวมคือ 1+2+3=6  ไม่มีเลข 1 อยู่ใน 6\n- เลข 67 ได้ผลรวมคือ 6+7=13  มีเลข 1 อยู่ใน 13\n","archived":true,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"308","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1533106847,"_nanoseconds":0}},"25c28ee0-40bb-425c-904b-a8ca5630a4ce":{"deleted":true,"solution":"1. C. ตอบว่า A\n2. A. ข้อย่อย 3\n3. B. B","imageUrls":[],"tags":["logic-puzzle","propose-north-regional"],"createdAt":{"_seconds":1533106820,"_nanoseconds":0},"note":"- **Category:** Math & Logical puzzle\n- **Author:** คูน\n- ทำเป็น QF regional ได้มั้ย สัก 30 วินาที น่าจะมีคนคิดออก","updatedAt":{"_seconds":1536572495,"_nanoseconds":634000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"national":false,"regional":true,"audition":false},"statement":"คำถามมี 3 ข้อย่อย\n\n**ข้อย่อย 1.** คำตอบของข้อย่อย 2. คือ?\n\n> A. ตอบว่า B  \n> B. ตอบว่า C  \n> C. ตอบว่า A\n\n**ข้อย่อย 2.** จากข้อย่อย 1. - 3. ข้อแรกที่ตอบ (b) คือ?\n\n> A. ข้อย่อย 3  \n> B. ข้อย่อย 1  \n> C. ข้อย่อย 2\n\n\n**ข้อย่อย 3.** จากข้อย่อย 1. - 2. ตัวเลือกที่ยังไม่ได้ตอบคือ?\n\n> A. A  \n> B. B  \n> C. C","archived":false,"region":{"northeast":false,"south":false,"north":true,"central":false}},"277c33d1-18a2-4d56-90e7-26fa8d66e5a4":{"region":{"central":true,"northeast":false,"south":false,"north":true},"deleted":true,"solution":"209,693 บาท (209,693.99)","imageUrls":[],"tags":["small-coding","finance"],"createdAt":{"_seconds":1533106853,"_nanoseconds":0},"note":"**Author:** เอก\n\n- [เพลน] คำถามต้องเข้าใจเรื่องการเงินหรือเปล่าฮะ? เช่นหลายคนอาจจะงงว่าการปันผลมันเป็นอย่างไรฮะ?","updatedAt":{"_seconds":1536543849,"_nanoseconds":895000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"สมชายมีเงินรางวัลจากการแข่ง TechJam อยู่ 100,000 บาท  เอาไปลงทุนในกองทุนที่ให้ผลตอบแทน 10% ทุกปี\n\nในแต่ละปี กองทุนจะแบ่งผลตอบแทน 10% นี้โดยการปันผลออกเป็นเงินสดครึ่งหนึ่ง  ส่วนอีกครึ่งหนึ่งจะนำไปลงทุนในกองทุนต่อไป โดยเงินปันผลจะถูกหักภาษี 10% ของยอดเงินปันผล \n\nสมชายจะนำเงินปันผลนี้มาเก็บไว้เป็นเงินสดเผื่อใช้ยามฉุกเฉิน จากนั้นทุกสิ้นปีสมชายจะนำเงินออกจากกองทุนอีก 2,000 บาท มาเก็บไว้รวมเป็นเงินยามฉุกเฉินเช่นกัน\n\nถามว่า เมื่อผ่านไป 10 ปี ณ สิ้นปีที่ 10 สมชายจะมีเงินทั้งหมดกี่บาท โดยปัดเศษสตางค์ทิ้ง (นับทั้งเงินเก็บเผื่อฉุกเฉิน และเงินที่อยูในกองทุน)","archived":false},"291dafe0-9251-4b6b-a6cf-6369ed4f6f96":{"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1541059439,"_nanoseconds":670000000},"note":"","updatedAt":{"_seconds":1541059439,"_nanoseconds":670000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":false},"round":{"national":false,"regional":false,"audition":false},"statement":"สมมติว่าแม่มีสมบัติอยู่จำนวนหนึ่ง สมบัติแต่ละชิ้นมีมูลค่าเป็น**จำนวนเต็ม**และ**แตกต่างกัน**ทั้งหมด &nbsp; แม่ต้องการแบ่งสมบัติเหล่านี้ให้ลูกสองคน โดยในความเป็นจริงแล้วรับประกันว่ามีวิธีที่ทำให้ลูกทั้งสองคนได้สมบัติเป็นมูลค่ารวมเท่ากัน แต่ว่าผู้เป็นแม่ตัดสินใจใช้ Greedy Algorithm ที่มีลักษณะดังนี้\n\n```pseudocode\nfunction split_inheritance(inherit_values):\n    # inherit_values is a sequence of values of\n    # inheritances to be split among siblings\n    older := empty list\n    younger := empty list\n    sort inherit_values in decreasing order\n    for each value in inherit_values:\n        if sum(older) < sum(younger) then:\n            older := older + [value]\n        else:\n            younger := younger + [value]\n        end\n    end\n    return (older, younger)\nend\n```\n","archived":false},"29cae9e9-9815-4681-98c0-b140804b0ff3":{"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1540741256,"_nanoseconds":932000000},"note":"- **Author:** เพลน\n- boring math counting question","updatedAt":{"_seconds":1540741269,"_nanoseconds":509000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":true,"regional":false},"statement":"มีคน 10 คน ต้องการยืนเรียงหนึ่งหน้ากระดานเพื่อถ่ายรูปร่วมกัน โดยมีเงื่อนไขดังนี้\n\n- A จะต้องยืนทางซ้ายมือของ B (ไม่จำเป็นต้องยืนติดกัน)\n- C จะต้องยืนทางขวามือของ D (ไม่จำเป็นต้องยืนติดกัน)\n- E จะต้องยืนอยู่ระหว่าง F และ G  (ไม่จำเป็นต้องยืนติดกัน)\n- H จะต้องยืนอยู่ริมฝั่งใดฝั่งหนึ่ง\n- I และ J ห้ามยืนติดกัน\n\nอยากทราบว่าจะมีวิธียืนเรียงกันเพื่อถ่ายรูปทั้งหมดกี่วิธี?","archived":false},"29f0eb90-f1ae-401b-bec4-3d488e1fad7b":{"note":"- **Author:** เพลน\n- should be paired with [different classrooms problem](/questions/3a20109a-f3b4-45f0-bc81-8387aa7db189)\n- อาจจะต้อง print ให้ผู้เข้าแข่งขันก่อนเริ่มอ่านคำถาม\n- [Eak] Verified .... ชอบๆ ข้อนี้สนุก และไม่ง้อคอม\n- [Group] Verified .... ชอบๆ ข้อนี้สนุก ไม่ง้อคอม และไม่ยากเกิน","updatedAt":{"_seconds":1541171976,"_nanoseconds":844000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"regional":false,"audition":false,"national":true},"statement":"มีตู้เซฟอยู่อันหนึ่ง\n\n- ตู้เซฟนี้ถูกล็อกด้วยเลขปริศนา $Q$ ความยาว 6 หลัก  (เราเรียก $Q$ ว่ารหัสผ่านจริง)\n- หากเรากดรหัสไม่ถูกต้อง ตู้เซฟจะมีเสียงร้อง พร้อมทั้งยังบอกอีกว่า “เลขโดดที่อยู่ติดกันที่ยาวที่สุดที่ปรากฏในรหัสจริง $Q$ และรหัสผ่านที่ป้อนผิดนั้นมีความยาวเท่าใด” &nbsp; พูดอีกนัยหนึ่งคือ output message จะเป็นความยาวของ longest common substring ระหว่าง Q กับรหัสผ่านที่ป้อนผิดนั่นเอง &nbsp; (เช่น ถ้ารหัสปริศนา $Q$ คือ 123456 แต่เราพิมพ์ 134579 แล้วเซฟจะให้ output message เป็น 3)\n\nต่อไปนี้เป็นประวัติการลองกดรหัสเซฟทั้งสิ้น 9 ครั้ง พร้อมทั้ง output message ในแต่ละครั้ง\n\n- try `027292` output `1`\n- try `135135` output `0`\n- try `257015` output `2`\n- try `362447` output `1`\n- try `470619` output `3`\n- try `560968` output `1`\n- try `674669` output `1`\n- try `822642` output `1`\n- try `903287` output `3`\n\nจงหารหัสเซฟที่ถูกต้องจากข้อมูลนี้","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"Answer: $Q = 287706$\n\n### How to solve by hand?\n\n1. $LCS(Q, 135135) = 0$ แปลว่ารหัสไม่มี $1, 3, 5$ อยู่แล้ว สามารถใช้เป็น separator ของรหัสที่ทดลองอื่น ๆ ได้\n2. $LCS(Q, 903287) = 3$ แปลว่ารหัสต้องมี $287$ อยู่เท่านั้น (มอง $1$ เป็น separator)\n3. $LCS(Q, 470619) = 3$ แปลว่ารหัสต้องมี $470$ หรือ $706$ อยู่เท่านั้น (มอง $1$ เป็น separator)\n4. $LCS(Q, 362447) = 1$ แปลว่า $47$ นั้นต้องห้าม ซึ่งแปลว่ารหัสต้องมี $706$ เท่านั้น \n5. ในขณะเดียวกัน $LCS(Q, 362447) = 1$ แปลว่า $Q \\neq 706287$ เพราะ $62$ นั้นต้องห้าม\n6. จะเหลือ 3 รูปแบบที่เป็นไปได้คือ $\\_28706$ หรือ $28706\\_$ หรือ $287706$ เท่านั้น\n7. $\\_28706$ เป็นไปไม่ได้ เพราะจากการทดลองหลายครั้ง ทำให้ rule out เลขโดดทุกตัวก่อน $2$\n8. $28706\\_$ เป็นไปไม่ได้ เพราะจากการทดลองหลายครั้ง ทำให้ rule out เลขโดดทุกตัวหลัง $6$\n9. จึงตอบว่า $Q = 287706$\n\n### Verification\n```python\nfrom itertools import takewhile \ndef lcs(s, t):\n    return max(\n        # longest common prefix\n        len(list(takewhile(lambda p: p[0] == p[1], zip(s[i:], t[j:]))))\n        for i in range(len(s))  # starting point for s\n        for j in range(len(t))  # starting point for t\n        )\n\nconds = [\n    (\"027292\", 1), (\"135135\", 0), (\"257015\", 2), \n    (\"362447\", 1), (\"470619\", 3), (\"560968\", 1), \n    (\"674669\", 1), (\"822642\", 1), (\"903287\", 3)\n    ]\nfor q in range(1000000):\n    q = \"{:06}\".format(q)\n    if all(lcs(q, t) == v for t, v in conds):\n        print(q)\n```","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F29f0eb90-f1ae-401b-bec4-3d488e1fad7b%2Fvaultpasscode.png?alt=media&token=5d278595-1872-44a5-9e38-3e96861f0b11"],"tags":["logic-puzzle","small-coding","used","verified"],"createdAt":{"_seconds":1541090729,"_nanoseconds":523000000}},"2bb28793-13c4-4e97-982c-9f94600acc97":{"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"Answer: 9 ครั้ง\n\n- อย่าเพิ่งหลงกลว่าจะทำ exponentiation by squaring แล้วจะได้ผลดีที่สุดเสมอไป\n    เพราะการทำ exponentiation by squaring ที่ไม่วางแผนดี ๆ อาจทำให้ใช้การคูณถึง 11 ครั้ง\n- วิธีการทำให้ได้ 9 ครั้ง คือการทำ $n \\mapsto n^5$ ซ้ำกันสามรอบ ซึ่งสามารถเขียนเป็น pseudocode ดังนี้\n   ```pseudocode\n  # Phase 1\n   r_1 =   x *   x  # x^2\n   r_2 = r_1 * r_1  # x^4\n   r_3 =   x * r_2  # x^5\n  # Phase 2\n   r_4 = r_3 * r_3  # x^10\n   r_5 = r_4 * r_4  # x^20\n   r_6 = r_3 * r_5  # x^25\n  # Phase 3\n   r_7 = r_6 * r_6  # x^50\n   r_8 = r_7 * r_7  # x^100\n   r_9 = x_6 * r_8  # x^125\n   ```\n- โค้ด python ต่อไปนี้เพื่อ verify ว่าใช้การคูณ 9 ครั้งเป็น optimal solution\n   ```python\n   from itertools import count, product\n   \n   def find_target(target):\n       epoch = frozenset([1])\n       if target == 1:\n           return epoch\n       queue = [frozenset([1])]\n       seen = set(queue)\n       if target == 1:\n           return queue\n       for i in count():\n           comb = queue[i]\n           for s, t in product(comb, repeat=2):\n               new_comb = comb | {s + t}\n               if s + t == target:\n                   return new_comb\n               if new_comb not in seen:\n                   queue.append(new_comb)\n                   seen.add(new_comb)\n   ```\n- มี 48 วิธี\n   ```\n   {1, 2, 3, 5, 10, 15, 25, 50, 100, 125}\n   {1, 2, 3, 5, 10, 15, 25, 50, 75, 125}\n   {1, 2, 3, 5, 10, 15, 30, 60, 65, 125}\n   {1, 2, 3, 5, 10, 15, 30, 60, 120, 125}\n   {1, 2, 3, 5, 10, 20, 40, 60, 65, 125}\n   {1, 2, 3, 5, 10, 20, 40, 60, 120, 125}\n   {1, 2, 3, 5, 10, 20, 40, 45, 80, 125}\n   {1, 2, 3, 5, 10, 20, 40, 45, 85, 125}\n   {1, 2, 3, 5, 10, 20, 40, 80, 85, 125}\n   {1, 2, 3, 5, 10, 20, 40, 80, 120, 125}\n   {1, 2, 3, 5, 10, 20, 25, 50, 100, 125}\n   {1, 2, 3, 5, 10, 20, 25, 50, 75, 125}\n   {1, 2, 3, 5, 10, 20, 30, 60, 65, 125}\n   {1, 2, 3, 5, 10, 20, 30, 60, 120, 125}\n   {1, 2, 3, 6, 12, 13, 25, 50, 100, 125}\n   {1, 2, 3, 6, 12, 13, 25, 50, 75, 125}\n   {1, 2, 3, 6, 12, 24, 25, 50, 100, 125}\n   {1, 2, 3, 6, 12, 24, 25, 50, 75, 125}\n   {1, 2, 4, 5, 10, 15, 25, 50, 100, 125}\n   {1, 2, 4, 5, 10, 15, 25, 50, 75, 125}\n   {1, 2, 4, 5, 10, 15, 30, 60, 65, 125}\n   {1, 2, 4, 5, 10, 15, 30, 60, 120, 125}\n   {1, 2, 4, 5, 10, 20, 25, 50, 100, 125}\n   {1, 2, 4, 5, 10, 20, 25, 50, 75, 125}\n   {1, 2, 4, 5, 10, 20, 40, 45, 80, 125}\n   {1, 2, 4, 5, 10, 20, 40, 45, 85, 125}\n   {1, 2, 4, 5, 10, 20, 40, 60, 65, 125}\n   {1, 2, 4, 5, 10, 20, 40, 60, 120, 125}\n   {1, 2, 4, 5, 10, 20, 40, 80, 85, 125}\n   {1, 2, 4, 5, 10, 20, 40, 80, 120, 125}\n   {1, 2, 4, 5, 10, 20, 30, 60, 65, 125}\n   {1, 2, 4, 5, 10, 20, 30, 60, 120, 125}\n   {1, 2, 4, 6, 12, 13, 25, 50, 100, 125}\n   {1, 2, 4, 6, 12, 13, 25, 50, 75, 125}\n   {1, 2, 4, 6, 12, 24, 25, 50, 100, 125}\n   {1, 2, 4, 6, 12, 24, 25, 50, 75, 125}\n   {1, 2, 4, 8, 16, 17, 25, 50, 100, 125}\n   {1, 2, 4, 8, 16, 17, 25, 50, 75, 125}\n   {1, 2, 4, 8, 16, 24, 25, 50, 100, 125}\n   {1, 2, 4, 8, 16, 24, 25, 50, 75, 125}\n   {1, 2, 4, 8, 9, 16, 25, 50, 100, 125}\n   {1, 2, 4, 8, 9, 16, 25, 50, 75, 125}\n   {1, 2, 4, 8, 9, 17, 25, 50, 100, 125}\n   {1, 2, 4, 8, 9, 17, 25, 50, 75, 125}\n   {1, 2, 4, 8, 12, 13, 25, 50, 100, 125}\n   {1, 2, 4, 8, 12, 13, 25, 50, 75, 125}\n   {1, 2, 4, 8, 12, 24, 25, 50, 100, 125}\n   {1, 2, 4, 8, 12, 24, 25, 50, 75, 125}\n   ```","imageUrls":[],"tags":["arithmetic","optimization","divide-and-conquer","edge-cases"],"createdAt":{"_seconds":1538406344,"_nanoseconds":678000000},"note":"- **Author:** เพลน\n- **Verified** Aof","updatedAt":{"_seconds":1538623890,"_nanoseconds":530000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"national":false,"regional":true,"audition":false},"statement":"กำหนดให้มี Input ทั้งสิ้น 2 จำนวน ได้แก่ (1) จำนวนจริง $x$ และ (2) จำนวนเต็มบวก $n$ \n\nเป้าหมายคือ เราต้องการคำนวณค่าของ $x^n$ โดยใช้ Operation การคูณเป็น**จำนวนครั้งน้อยที่สุด** ภายใต้เงื่อนไขว่า\n- อนุญาตให้ใช้เฉพาะ Operation การคูณ\n- อนุญาตให้นำผลคูณที่เกิดขึ้นก่อนหน้านั้นระหว่างการคำนวณ มาใช้เป็นตัวตั้งหรือตัวคูณของการคูณครั้งถัดไปได้  \n   (หมายความว่า เรามีการจดบันทึกผลการคูณที่เกิดขึ้นทั้งหมด คล้ายกับ history tape ในเครื่องคิดเลขของนักบัญชี)\n\n### ตัวอย่าง\nสมมติว่าเราต้องการคำนวณ $x^n$ ในกรณีที่ $n = 6$ เราจะใช้การคูณเป็นจำนวนครั้งน้อยที่สุดเพียง 3 ครั้งเท่าน้้น เขียนเป็นขั้นตอนวิธีได้ดังนี้\n```pseudocode\nr_1 := x * x      # => x^2\nr_2 := r_1 * r_1  # => x^4\nr_3 := r_1 * r_2  # => x^6\n```\nสังเกตว่า จากข้อมูล $x$ ที่เราทราบ เราจะคำนวณหา $x^2$, $x^4$ และ $x^6$ ตามลำดับ  \n(**หมายเหตุ:** นอกเหนือจากวิธีข้างต้นนี้ ยังมีวิธีอื่นอีก เช่น การคำนวณหา $x^2$, $x^3$ และ $x^6$ ตามลำดับ)\n\n### โจทย์\nการคำนวณหาค่าของ $x^n$ ในกรณีที่ $n=125$ (นั่นคือให้คำนวณค่าของ $x^{125}$) จะใช้ Operation การคูณเป็นจำนวนน้อยที่สุดกี่ครั้ง และการคูณในแต่ละขั้นนั้น คำนวณ $x^{???}$ อะไรบ้าง ตามลำดับ (ให้ตอบมา 1 วิธี)","archived":true},"2f5e3bc3-a092-452f-ad78-fad52f52289a":{"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":true,"solution":"1/64","imageUrls":[],"tags":[],"createdAt":{"_seconds":1539140107,"_nanoseconds":106000000},"note":"- **Author:** Ball\n- [เพลน] ผมลองคำนวณได้ $\\frac{1}{64} - \\frac{1}{8192}$ T T","updatedAt":{"_seconds":1539231937,"_nanoseconds":381000000},"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false},"round":{"audition":false,"national":true,"regional":false},"statement":"There are 128 teams in a single elimination tournament. Team TechJelly and team TechMarmalade are two of\nthese teams. Each of the 128 teams in the tournament is equally strong, so during each match, each\nteam has an equal probability of winning. Now, the 128 teams are randomly put into the bracket.\nWhat is the probability that TechJelly play TechMarmalade sometime during the tournament?","archived":false},"300fdf45-1289-46b3-8383-aad1bb471113":{"format":{"quickfire":true,"choices":false,"coding":false,"ponder":false},"round":{"audition":false,"national":false,"regional":true},"statement":"กำหนดให้มีฟังก์ชัน $sort\\_inplace(L, p, q)$ ซึ่งทำหน้าที่จัดเรียงจำนวนใน Array $L$ เฉพาะตำแหน่ง $p$ ไปจนถึงตำแหน่ง $q$ จากน้อยไปมาก โดยที่จำนวนอื่น ๆ ใน Array $L$ จะไม่เปลี่ยนแปลง\n\n- เช่น ถ้ากำหนดให้ $L_0 = [4, 2, 7, 3, 8, 1, 5]$ แล้วเมื่อเรียกฟังก์ชัน $sort\\_inplace(L_0, 2, 5)$ แล้วค่าของ $L_0$ จะเปลี่ยนเป็น $L_0 = [4, 2, 1, 3, 7, 8, 5]$\n\nเราจะนำฟังก์ชัน $sort\\_inplace$ ดังกล่าวนี้มาใช้งานเพื่อเขียนฟังก์ชันใหม่ $slider\\_sort\\_inplace$ ซึ่งมีกระบวนการทำงานดังต่อไปนี้\n\n```pseudocode\nfunction slider_sort_inplace(L, k):\n    n := L.length()\n    for i := 0, 1, 2, …, n-k do:\n        # เรียงลำดับจำนวนที่ติดกัน k จำนวนใน L\n        sort_inplace(L, i, i+k-1)\n    end\nend\n```\n\nสมมติว่าเรามี Array $L_1$ ซึ่งประกอบด้วยจำนวนเต็ม 250 จำนวน อยากทราบว่า เราจะต้องเรียกใช้งานคำสั่ง $slider\\_sort\\_inplace(L_1, k=25)$ นี้ซ้ำ ๆ กันกี่ครั้งจึงจะรับประกันว่าค่าทั้งหมดของ Array $L_1$ จะเรียงลำดับจากน้อยไปมาก?","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"Answer: 11 รอบ\n\n- ฟังก์ชัน $slider\\_sort\\_inplace$ เปรียบเสมือน inner loop ของ bubble sort\n- แต่แทนที่เราจะ**เปรียบเทียบ**จำนวนที่อยู่ติดกันใน Array ทีละ 2 จำนวน (เพื่อเลื่อนค่าที่มากที่สุดเพียง 1 ตัวไปอยู่ท้าย Array) ในกรณีนี้เราเปรียบเทียบจำนวนที่อยู่ติดกันใน Array ทีละ 25 จำนวน (เพื่อเลื่อนค่าที่มากที่สุด 24 ตัวไปท้าย Array)\n- ดังนั้นจึงต้องเรียกใช้ $slider\\_sort\\_inplace$ ทั้งสิ้น $\\left\\lceil\\frac{250-1}{25-1}\\right\\rceil = 11$ รอบ","imageUrls":[],"tags":["algorithms","sorting","30-sec"],"createdAt":{"_seconds":1537855328,"_nanoseconds":188000000},"note":"- **Author:** เพลน\n- Adapt มาจากโจทย์พี่จิ โดยมีโครงสร้างคล้ายข้อในรอบ Audition","updatedAt":{"_seconds":1538640747,"_nanoseconds":932000000}},"30c578ff-5784-455f-8153-a52d304c1c2b":{"round":{"regional":true,"audition":false,"national":false},"statement":"จงพิจารณา pseudocode ต่อไปนี้ ว่าได้ผลลัพธ์เป็นค่าอะไร?\n\n```pseudocode\nsentence := \"My name is James. I love Technical Challenge.\"\nwords := split(str, \" \")  # array of words split by spaces\na := words[6].substring(0, 4)\nb := words[3].substring(0, 3)\nc := (words[0].length * 1000) + 18\nprint(string_concat(a, b, c))\n```\n\n**หมายเหตุ:** Array เป็น zero-indexed","archived":false,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":["code-peeking"],"createdAt":{"_seconds":1533106855,"_nanoseconds":0},"note":"- 30 sec, first question of regional event\n- [เอก] ขออนุญาตแก้คำใน string ให้ถูก grammar\n- [เพลน] ผมคิดว่าคำว่า `split` และ `substring` ค่อนข้างคลุมเครือขึ้นกับภาษาฮะ อาจต้องแก้ไขก่อนนำไปใช้ฮะ","updatedAt":{"_seconds":1534930777,"_nanoseconds":609000000},"format":{"quickfire":true,"choices":false,"coding":false,"ponder":false}},"31118bb3-4499-440d-909e-5598d3531af8":{"createdAt":{"_seconds":1535334966,"_nanoseconds":8000000},"note":"- *จิ*แปลงจากโจทย์ Codility coding Medium มาเป็น fix test case Ponder\n- *เอก* คิดมาได้ 372 ใครช่วย verify ที\n- *เอก* สงสัยว่าเวลาที่ใช้เลขแค่ตัวเดียว นับหรือไม่นับ เช่น 11:11:11\n- *อ๊อฟ* คิดได้ 371 ไม่นับเคสที่ใช้เลขตัวเดียว รอคนต่อไปมาตอบ\n- *เอก* ได้ตรงกะอ๊อฟ ถ้าไม่นับเคสเลขเดียวก็จะได้ 371 เท่ากัน\n- *เอก* **Change log:** แก้โจทย์เป็น \"ไม่เกิน 2 ตัว\" ได้คำตอบ 372 (verified)","updatedAt":{"_seconds":1536575782,"_nanoseconds":588000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"** หาเวลาเลขสวย **\n\nกำหนดให้มีนาฬิกา Digital อยู่ตัวหนึ่ง มีรูปแบบการแสดงผลเป็น HH:MM:SS โดยเป็นเวลา ชั่วโมง:นาที:วินาที (แบบ 24 ชั่วโมง)\n\nและกำหนดให้ \"เลขสวย\" คือเวลาที่แสดงผลด้วยตัวเลข__ไม่เกินสองตัว__เท่านั้น เช่น \n- 13:13:13 เป็นเลขสวย เนื่องจากแสดงผลได้ด้วยเลข 1 และ 3 เพียงสองตัวเท่านั้น\n- 23:00:00 ไม่เป็นเลขสวย เนื่องจากต้องใช้ตัวเลข 3 ตัวในการแสดงผล\n\nจงหาว่า ในช่วงเวลาตั้งแต่ 00:01:23 ถึง 21:21:23 มีเลขสวยทั้งหมดกี่ตัว?","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false},"deleted":false,"solution":"372","imageUrls":[],"tags":["counting","text-processing"]},"35e47c0b-5be1-4a23-9a73-fcc777652fab":{"round":{"regional":false,"audition":true,"national":false},"statement":"The time complexity of g(n, x, y) is O(n). What is the time complexity of f(n)?\n\n```pseudocode\nfunction f(integer n):\n     if n ≤ 1:\n          return 1\n      x = f(n/2)\n      y = f(n/2)\n      return g(n, x, y)\n```\n\n1. $O(\\log n)$\n2. $O(n)$\n3. $O(n \\cdot \\log n)$\n4. $O(n \\cdot n)$","archived":true,"region":{"northeast":true,"south":false,"north":false,"central":false},"deleted":false,"solution":"\"3\"","imageUrls":[],"tags":["big-o-analysis"],"createdAt":{"_seconds":1535332670,"_nanoseconds":393000000},"note":"- จิ copy จาก codility","updatedAt":{"_seconds":1536575707,"_nanoseconds":56000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true}},"376c0ed4-6be0-49d2-a397-b215a664c2f1":{"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"national":false,"regional":false,"audition":true},"statement":"สมมติว่าเราต้องการสร้างรูปเรขาคณิตใหม่ โดยนำชิ้นส่วนจัตุรัสขนาด 1 ตารางหน่วยอย่างน้อย 1 ชิ้นมาประกอบกัน โดยมีเงื่อนไขดังต่อไปนี้\n\n- รูปเรขาคณิตใหม่จะต้องไม่มีชิ้นส่วนที่แยกจากกัน (ยกตัวอย่างเช่นรูป (c) ใช้ไม่ได้)\n- รูปเรขาคณิตใหม่จะต้องไม่มีรูหรือช่องว่างภายในรูปปิด (ยกตัวอย่างเช่นรูป (d) ใช้ไม่ได้)\n- รูปเรขาคณิตใหม่จะต้องมีทุกด้านยาว 1 หน่วยเท่านั้น (ยกตัวอย่างเช่นรูป (e) หรือ (f) ใช้ไม่ได้ เพราะมีบางด้านยาว 2 หน่วย หรือ 0.5 หน่วย)\n\nสังเกตว่า หากเรามีชิ้นส่วนจัตุรัส 1 ชิ้นพอดี หรือ 5 ชิ้นพอดี (จากรูปตัวอย่าง (a) และ (b) ตามลำดับ) เราสามารถสร้างรูปเรขาคณิตที่สอดคล้องกับเงื่อนไขข้างต้นได้ … อย่างไรก็ดี เราไม่สามารถสร้างรูปเรขาคณิตตามเงื่อนไขดังกล่าวได้เลย หากเรามีชิ้นส่วนจัตุรัสเพียง 2 หรือ 3 หรือ 4 ชิ้นเท่านั้น\n\nจงหาจำนวนชิ้นส่วนจัตุรัสที่มากที่สุดที่ไม่สามารถนำมาประกอบเป็นรูปเรขาคณิตตามเงื่อนไขข้างต้นได้\n\n1. 6 ชิัน\n1. 7 ชิัน\n1. 8 ชิัน\n1. 9 ชิัน\n1. 10 ชิัน\n1. 11 ชิัน\n1. 12 ชิัน\n1. 13 ชิัน\n1. 14 ชิัน\n1. 15 ชิัน\n1. 16 ชิัน\n1. 17 ชิัน\n1. 18 ชิัน\n1. 19 ชิัน\n1. 20 ชิัน\n1. 21 ชิัน\n1. 22 ชิัน\n1. 23 ชิัน\n1. 24 ชิัน\n1. 25 ชิัน\n1. 26 ชิัน\n1. 27 ชิัน\n1. 28 ชิัน\n1. 29 ชิัน\n1. 30 ชิัน","archived":true,"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"10 ชิ้น","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F376c0ed4-6be0-49d2-a397-b215a664c2f1%2Fblocks.png?alt=media&token=ea22ceb5-e7a3-4c32-aa07-994b266374b0"],"tags":["counting","logic-puzzle","math-induction"],"createdAt":{"_seconds":1533106842,"_nanoseconds":0},"note":"- **Author:** เพลน\n- Verified by Eak","updatedAt":{"_seconds":1537765005,"_nanoseconds":691000000}},"3983add7-a203-4e7f-a4ad-66f261c67849":{"imageUrls":[],"tags":["small-coding","dynamic-programming","math-induction"],"createdAt":{"_seconds":1533106833,"_nanoseconds":0},"note":"- **Author:** เพลน\n- Verified by Eak (เขียน code dp ยาวกว่าเพลนไปเยอะเลย เริ่มอิจฉา python...), Aof","updatedAt":{"_seconds":1538468671,"_nanoseconds":7000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"regional":true,"audition":false,"national":false},"statement":"**ยกตัวอย่าง:** สมมติว่าลูกอมยี่ห้อหนึ่ง ถูกบรรจุขายเป็นแพ็คถุง 2 ขนาด คือแบบถุงละ 3 ลูก หรือ 5 ลูก สังเกตว่า\n- เราสามารถซื้อลูกอมให้มีลูกอม**เป็นจำนวนรวม** 8 ลูกได้ (คือซื้อทั้งสองแบบ แบบละ 1 ถุง แล้วนำลูกอมมาเทรวมกัน)\n- แต่เราไม่มีวิธีที่สามารถซื้อลูกอมเป็นจำนวนรวม 7 ลูกพอดีได้เลย\n\n**สำหรับโจทย์ข้อนี้** สมมติว่ามีลูกอมอีกยี่ห้อหนึ่ง ถูกบรรจุขายเป็นแพ็ค 3 ขนาด คือแบบถุงละ 6 ลูก หรือ 15 ลูก หรือ 40 ลูก ตามลำดับ\n\nจำนวนลูกอมที่มากที่สุดที่เรา**ไม่สามารถ**หาวิธีซื้อให้พอดีจากการผสมแพ็คลูกอมทั้ง 3 แบบนี้ มีจำนวนลูกอมเท่าใด?","archived":true,"region":{"central":true,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"Answer: 89\n\n#### General solution for python:\n```python\ndef find_impossibles(sizes):\n    \"\"\"\n    Find impossible number of candies.\n    >>> find_impossibles([3, 5])\n    \"\"\"\n    from itertools import count\n    impossibles = set()\n    limit = min(sizes)\n    for v in count(1):\n        if v >= limit and all(v-s not in impossibles for s in range(1, 1+limit)):\n            break\n        if all(v < s or v-s in impossibles for s in sizes):\n            impossibles.add(v)\n    return impossibles\n```"},"39eeb410-b892-408a-ad8e-e6d87dcd091f":{"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":false,"solution":"\"2\" ฟังก์ชัน square-root แต่ปัดเศษทิ้งเป็นจำนวนเต็มเสมอ (round down)","imageUrls":[],"tags":["code-peeking","edge-cases"],"createdAt":{"_seconds":1535372471,"_nanoseconds":424000000},"note":"","updatedAt":{"_seconds":1536575831,"_nanoseconds":178000000},"format":{"ponder":true,"quickfire":false,"choices":true,"coding":false},"round":{"national":false,"regional":false,"audition":true},"statement":"โปรแกรมต่อไปนี้ทำงานอะไร\n\n```pseudocode\ninput: positive integer N\noutput: ???\n\nlb := 0\nub := N\nloop:\n   attempt := floor((lb + ub)/2) # floor = round-down\n   if N < attempt^2:\n      ub := attempt - 1\n   else if N >= (attempt + 1)^2:\n      lb := attempt + 1\n   else: \n      return attempt\n```\n\n1. ฟังก์ชัน square-root แต่ปัดเศษเป็นจำนวนเต็มที่ใกล้ที่สุดเสมอ (round to nearest integer)\n2. ฟังก์ชัน square-root แต่ปัดเศษทิ้งเป็นจำนวนเต็มเสมอ (round down)\n3. ฟังก์ชัน square-root แต่ปัดเศษขึ้นเป็นจำนวนเต็มเสมอ (round up)\n4. ฟังก์ชัน square-root แต่เศษอาจถูกปัดขึ้นหรือลงอย่างไรก็ได้ ไม่สามารถคาดเดาได้\n5. ฟังก์ชันติด infinite loop ไม่รู้จบ","archived":true},"3a20109a-f3b4-45f0-bc81-8387aa7db189":{"imageUrls":[],"tags":["logic-puzzle","graph-theory","used","verified"],"createdAt":{"_seconds":1541087856,"_nanoseconds":464000000},"note":"- **Author:** เพลน\n- should be paired with [vault password problem](/questions/29f0eb90-f1ae-401b-bec4-3d488e1fad7b)\n- [Group] verified","updatedAt":{"_seconds":1541132241,"_nanoseconds":729000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"regional":false,"audition":false,"national":true},"statement":"ในโรงเรียนแห่งหนึ่ง มีห้องเรียนชั้น ป.1 อยู่ 2 ห้อง ได้แก่ห้องทานตะวัน และห้องกุหลาบ \n\nเด็กชาย K มีเพื่อนอยู่ 8 คน แต่ละคนมีชื่อย่อว่า A, B, C, D, E, F, G และ H\n- บางคนเรียนอยู่ห้องทานตะวันเช่นเดียวกับเด็กชาย K \n- ส่วนบางคนเรียนอยู่ห้องกุหลาบ  คนละห้องกับเด็กชาย K\n\nต่อไปนี้คำบอกกล่าวของครูใหญ่ทั้งสิ้น 14 ประโยค\n\n1. A กับ B เรียนอยู่คนละห้องกัน\n2. B กับ C เรียนอยู่คนละห้องกัน\n3. C กับ D เรียนอยู่คนละห้องกัน\n4. D กับ E เรียนอยู่คนละห้องกัน\n5. E กับ A เรียนอยู่คนละห้องกัน\n6. A กับ F เรียนอยู่คนละห้องกัน\n7. F กับ G เรียนอยู่คนละห้องกัน\n8. G กับ H เรียนอยู่คนละห้องกัน\n9. H กับ D เรียนอยู่คนละห้องกัน\n10. D กับ B เรียนอยู่คนละห้องกัน\n11. B กับ E เรียนอยู่คนละห้องกัน\n12. E กับ C เรียนอยู่คนละห้องกัน\n13. C กับ K เรียนอยู่คนละห้องกัน\n14. K กับ G เรียนอยู่คนละห้องกัน\n\nในบรรดา 14 ประโยคข้างต้น มี 2 ประโยคที่ไม่เป็นความจริง จงตอบคำถามต่อไปนี้\n\n1. ประโยคใดเป็นเท็จบ้าง?\n2. ใครเรียนอยู่ห้องทานตะวันเช่นเดียวกับเด็กชาย K บ้าง?","archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"1. ประโยค 3 & 11 เป็นเท็จ (C–D และ B–E)\n2. K อยู่ห้องเดียวกับ B, E, F, H"},"3a5dcc56-17ca-463f-976e-d1c68b227601":{"updatedAt":{"_seconds":1536575814,"_nanoseconds":749000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true},"round":{"regional":false,"audition":true,"national":false},"statement":"กำหนดให้ Binary Search Tree หนึ่งมีตัวเลขตั้งแต่ 1 ถึง 100 ปรากฏอยู่ หากเราต้องการ traverse ในต้นไม้ดังกล่าว ลำดับที่เกิดจาก Tree Traversal ข้อใดต่อไปนี้ไม่สามารถเกิดขึ้นได้?\n\n\n1. 24,21,15,16,19,17\n2. 43,50,66,64,60,59\n3. 3,24,43,21,33,35\n4. 24,43,50,66,77,93\n","archived":true,"region":{"northeast":true,"south":false,"north":false,"central":false},"deleted":false,"solution":"\"3.\" 3,24,43,21,33,35","imageUrls":[],"tags":["data-structure"],"createdAt":{"_seconds":1535372345,"_nanoseconds":498000000},"note":""},"3c923209-8387-4941-a0bc-c9ef942267e6":{"note":"**Author:** เพลน","updatedAt":{"_seconds":1537350144,"_nanoseconds":829000000},"format":{"ponder":false,"quickfire":false,"choices":false,"coding":true},"round":{"audition":false,"national":false,"regional":true},"statement":"# shipping-dolls\n\n### Problem Statement\n\nโรงงานแห่งหนึ่งรับจ้างผลิตตุ๊กตาแบบสั่งทำพิเศษ อยู่มาวันหนึ่งมีลูกค้า A มาติดต่อจ้างให้ผลิตตุ๊กตาทั้งสิ้น $N$ ตัว ตุ๊กตาแต่ละตัวมีหมายเลขกำกับ $i = 1, 2, \\ldots, N$ นอกจากนั้น ตุ๊กตาตัวที่ $i$ จะมีน้ำหนัก $w_i$ กรัม ซึ่งอาจเท่ากันหรือต่างกันก็ได้\n\nเมื่อโรงงานแห่งนี้ผลิตตุ๊กตาเสร็จเป็นที่เรียบร้อยแล้ว โรงงานจะต้องขนส่งตุ๊กตาทั้งหมดนี้ให้ลูกค้า A ... โรงเรียนสามารถเลือกขนส่งตุ๊กตา**แต่ละตัว**ได้ 2 วิธี คือ (1) บรรจุตุ๊กตาลงในกล่องพัสดุที่จำกัดน้ำหนัก หรือ (2) บรรจุตุ๊กตาลงถุงกระสอบที่จำกัดจำนวนตุ๊กตา โดยมีเงื่อนไขว่า\n\n- การขนส่งอาจใช้กล่องหลายใบก็ได้ กล่องแต่ละใบจุของน้ำหนักรวมไม่เกิน $L$ กรัม\n- การขนส่งสามารถใช้ถุงกระสอบได้เพียงถุงเดียว และใส่ตุ๊กตาได้ไม่เกิน $M$ ตัว (ไม่จำกัดน้ำหนัก)\n- หากตุ๊กตาหมายเลขที่ $s$ และตุ๊กตาหมายเลขที่ $t$ จะต้องถูกบรรจุลงในกล่องเดียวกันแล้ว ตุ๊กตาตัวอื่น ๆ ทุกตัวที่มีหมายเลขระหว่างนั้น (หมายถึงตุ๊กตาหมายเลขที่ $i$ ซึ่ง $s < i < t$) จะต้องถูกบรรจุ**ในกล่องใบเดียวกันด้วย** หรือจะต้องถูกบรรจุ**ในถุงกระสอบ**เท่านั้น\n\n#### Main Goal\n\nโรงงานต้องการขนส่งตุ๊กตาทั้งหมดให้ลูกค้า $A$ โดยใช้จำนวนกล่องให้น้อยที่สุด จะต้องใช้กล่องทั้งหมดกี่ใบ?\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มสามตัว $N, L, M$ คั่นด้วยช่องว่าง\n- อีก $N$ บรรทัดถัดมา บรรทัดที่ $i+1$ จะมีจำนวนเต็ม $w_i$ ระบุน้ำหนักของตุ๊กตาตัวที่ $i$  \n\n$$\n\\begin{aligned}\n& N\\; L\\; M \\\\\n& w_1 \\\\\n& w_2 \\\\\n& \\vdots \\\\\n& w_N\n\\end{aligned}\n$$\n\n#### Output Format\n\n- คำตอบประกอบด้วยจำนวนเต็มตัวเดียว ซึ่งระบุจำนวนกล่องที่น้อยที่สุดที่สามารถใช้ขนส่งตุ๊กตาทั้งหมด ตามเงื่อนไขโจทย์ข้างต้น\n\n### Example #1 \n\n#### Input\n```text\n6 5 1\n1\n2\n3\n2\n1\n4\n```\n\n#### Output\n```text\n2\n```\n\n(หมายเหตุ: หยิบตุ๊กตาตัวที่ $i=3$ ซึ่ง $w_i = 3$ ใส่ถุง จากนั้นหยิบตุ๊กตาตัวที่ $1,2,4$ ใส่กล่องใบแรก และตัวที่ $5, 6$ ใส่กล่องใบที่สอง)\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า $1 \\leq N \\leq 250$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า $1 \\leq N \\leq 2500$\n- นอกจากนั้นกำหนดให้ $1 \\leq L \\leq 10^8, 0 \\leq M \\leq N$ และตุ๊กตาแต่ละตัวมีนำหนัก $1 \\leq w_i \\leq L$","archived":true,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"https://drive.google.com/drive/folders/19n2QppDh5aoaF0JWy7cNaXHOZ6CqvFOp","imageUrls":[],"tags":["dynamic-programming"],"createdAt":{"_seconds":1533106845,"_nanoseconds":0}},"3e8aac82-8dc1-4854-89df-6beb454d6658":{"createdAt":{"_seconds":1537173458,"_nanoseconds":424000000},"note":"- แข่งปกติ 9 รอบ แล้วเอา top กับ last มาแข่งต่ออย่างละ 2 รอบ","updatedAt":{"_seconds":1537345650,"_nanoseconds":748000000},"format":{"quickfire":true,"choices":false,"coding":false,"ponder":false},"round":{"regional":true,"audition":false,"national":false},"statement":"## เวอร์ชันภาษาไทย\n\nธนาคารกสิกรจัดประเพณีวิ่งควายที่จังหวัดชลบุรี มีควายร่วมเข้าประกวดวิ่งจำนวน 45 ตัว แต่ภายในงานมีลู่ให้ควายวิ่งได้แค่รอบละ 5 ตัวเท่านั้น\n\nหากธนาคารต้องการหาควายที่วิ่งเร็วที่สุดและช้าที่สุด อย่างละ 1 ตัว จะต้องจัดการแข่งขันอย่างน้อยกี่รอบ?\n\n**หมายเหตุ:** สมมติว่าควายวิ่งด้วยอัตราเร็วเท่าเดิมตลอดทุกรอบ โดยไม่สามารถใช้นาฬิกาจับเวลาได้\n\n## English Version\n\nKasikornbank is organizing a buffalo race in Chonburi Province. There are 45 buffalos in total; however, there is only enough space for 5 horses to race in each heat.\n\nSuppose that if the bank would like to determine an absolute fastest horse and an absolute slowest horse from the herd, what is the least number of heats the bank needs to organize for such event?\n\n**N.B.** Assume that every buffalo runs at a constant speed, and stopwatches are not allowed.","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"13","imageUrls":[],"tags":[]},"417aa333-f736-4dc8-a35c-c5a782fed1ba":{"updatedAt":{"_seconds":1537352960,"_nanoseconds":955000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"regional":true,"audition":false,"national":false},"statement":"## เวอร์ชันภาษาไทย\n\nกำหนดให้ $A$ เป็น Array ของเลขจำนวนเต็มดังต่อไปนี้\n\n$$\nA = [133, 60, 96, 130, 125, 65, 482, 88, 220, 165, 25, 45] \n$$\n\nจงเลือกจำนวน 3 จำนวนที่ไม่ซ้ำกันจาก $A$ แล้วหาผลคูณที่ลงท้ายด้วยเลขโดด 0 เยอะที่สุด **ผลคูณดังกล่าวมีค่าเท่าใด?** \n\n## English Version\n\nGiven an array $A$ of integers as follows.\n\n(declaration)\n\nWe are going to choose 3 distinct elements from $A$ so that their product has the maximum number of trailing zeros. What is the value of such product?","archived":true,"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"300,000","imageUrls":[],"tags":["counting","small-coding","propose-north-audition"],"createdAt":{"_seconds":1533106824,"_nanoseconds":0},"note":"- **Category:** Counting / corner cases\n- **Author:** เอก\n- Requires modification to fit **regional**\n- [เอก] ถ้าใช้รอบ regional ponder ก็เอา list ยาวขึ้นดีมั้ย? (เพื่อไม่ให้ทดกระดาษแล้วตอบได้) และถามเจาะจงขึ้นว่าต้องเลือก 3 ตัวไหน แล้วจะได้ 0 ลงท้ายกี่ตัว\n- [เอก] 96x125x25=300,000"},"42d31897-0625-4ab7-a3b9-7ae5eba8f55d":{"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"","imageUrls":[],"tags":["dynamic-programming"],"createdAt":{"_seconds":1537333537,"_nanoseconds":752000000},"note":"","updatedAt":{"_seconds":1537376202,"_nanoseconds":490000000},"format":{"quickfire":false,"choices":false,"coding":true,"ponder":false},"round":{"regional":true,"audition":false,"national":false},"statement":"[โจทย์ภาษาไทยคลิกที่นี่](/questions/3c923209-8387-4941-a0bc-c9ef942267e6)\n\n# shipping-dolls [English Version]\n\n### Problem Statement\n\nSuppose that there exists a factory whose job is to produce custom-made dolls. One day, customer A reached out to the factory and order a production of $N$ distinct dolls, each with label $i = 1, 2, \\ldots, N$. In addition, each doll $i$ must weigh exactly $w_i$ grams. The weights of any pairs of dolls are not necessarily distinct.\n\nOnce the factory has completed the production of these doll, the next step is to ship out these dolls to customer A. For each single doll, there are 2 shipping options: (1) pack the doll inside a weight-limited cardboard box, or (2) pack the doll inside a sack which has an upper limit on the number of dolls. Here are a few shipping constraints:\n\n- In the entire shipping process, multiple cardboard boxes may be used. But each box has the upper weight limit of $L$ grams.\n- In the entire shipping process, there is only one sack, and it could contain at most $M$ dolls. (There is no weight limit.)\n- If two dolls, one with label $s$ and another with label $t$, are to be packed inside the same cardboard box, then each of the dolls whose label is in between (that is the label $i$ where $s < i < t$) either must also be **within the same box**, or otherwise, must be **inside the sack**.\n\n#### Main Goal\n\nThe factory has to figure out what is the minimum number of cardboard boxes required to ship all of these dolls of customer A.\n\n### Program Specification\n\nThe program you write must read the input data from standard input, and the answer should be written to standard output. The data has the following format.\n\n#### Input Format\n\n- Line #1: there are three integers $N$, $L$, and $M$, separated by spaces\n- For each of the next $N$ lines: line #($i+1$) contains a single integer $w_i$ denoting the weight of the $i$-th doll.\n\n$$\n\\begin{aligned}\n& N\\; L\\; M \\\\\n& w_1 \\\\\n& w_2 \\\\\n& \\vdots \\\\\n& w_N\n\\end{aligned}\n$$\n\n#### Output Format\n\n- The output should be a single integer describing the minimum number of cardboard boxes required to shipping all of the dolls ordered by customer A, subjecting to the aforementioned shipping constraints.\n\n\n### Example #1 \n\n#### Input\n```text\n6 5 1\n1\n2\n3\n2\n1\n4\n```\n\n#### Output\n\n```text\n2\n```\n(N.B. Pack the doll with label $i=3$ (where $w_i = 3$) into the sack. Then we put 1st, 2nd, and 4th dolls into the first box, and we put 5th and 6th dolls into the second box.)\n\n### Constraints\n\nYour program will be run against two sets of test cases: \"small\" and \"large\".\n- For test cases in group \"small\", the value $N$ satisfies $1 \\leq N \\leq 250$\n- For test cases in group \"large\", the value $N$ satisfies $1 \\leq N \\leq 2500$\n- In addition, for all test cases, $1 \\leq L \\leq 10^8, 0 \\leq M \\leq N$ and each doll has the weight satisfying $1 \\leq w_i \\leq L$.","archived":true},"42e9879c-9f26-4db2-874b-a047489f5286":{"round":{"regional":false,"audition":false,"national":true},"statement":"# แขวนรูป\n\nเราต้องการกรอบรูปอันหนึ่งด้วย 1 เส้นที่ร้อยจากขอบซ้ายของรูป คล้องเหนือหมุดบนกำแพงบางอัน แล้วมาร้อยเชื่อมกับขอบขวาของรูป\n\n## ตัวอย่าง: หมุด 2 ตัว\n\nสมมติว่าเราต้องการแขวนรูปด้วยการใช้เชือกกับหมุด 2 ตัว ในรูปแบบต่าง ๆ ดังนี้\n\n- **รูปสีฟ้า:** หากเราแขวนรูปแบบปกติ (ดังรูป) เราพบว่าหากหมุดตัวใดตัวหนึ่งถูกดึงออกไป หมุดอีกตัวหนึ่งจะยังสามารถรั้งกรอบภาพไม่ให้ตกตามแรงโน้มถ่วงได้\n- **รูปสีเขียว:** แต่หากเราแขวนอีกแบบหนึ่ง (ดังรูป) เราพบว่ากรอบภาพยังคงแขวนได้ แต่หากหมุดตัวใดตัวหนึ่งถูกดึงออกไป กรอบภาพจะหลุดลงมาทันที แม้ว่าหมุดอีกตัวจะยังยึดกำแพงอยู่ก็ตาม\n\n**คำเตือน (รูปสีแดง):** 1. ห้ามใช้เชือกคล้องกันเอง (ดังรูป) ในรูปนี้ให้ถือว่าเชือกขดทับกันแต่ไม่ไขว้กัน ซึ่งแปลว่ารูปจะไม่ถูกแขวนได้สำเร็จแต่แรก &nbsp; นอกจากนั้น 2. ห้ามมัดเชือกกันเองเป็นปมเพื่อแขวนหมุด\n\n## คำถาม: หมุด 3 ตัว\n\nหากเรามีหมุดสามอัน คือ A, B, C เรียงจากซ้ายไปขวา (ดูรูปสีเหลืองประกอบ) เราจะร้อยเชือกรอบหมุดอย่างไร จึงจะสอดคล้องกับเงื่อนไขต่อไปนี้\n- หากดึงหมุด A หรือหมุด C อันใดอันหนึ่ง รูปจะยังรั้งไว้ได้ ไม่หล่นลงมา\n- หากดึงหมุด B หมุดเดียว รูปจะหล่นลงมาทันที\n- หากดึงทั้งหมุด A และหมุด C ทั้งสองหมุด รูปจะหล่นลงมาเช่นกัน","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F-LJnnkVtosB-S9_pGebw?alt=media&token=97d843fb-0e62-49eb-a4df-f5dfd0da971b","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F42e9879c-9f26-4db2-874b-a047489f5286%2FHangingFrame.png?alt=media&token=d48a294b-0c99-4b49-9099-35d7e3936dff","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F42e9879c-9f26-4db2-874b-a047489f5286%2Fpicturehang-blue.png?alt=media&token=a460f36e-fec0-4879-9f60-88c7a2ddb9e5","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F42e9879c-9f26-4db2-874b-a047489f5286%2Fpicturehang-green.png?alt=media&token=eca2d156-74ed-445b-802f-8baaf98a6347","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F42e9879c-9f26-4db2-874b-a047489f5286%2Fpicturehang-red.png?alt=media&token=f7c36055-8a1d-4553-9f36-5535f78a0274","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F42e9879c-9f26-4db2-874b-a047489f5286%2Fpicturehang-yellow.png?alt=media&token=e90ac6d4-26e7-47ca-9798-ffb3ca25be99"],"tags":["logic-puzzle","hard-math","used"],"createdAt":{"_seconds":1533106837,"_nanoseconds":0},"note":"- **Author:** เพลน\n- should be paired with [tiling problem](/questions/ff755ca3-5396-4194-bb15-0690eb409366)\n- [Ji] change log:\n   fix typo หมุน -> หมุด\n   เพิ่มตรง หมายเหตุต่อท้าย ห้ามพันเป็นปม","updatedAt":{"_seconds":1541098959,"_nanoseconds":590000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false}},"43c73183-ca8d-4973-8555-2e035c429756":{"createdAt":{"_seconds":1533106807,"_nanoseconds":0},"note":"- **Author:** คูน","updatedAt":{"_seconds":1536572435,"_nanoseconds":496000000},"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":false,"audition":true,"national":false},"statement":"จงหาผลลัพธ์ต่อไปนี้ โดยใช้วิธี Reverse Polish Notation (Postfix Notation) \n\n```\n8 7 * 6 5 4 + * -\n```\n\n1. -370\n2. -3    \n3. 2\n4. 7\n5. 12","archived":false,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":true,"solution":"Answer: 3. \"2\"","imageUrls":[],"tags":["cs-knowledge"]},"477c3178-9233-43ff-bb48-58e4be2f7614":{"deleted":false,"solution":"Hash Table (Given an input, there is only one output)","imageUrls":[],"tags":["cs-knowledge","data-structure"],"createdAt":{"_seconds":1533106834,"_nanoseconds":0},"note":"- **Category:** Algorithms & Data Structures\n- **Author:** เพลน","updatedAt":{"_seconds":1535359646,"_nanoseconds":891000000},"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"audition":true,"national":false,"regional":false},"statement":"โครงสร้างข้อมูล (Data Structure) หรือแบบชนิดข้อมูลนามธรรม (Abstract Data Type) ใดต่อไปนี้สามารถใช้เก็บความสัมพันธ์ข้อมูลที่มีลักษณะเป็นฟังก์ชันทางคณิตศาสตร์ได้โดยตรง\n\n1. Hash Table\n2. Stack\n3. Doubly Linked List\n4. Priority Queue\n5. Undirected Graph\n6. Fibonacci heap\n","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false}},"47b18bce-432f-4683-9fe3-be6b58f1a226":{"updatedAt":{"_seconds":1536547333,"_nanoseconds":886000000},"format":{"ponder":true,"quickfire":false,"choices":true,"coding":false},"round":{"audition":true,"national":false,"regional":false},"statement":"ธนาคารกสิกรสาขา TechJam 2018 มี 600 ชั้น ติดเลขไว้ตั้งแต่ 1 ถึง 600 \n\nเจ้าหน้าที่ต้องเตรียมเลขโดด 0 ถึง 9 ไว้เพื่อนำมาติดตามชั้นต่างๆ  เช่นชั้น 10 ต้องเตรียมเลข 1 กับ 0 อย่างละ 1 ตัว\n\nอยากทราบว่าเจ้าหน้าที่ต้องเตรียมเลข 0 กี่ตัว เพื่อนำมาติดให้ครบ 600 ชั้น ?\n\n1. 20\n3. 40\n4. 66\n5. 90\n6. 100\n7. 109\n8. 111\n9. 121\n10. 128\n11. 150\n12. 199\n13. 200\n14. 201\n15. 270\n16. 300\n17. 330\n18. 365\n19. 400\n20. 472","archived":true,"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"Answer: \"111\"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1536547333,"_nanoseconds":886000000},"note":"Reuse Audition NE to Audition N"},"491d33c3-e8af-4d28-881a-724604f3d634":{"updatedAt":{"_seconds":1535292873,"_nanoseconds":582000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"regional":false,"audition":true,"national":false},"statement":"ถ้า x เป็น 32 แล้วค่าของ y หลังจากรันโปรแกรมต่อไปนี้เป็นเท่าไร?\n\n```pseudocode\ny := 1\nwhile y ≤ x\n    y := y * 2\nend\n```\n\n1. 1\n2. 2\n3. 4\n4. 8\n5. 16 \n6. 32\n7. 64\n8. 128","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":true,"solution":"Answer: \"64\"","imageUrls":[],"tags":["code-peeking"],"createdAt":{"_seconds":1535291911,"_nanoseconds":657000000},"note":"- Recycled"},"4b1d8664-dd78-4d74-9363-29760a118513":{"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4b1d8664-dd78-4d74-9363-29760a118513%2Fatoms-ex1.png?alt=media&token=b032e43b-c101-4a01-8654-9810bc6d443e","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4b1d8664-dd78-4d74-9363-29760a118513%2Fatoms-ex2.png?alt=media&token=3da7bc4f-6d66-4af8-8c20-54e7d215156b","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4b1d8664-dd78-4d74-9363-29760a118513%2Fatoms-enum.png?alt=media&token=699ad8fa-e9bb-4734-95c8-8a55de18d89b"],"tags":[],"createdAt":{"_seconds":1541174144,"_nanoseconds":287000000},"note":"","updatedAt":{"_seconds":1541215526,"_nanoseconds":867000000},"format":{"choices":false,"coding":true,"ponder":false,"quickfire":false},"round":{"regional":false,"audition":false,"national":true},"statement":"# Stable Molecule\n\n### Background\n\nในห้องปฏิบัติการวิจัยเคมีแห่งหนึ่ง คุณกุ้งกำลังศึกษาโครงสร้างของโมเลกุลชนิดหนึ่ง ที่ประกอบไปด้วยอะตอมหลากหลายชนิดมาประกอบกันด้วยพันธะที่เชื่อมระหว่างอะตอมบางคู่ จนมีโครงสร้างเป็นกราฟต้นไม้\n\nกล่าวคือโครงสร้างโมเลกุลนี้จะประกอบด้วยอะตอมทั้งสิ้น $N$ ชนิด ชนิดละ 1 อนุภาค (เรียกสั้น ๆ ว่า “ลูก”) และมีพันธะทั้งสิ้น $N-1$ พันธะที่เชื่อมอะตอมเหล่านี้เข้าด้วยกัน (เราจะเรียกอะตอมแต่ละลูกว่าลูกที่ $i$ สำหรับ $i = 1, 2, \\ldots, N$)\n\nคุณกุ้งสามารถกำหนดค่ามวลของอะตอมแต่ละลูกได้ โดยที่มวลของอะตอมลูกที่ $i$ จะกำหนดด้วยตัวแปร $m_i$ ซึ่งเป็นจำนวนเต็มบวก กล่าวคือมีเงื่อนไขว่า $m_i \\geq 1$\n\nโครงสร้างโมเลกุลนี้จะ **“เสถียร”** ก็ต่อเมื่อ แรงดึงดูดระหว่างอะตอม 2 ลูกที่เป็นพันธะต่อกันจะมีค่าไม่เกิน $P$   \nโดยแรงดึงดูดระหว่างมวลสามารถคำนวณได้จากผลคูณของมวลของอะตอมแต่ละลูก (นั่นแปลว่า $m_u \\times m_v \\leq P$ สำหรับทุกคู่อะตอม $u$ และ $v$ ที่มีพันธะต่อกัน) \n\n#### Example #1\n\nยกตัวอย่างโครงสร้างโมเลกุลที่เกิดจากอะตอม 4 ลูกที่เชื่อมกันดังรูปนี้ และกำหนดให้ $P=12$ พบว่าโครงสร้างโมเลกุลทางซ้ายจะเสถียร แต่โครงสร้างทางขวาจะไม่เสถียร\n\n![][ex1] &nbsp;&nbsp; ![][ex2]\n\n### Problem Statement\n\nจงเขียนโปรแกรมเพื่อรับโครงสร้างโมเลกุล และค่าขีดจำกัดสูงสุดของแรงดึดดูดระหว่างอะตอม $P$ แล้วหาว่าคุณกุ้งจะสามารถกำหนดค่ามวลให้แก่อะตอมแต่ละลูกให้แตกต่างกันได้ทั้งหมดกี่รูปแบบ โดยที่โมเลกุลจะยังเสถียรอยู่\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มสองจำนวน $N$ และ $P$ คั่นด้วยช่องว่าง\n- อีก $N-1$ บรรทัดถัดมา บรรทัดที่ $j+1$ จะมีจำนวนเต็ม $u_j$ และ $v_j$ คั่นด้วยช่องว่าง ซึ่งระบุว่ามีพันธะระหว่างอะตอมลูกที่ $u_j$ และอะตอมลูกที่ $v_j$  (**หมายเหตุ:** กำหนดให้ $1 \\leq u_j, v_j \\leq N$ และ $u_j \\neq v_j$)\n$$\n\\begin{aligned}\n& N \\;\\; P \\\\\n& u_1 \\;\\; v_1 \\\\\n& u_2 \\;\\; v_2 \\\\\n& \\vdots \\\\\n& u_{N-1} \\;\\; v_{N-1}\n\\end{aligned}\n$$\n\n#### Output Format\n\n- คำตอบประกอบด้วยจำนวนเต็ม 1 ตัว ระบุจำนวนรูปแบบของโมเลกุลที่คุณกุ้งสามารถกำหนดมวลให้อะตอมแต่ละลูกได้ โดยคำตอบจะต้องอยู่ในรูปของเศษที่เกิดจากการหารด้วย $1,\\!000,\\!000,\\!007$ \n\n### Example #1\n\n#### Input\n\n```plaintext\n4 2\n1 2\n2 3\n4 2\n```\n\n#### Output\n\n```plaintext\n9\n```\nเราสามารถแจกแจงรูปแบบของการกำหนดมวลให้อะตอมแต่ละลูกในโมเลกุลได้ดังนี้\n\n![][enum]\n\n####\n\n### Example #2\n\n#### Input\n\n```plaintext\n5 3 \n4 2\n3 2\n1 3\n5 3\n```\n\n#### Output\n\n```plaintext\n51\n```\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า ค่าขีดจำกัดสูงสุดของแรงดึดดูดระหว่างอะตอมจะสอดคล้องกับเงื่อนไข $1 \\leq P \\leq 10^3$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า ค่าขีดจำกัดสูงสุดของแรงดึดดูดระหว่างอะตอมจะสอดคล้องกับเงื่อนไข $1 \\leq P \\leq 10^9$\n- สำหรับทุก test cases จะมีเงื่อนไขว่า จำนวนของอะตอมจะสอดคล้องกับเงื่อนไข $1 \\leq N \\leq 1,\\!000$\n\n\n- สำหรับแต่ละ test case โปรแกรมจะต้องใช้เวลาไม่เกิน 2 second (baseline) และใช้ memory ไม่เกิน 128 MB\n   - สำหรับภาษา Java และ Go จะมี time limit เท่ากับ baseline × 2\n   - สำหรับภาษา Python และ JavaScript จะมี time limit เท่ากับ baseline × 4\n\n[ex1]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4b1d8664-dd78-4d74-9363-29760a118513%2Fatoms-ex1.png?alt=media&token=b032e43b-c101-4a01-8654-9810bc6d443e\n[ex2]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4b1d8664-dd78-4d74-9363-29760a118513%2Fatoms-ex2.png?alt=media&token=3da7bc4f-6d66-4af8-8c20-54e7d215156b\n[enum]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4b1d8664-dd78-4d74-9363-29760a118513%2Fatoms-enum.png?alt=media&token=699ad8fa-e9bb-4734-95c8-8a55de18d89b","archived":false},"4e609783-2e77-4232-8c9c-ec12370ecd9d":{"archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":false,"solution":"13","imageUrls":[],"tags":["logic-puzzle"],"createdAt":{"_seconds":1536055494,"_nanoseconds":30000000},"note":"","updatedAt":{"_seconds":1536575980,"_nanoseconds":222000000},"format":{"quickfire":true,"choices":false,"coding":false,"ponder":false},"round":{"national":false,"regional":true,"audition":false},"statement":"วิ่งควาย 66 กะ 6  หาอันดับ 1   ให้เวลา 10  วิ "},"4fb0779b-a35a-48d5-acd0-3af99f02cf94":{"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"### ตัวอย่าง\n\nพิจารณาตัวอย่างของต้นไม้ค้นหาแบบทวิภาค (Binary search tree) ดังที่แสดงต่อไปนี้ \n\n![][dia]\n\n**A. Pre-order traversal** ของโครงสร้างข้อมูลต้นไม้ทวิภาค (Binary tree) คือการใช้กรรมวิธี Depth-first search (DFS) เพื่อประมวลผลโหนดแต่ละโหนดของต้นไม้หนึ่งตามลำดับดังต่อไปนี้ โดยเริ่มต้นจากราก (root) ของต้นไม้ \n\n   1. compute โหนดตัวเอง\n   2. recursively compute โหนดในกลุ่ม subtree ทางซ้ายของโหนดตัวเอง\n   3. recursively compute โหนดในกลุ่ม subtree ทางขวาของโหนดตัวเอง\n\nยกตัวอย่างเช่น ต้นไม้ในรูปข้างต้น จะมีลำดับ Pre-order traversal เป็น $[5, 2, 1, 4, 3]$\n\n**B. Breadth-first search** ของกราฟนี้ที่เริ่มจากรากของต้นไม้ในรูปข้างต้นนี้ มีลำดับที่เป็นไปได้ 2 รูปแบบ คือ $[5, 2, 1, 4, 3]$ และ $[5, 2, 4, 1, 3]$\n\n### โจทย์\n\nมีต้นไม้ค้นหาแบบทวิภาค (Binary search tree) $T$ อีกต้นหนึ่ง ซึ่งมีลำดับ Pre-order traversal เป็น $[7, 2, 1, 4, 3, 6, 5, 9, 8, 10, 11]$  \nอยากทราบว่าต้นไม้ $T$ เดียวกันนี้จะมี Breadth-first search (BFS) ordering ที่เริ่มต้นจากรากได้ต่างกันทั้งหมดกี่รูปแบบ?\n\n[dia]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4fb0779b-a35a-48d5-acd0-3af99f02cf94%2Fbst-preorder.png?alt=media&token=4c069723-adb3-4552-a5fd-b1ea3febb878","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"16 แบบ","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4fb0779b-a35a-48d5-acd0-3af99f02cf94%2Fbst-preorder.png?alt=media&token=4c069723-adb3-4552-a5fd-b1ea3febb878","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F4fb0779b-a35a-48d5-acd0-3af99f02cf94%2Fbst-preorder-inverted.png?alt=media&token=66319d0b-d34d-48c0-8caa-0072e517b617"],"tags":["algorithms","data-structure","graph-algorithms","counting","45-sec"],"createdAt":{"_seconds":1537904284,"_nanoseconds":537000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1538645229,"_nanoseconds":257000000}},"50c8339d-e522-4de4-bcfc-e07a6188c674":{"imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F50c8339d-e522-4de4-bcfc-e07a6188c674%2Fpizza-diff.png?alt=media&token=413d11db-50eb-4afe-b64b-81b3569e82b5","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F50c8339d-e522-4de4-bcfc-e07a6188c674%2Fpizza-iden.png?alt=media&token=d9e1663e-09c1-4c9c-ba13-089967327902","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F50c8339d-e522-4de4-bcfc-e07a6188c674%2Fpizza-diff.png?alt=media&token=54e334f0-c411-4cd4-aeb0-a3501ad05581","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F50c8339d-e522-4de4-bcfc-e07a6188c674%2Fpizza-iden.png?alt=media&token=2c3b40dc-3c7b-4b6a-9f0f-4d4032c4784b"],"tags":["counting ","small-coding"],"createdAt":{"_seconds":1535875837,"_nanoseconds":320000000},"note":"- **Author:** เพลน\n- **Verified** Aof","updatedAt":{"_seconds":1538644697,"_nanoseconds":367000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"1. พิซซ่าถาดหนึ่งถูกตัดแบ่งด้วยรัศมีออกเป็นพิซซ่าชิ้นย่อย ๆ 8 ชิ้นที่มาขนาดเท่า ๆ กัน \n2. จากนั้น พิซซ่าแต่ละชิ้นย่อยทุกชิ้นจะถูกทาด้วยซอสหนึ่งในสามชนิด (ซอสขาว ซอสแดง หรือซอสน้ำตาล)\n3. พิซซ่าสองถาดจะมีหน้าตา**แบบเดียวกัน** ***ก็ต่อเมื่อ*** หากสามารถหมุนถาดพิซซ่าให้หน้าตาของทั้งสองออกมาเหมือนกันได้\n\n   - ตัวอย่างของพิซซ่าที่หน้าตาแตกต่างกัน  \n       ![][diff]\n   - ตัวอย่างของพิซซ่าที่หน้าตาเหมือนกันทั้งหมด  \n       ![][same] \n\nอยากทราบว่าเราจะได้ถาดพิซซ่าที่หน้าตามีการทาซอสออกมาแตกต่างกันทั้งหมดกี่แบบ?\n\n[diff]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F50c8339d-e522-4de4-bcfc-e07a6188c674%2Fpizza-diff.png?alt=media&token=413d11db-50eb-4afe-b64b-81b3569e82b5\n[same]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F50c8339d-e522-4de4-bcfc-e07a6188c674%2Fpizza-iden.png?alt=media&token=d9e1663e-09c1-4c9c-ba13-089967327902","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"834 แบบ"},"5523ba8f-d93c-434c-af84-88a0e3691e5a":{"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"$0 - (1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10) = 53$","imageUrls":[],"tags":["math-puzzle","edge-cases","30-sec"],"createdAt":{"_seconds":1533106843,"_nanoseconds":0},"note":"- **Category:** Basic math puzzle, วัดความรอบคอบและแม่นยำ\n- **Author:** เพลน\n- **Time-limit:** 30 วิ\n- Verified\n- ภาคใต้ตอบถูก 0/7 ทีม","updatedAt":{"_seconds":1535329957,"_nanoseconds":706000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"regional":true,"audition":false,"national":false},"statement":"จากนิพจน์ต่อไปนี้\n\n$$\n    0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10\n$$\n\nหากคุณสามารถใส่วงเล็บในนิพจน์ดังกล่าวกี่คู่ก็ได้เพื่อเปลี่ยนกลุ่มการลบ  \nผลลัพธ์ที่มากที่สุดที่เป็นไปได้จากการใส่วงเล็บดังกล่าวคือเท่าใด?\n\n**หมายเหตุ:** ไม่สามารถเปลี่ยนการลบเป็นการคูณได้ เช่น $(0 - 1)(-2)(-3)(-4)(-5)(-6)(-7)(-8)(-9)(-10) = 10!$","archived":true},"56b76e33-9440-458b-a8dc-9aad2e97c973":{"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"regional":false,"audition":false,"national":true},"statement":"Let $a$ and $b$ be five-digit palindromes (without leading zeroes) such that $a < b$ and there are no other\nfive-digit palindromes strictly between $a$ and $b$. How many possible values of $b - a$ are there? (A number is a\npalindrome if it reads the same forwards and backwards in base 10.)","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"3 (100,110,11)","imageUrls":[],"tags":[],"createdAt":{"_seconds":1539139295,"_nanoseconds":350000000},"note":"[Ju] ใช้ 20 นาที หันไปเห็น อ่าว Quickfire ตายแปป","updatedAt":{"_seconds":1540800892,"_nanoseconds":243000000}},"5a5d3d8c-7250-42eb-a392-20784c9833dd":{"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"audition":false,"national":false,"regional":true},"statement":"เดินข้ามตึก [to be added]","archived":false,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106848,"_nanoseconds":0},"note":"","updatedAt":{"_seconds":1533106848,"_nanoseconds":0}},"5c0f744d-24eb-4fdd-bc50-eaba08e56461":{"archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"Answer: 102334155\n\n- Coincidentally, the answer fits the definition of [this sequence](https://oeis.org/A088305)","imageUrls":[],"tags":["counting","used"],"createdAt":{"_seconds":1540466801,"_nanoseconds":878000000},"note":"- **Author:** เพลน\n- should be paired with [food chain problem](/questions/6bc4f0a2-8058-4b28-a20d-3d8f04d5d5bd)","updatedAt":{"_seconds":1541045728,"_nanoseconds":402000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":true,"regional":false},"statement":"กำหนดให้ `validate_array(A)` คือฟังก์ชันที่รับ input เป็นอาร์เรย์ `A` ของจำนวนเต็ม (ซึ่งเริ่มนับ index จาก 0) และให้ output เป็นค่า Boolean ที่เป็น `true` หรือ `false` เท่านั้น\n\nimplementation ของฟังก์ชันดังกล่าว สามารถเขียนเป็น pseudocode ได้ดังนี้\n\n```pseudocode\nfunction validate_array(A[0...n-1]):\n    return (\n        (0 ≤ A[i] ≤ n-1 and A[i] == A[A[i]]  for each i := 0 to n-1)\n        and (A[i-1] ≤ A[i]  for each i := 1 to n-1)\n    )\nend\n```\n\nตัวอย่างของการเรียกใช้ฟังก์ชันข้างต้น\n- `validate_array(A = [0, 1, 1, 3]) # => true` \n- `validate_array(A = [2, 2, 2, 2]) # => true` \n- `validate_array(A = [1, 2, 3, 3]) # => false` \n- `validate_array(A = [3, 1, 1, 3]) # => false` \n\nถามว่าจะมีอาร์เรย์ `A` ที่มีสมาชิก 20 ตัวทั้งหมดกี่รูปแบบที่ทำให้ `validate_array(A)` มีค่าเป็น `true`?"},"5ccb7362-17e8-4a29-8cf8-b1b62fcf041f":{"deleted":false,"solution":"0","imageUrls":[],"tags":["coding","edge-cases"],"createdAt":{"_seconds":1536055458,"_nanoseconds":712000000},"note":"","updatedAt":{"_seconds":1536575944,"_nanoseconds":814000000},"format":{"quickfire":true,"choices":false,"coding":false,"ponder":false},"round":{"audition":false,"national":false,"regional":true},"statement":"ให้พิจารณา pseudocode ต่อไปนี้\n\n```pseudocode\nfunction findM(A):\n    # A[1...n] is a one-indexed array of n integers\n    n = A.length()\n    answer = 0\n    for i := 1 to n:\n        if A[i] < answer:\n            answer := A[i]\n    return answer\n```\n\nจงหาผลลัพธ์ของการรัน `findM([9, 43, 214, 1, 5])`","archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true}},"5d6aaa4c-7cb6-4e23-b093-f050ee5dedbc":{"archived":true,"region":{"northeast":false,"south":false,"north":true,"central":false},"deleted":false,"solution":"Answer: `EABDFC`","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F-LJiV0qpha6-8pV2k-vt?alt=media&token=2a7dd008-c546-4e1e-8396-3de3c817334c"],"tags":["algorithms","graph-algorithms","propose-north-audition"],"createdAt":{"_seconds":1533106811,"_nanoseconds":0},"note":"- **Category:** Algorithms\n- **Author:** คูน","updatedAt":{"_seconds":1536541365,"_nanoseconds":362000000},"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"audition":true,"national":false,"regional":false},"statement":"จากกราฟที่กำหนดให้ดังรูป ข้อใดเป็นลำดับของการ visit node ที่เป็นไปได้ ในการใช้อัลกอริทึม Breadth First Search ที่สร้างขึ้นด้วย queue data structure\n\n1. `ABCDEF`\n2. `EABDFC`\n3. `BEADCF`\n4. `EABDCF`\n5. `FAEDBC`"},"5da71860-f4a0-42c9-ace3-fa4dff25215b":{"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F5da71860-f4a0-42c9-ace3-fa4dff25215b%2Fpip_chan_ex1.png?alt=media&token=2bd6293b-7bfe-4935-b4d7-0b4d06a510dc","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F5da71860-f4a0-42c9-ace3-fa4dff25215b%2Fpip_chan_grid_distance.png?alt=media&token=f9c9dc77-ea1e-49b5-97e4-a131586a2c3c"],"tags":["doing"],"createdAt":{"_seconds":1541069505,"_nanoseconds":161000000},"note":"","updatedAt":{"_seconds":1541213060,"_nanoseconds":643000000},"format":{"ponder":false,"quickfire":false,"choices":false,"coding":true},"round":{"national":true,"regional":false,"audition":false},"statement":"# Finding Peep Chan\n\n### Background\n\nเด็กหญิงเกดเป็นเด็กน้อยแสนน่ารักที่เลี้ยงแมวเหมียวชื่อว่าปิ๊บจัง วันหนึ่งเจ้าปิ๊บจังหายไปเลยออกไปตามหา เด็กหญิงเกดได้เบาะแสมาว่าเจ้าปิ๊บจังไปติดอยู่ในถ้ำแห่งหนึ่ง ถ้ำมีลักษณะเป็น grid 2 มิติ แบ่งเป็นห้องขนาด $N \\times M$ โดยห้องซ้ายบนสุดคือพิกัด $(1,1)$ และห้องขวาล่างสุดคือพิกัด $(N,M)$\n\nแต่ละห้องจะสามารถเดินไปมาหาสู่กันได้เฉพาะห้องที่ติดกันในทิศทาง บน ล่าง ซ้าย ขวา หรือก็คือ ห้อง $(x,y)$ สามารถเดินไปยังห้อง $(x-1,y)$, $(x+1,y)$, $(x,y-1)$ และ $(x,y+1)$ นอกจากนี้ในถ้ำยังมีทางลัดอีก $K$ เส้นทาง โดยเส้นทางที่ $i$ จะสามารถเดินทางไปมาหาสู่กันระหว่างห้อง $(x_{i1},y_{i1})$ และ $(x_{i2},y_{i2})$ ได้\nการเดินทางไปยังช่องที่ติดกันในทิศทาง บน ล่าง ซ้าย ขวา หรือ การใช้ทางลัด แต่ละครั้งจะใช้เวลาในการเดินทาง 1 วัน (ขอเรียกระยะการเดินของแมวใน 1 วันว่า 1 แมวเดิน)\n\n![][pip_chan_grid_distance]\n\nจากรูปแสดงระยะทางในหน่วยแมวเดิน จากการเดินของแมวที่อยู่ที่ห้องตรงกลาง ลูกศรคือเส้นทางลัด\n\nเด็กหญิงเกดรู้สึกจนปัญญามากเพราะไม่รู้ว่าแมวอยู่ห้องไหนในถ้ำกันแน่ ดังนั้นจะถือว่า**ตอนแรกแมวมีโอกาสที่จะอยู่ในแต่ละห้องด้วยความน่าจะเป็นที่เท่าๆกัน** (ซึ่งจะเท่ากับ $\\dfrac{1}{N \\times M}$) เด็กหญิงเกดจึงไปร้องขอต่อเทพเจ้าให้ช่วยเหลือ\n\nเทพเจ้ามีพลังวิเศษ 2 อย่าง คือ \n\n1. **หยั่งรู้** – เทพเจ้าจะเลือกห้องห้องหนึ่ง หลังจากนั้นพระเจ้าจะรู้ว่าแมวอยู่ห่างจากห้องที่เลือกเป็น“ระยะทางที่ใกล้ที่สุด” กี่แมวเดิน แต่ว่าสามารถใช้ได้วันละ 1 ครั้งเท่านั้น\n\n2. **ช่วยเหลือ** – เทพเจ้าจะเลือกห้องห้องหนึ่งเพื่อช่วยเหลือแมว ถ้าแมวอยู่ในห้องที่เลือกจะถือว่าช่วยเหลือสำเร็จ แต่ว่าสามารถใช้ได้แค่ครั้งเดียวเท่านั้น\n\nเนื่องจากถ้ำมีอากาศอยู่เบาบางมาก แมวจะสามารถมีชีวิตอยู่ได้แค่ 2 วัน เพราะฉะนั้นการช่วยเหลือแมวจะมีโอกาสแค่วันนี้กับพรุ่งนี้เท่านั้น\n\nเทพเจ้าตอบรับคำร้องขอของเด็กหญิงเกด และดำเนินการช่วยเหลือตามขั้นตอนต่อไปนี้\n\n1. เทพเจ้าจะใช้พลัง **“หยั่งรู้”** เพื่อเลือกห้องห้องหนึ่งในถ้ำ\n2. เทพเจ้าจะพิจารณาว่า จะใช้พลัง **“ช่วยเหลือ”** ในวันนี้เลยหรือไม่ แน่นอนว่าถ้าใช้แล้วจะไม่สามารถดำเนินการในข้อต่อไปได้ เพราะไม่สามารถใช้พลัง **“ช่วยเหลือ”** ได้อีกต่อไป\n3. ในกรณีที่เทพเจ้าไม่ได้ใช้พลัง **“ช่วยเหลือ”** เทพเจ้าจะนอน 1 วันเพื่อพักผ่อน ในขณะที่เทพเจ้านอนพัก แมวจะเคลื่อนที่ 1 ครั้ง โดยการเคลื่อนที่นี้แมวจะสามารถเดินไปยังห้องที่ติดกันหรือห้องที่มีทางลัดไปหากันได้ โดย**แมวจะเดินไปยังห้องที่ไปได้ทั้งหมดด้วยโอกาสที่เท่าๆกัน**\n4. ในวันถัดไป เทพเจ้าก็จะใช้พลัง **“หยั่งรู้”** อีกครั้ง\n5. เทพเจ้าก็จะใช้พลัง **“ช่วยเหลือ”** เพราะว่าเป็นโอกาสสุดท้ายที่จะช่วยเหลือแมวแล้ว\n\n\n### Problem Statement\n\nเทพเจ้าอยากทราบว่า ความน่าจะเป็นที่มากที่สุดที่เป็นไปได้ที่จะช่วยเหลือแมวได้สำเร็จเป็นเท่าไหร่ ถ้าดำเนินการช่วยเหลืออย่าง Optimal ที่สุด\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดแรกประกอบด้วยจำนวนเต็ม $N, M$ แทนขนาดของถ้ำ และ K แทนจำนวนเส้นทางลัด\n- K บรรทัดถัดมา บรรทัดที่ $i$ จะประกอบด้วย จำนวนเต็ม 4 จำนวน $x_{i1}$, $y_{i1}$, $x_{i2}$ และ $y_{i2}$ คั่นด้วยช่องว่าง ซึ่งระบุเส้นทางลัดเส้นที่ $i$   \n   **หมายเหตุ:** รับประกันว่า $1 \\leq x_{i1}, x_{i2} \\leq N$ และ $1 \\leq y_{i1},y_{i2} \\leq M$ และจะไม่มีเส้นทางลัดซ้ำกัน และไม่มีทางลัดของห้องที่อยู่ติดกัน\n$$\n\\begin{aligned}\n& N \\;\\; M \\;\\; K \\\\\n& x_{1,1} \\;\\; y_{1,1} \\;\\; x_{1,2} \\;\\; y_{1,2} \\\\\n& x_{2,1} \\;\\; y_{2,1} \\;\\; x_{2,2} \\;\\; y_{2,2} \\\\\n& \\vdots \\\\\n& x_{K,1} \\;\\; y_{K,1} \\;\\; x_{K,2} \\;\\; y_{K,2}\n\\end{aligned}\n$$\n\n#### Output Format\nตอบเป็นจำนวนจริง 1 จำนวน แทนความน่าจะเป็นที่มากที่สุดที่เป็นไปได้ของการช่วยเหลือแมว ถ้าเทพเจ้าทำการช่วยเหลืออย่าง Optimal ที่สุด (คำตอบจะถูกต้องถ้าคาดเคลื่อนไม่มากกว่าคำตอบจริงเกิน $10^{-6}$)\n\n### Example #1\n\n#### Input\n\n```plaintext\n2 2 1\n1 1 2 2\n```\n\n#### Output\n\n```plaintext\n0.9166666667\n```\nจากตัวอย่างที่ 1 ลักษณะของถ้้าเป็นดังนี้ ลูกศรคือเส้นทางลัด\n\n![][pip_chan_ex1]\n\nหนึ่งในการวิธีช่วยเหลือที่ Optimal ขอเทพเจ้ามีดังต่อไปนี้\n\n1. วันแรก ใช้พลัง **“หยั่งรู้”** ที่ห้อง $(1,2)$\n\n  1.1. ความน่าจะเป็น $\\dfrac{1}{4}$ ที่ระยะทางที่ใกล้ที่สุด จะเป็น $0$ แมวจะอยู่ที่ห้อง $(1,2)$ กรณีนี้ สามารถใช้พลัง **“ช่วยเหลือ”** เพื่อช่วยแมวได้ทันที  \n\n  1.2. ความน่าจะเป็น $\\dfrac{2}{4}$ ที่ระยะทางที่ใกล้ที่สุด จะเป็น 1 แมวอาจจะอยู่ที่ห้อง $(1,1)$ หรือ $(2,2)$ ก็ได้ กรณีนี้ควรรอวันที่ 2\n\n  1.3. ความน่าจะเป็น $\\dfrac{1}{4}$ ที่ระยะทางที่ใกล้ที่สุด จะเป็น 2 แมวจะอยู่ที่ห้อง (2,1) กรณีนี้ สามารถใช้พลัง **“ช่วยเหลือ”** เพื่อช่วยแมวได้ทันที\n\n2. ระหว่างวันในขณะที่เทพเจ้านอนพัก การเคลื่อนที่ของแมวเป็นดังนี้ (ข้อ 1.2)\n\n  2.1. ความน่าจะเป็นที่แมวจะเดินไปห้อง $(1,2)$ คือ $\\dfrac{2}{4}\\times\\dfrac{1}{3}=\\dfrac{2}{12}$ (เดินจาก $(1,1)$, $(2,2)$)\n\n  2.2. ความน่าจะเป็นที่แมวจะเดินไปห้อง $(1,1)$ คือ $\\dfrac{1}{4}\\times\\dfrac{1}{3}=\\dfrac{1}{12}$ (เดินจาก $(2,2)$)\n\n  2.3. ความน่าจะเป็นที่แมวจะเดินไปห้อง $(2,2)$ คือ $\\dfrac{1}{4}\\times\\dfrac{1}{3}=\\dfrac{1}{12}$ (เดินจาก $(1,1)$)\n\n  2.4. ความน่าจะเป็นที่แมวจะเดินไปห้อง $(2,1)$ คือ $\\dfrac{2}{4}\\times\\dfrac{1}{3}=\\dfrac{1}{12}$ (เดินจาก $(1,1)$, $(2,2)$)\n\n3. วันถัดมาวันที่ ใช้พลัง “หยั่งรู้” ที่ห้อง $(1,2)$ เช่นเดิม\n\n  3.1. ความน่าจะเป็น $\\dfrac{2}{12}$ ที่ระยะทางที่ใกล้ที่สุดจะเป็น 0 แมวจะอยู่ที่ห้อง $(1,2)$ กรณีนี้สามารถช่วยเหลือแมวได้แน่นอน\n\n  3.2. ความน่าจะเป็น $\\dfrac{2}{12}$ ที่ระยะทางที่ใกล้ที่สุดจะเป็น 2 แมวจะอยู่ที่ห้อง $(2,1)$ กรณีนี้สามารถช่วยเหลือแมวได้แน่นอน\n\n  3.3. ความน่าจะเป็น $\\dfrac{1}{12}+\\dfrac{1}{12}=\\dfrac{2}{12}$ ที่ระยะทางที่ใกล้ที่สุดจะเป็น 1 แมวจะอาจจะอยู่ที่ห้อง $(1,1)$ หรือ $(2,2)$ ก็ได้ กรณีนี้ การเลือกห้องใดห้องหนึ่งเพื่อใช้พลัง **“ช่วยเหลือ”** จะมีโอกาสช่วยแมวสำเร็จด้วยความน่าจะเป็น $\\dfrac{2}{12} \\times \\dfrac{1}{2}=\\dfrac{1}{12}$\n\n4. สรุป ความน่าจะเป็นที่เทพเจ้าจะสามารถช่วยเหลือแมวได้ คือ (ข้อ 1.1, 1.2, 3.1, 3.2, 3.3)\n\n  $\\dfrac{1}{4} + \\dfrac{1}{4} + \\dfrac{2}{12} + \\dfrac{2}{12} + \\dfrac{1}{12} = \\dfrac{11}{12} \\approx 0.9166666667$\n\n### Example #2\n\n#### Input\n\n```plaintext\n3 3 3\n3 1 1 2\n3 1 2 3\n1 2 3 1\n```\n\n#### Output\n\n```plaintext\n0.7259259259\n```\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไข ขนาดของถ้ำสอดคล้องกับเงื่อนไข $1 \\leq N,M \\leq 20$ และ $N \\times M \\leq 200$ และจำนวนเส้นทางลัดสอดคล้องกับเงื่อนไข $1 \\leq K \\leq 100$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า ขนาดของถ้ำสอดคล้องกับเงื่อนไข $1 \\leq N,M \\leq 20$ และจำนวนเส้นทางลัดสอดคล้องกับเงื่อนไข $1 \\leq K \\leq 70,000$\n\n\n- สำหรับแต่ละ test case โปรแกรมจะต้องใช้เวลาไม่เกิน 2 second (baseline) และใช้ memory ไม่เกิน 128 MB\n   - สำหรับภาษา Java และ Go จะมี time limit เท่ากับ baseline × 2\n   - สำหรับภาษา Python และ JavaScript จะมี time limit เท่ากับ baseline × 4\n\n[pip_chan_grid_distance]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F5da71860-f4a0-42c9-ace3-fa4dff25215b%2Fpip_chan_grid_distance.png?alt=media&token=f9c9dc77-ea1e-49b5-97e4-a131586a2c3c\n\n[pip_chan_ex1]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F5da71860-f4a0-42c9-ace3-fa4dff25215b%2Fpip_chan_ex1.png?alt=media&token=2bd6293b-7bfe-4935-b4d7-0b4d06a510dc\n","archived":false},"5ed75bce-3b40-48c1-b401-fd8c1adca7de":{"updatedAt":{"_seconds":1536542979,"_nanoseconds":475000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true},"round":{"national":false,"regional":false,"audition":true},"statement":"ฟังก์ชันต่อไปนี้ทำอะไร\n\n```pseudocode\ninput: a positive integer n\noutput: a string\n\nS := empty stack\nwhile n > 0\n    S.push(n mod 3)  # modulo operator\n    n := n div 3     # integer-truncated division\nend\n\noutput := \"\"\nwhile stack S is not empty\n    # + is string concatenation\n    output := output + int_to_string(S.pop())\nend\n\nreturn output\n```\n\n1. แสดงค่าเลขฐาน 3 ของ n\n2. แสดงค่าเลขฐาน 3 ของ n จากหลังมาหน้า\n3. แสดงค่า log₃ n\n4. แสดงค่า log₃ n จากหลังมาหน้า\n5. ไม่ใช่ทั้ง A, B, C, และ D","archived":false,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":true,"solution":"1. แสดงค่าเลขฐาน 3 ของ n","imageUrls":[],"tags":["code-peeking","data-structure"],"createdAt":{"_seconds":1533106804,"_nanoseconds":0},"note":"- **Category:** Data structure\n- **Author**: คูน"},"62e38518-044c-4d30-93a8-b0dc64de5966":{"deleted":false,"solution":"Answer: 20 ใบ\n\n- เนื่องจาก $B_1[1] = 5$ ทำให้ $B_1[0] \\geq 5$ ดังนั้นแล้ว \n   $$\n   \\text{จำนวนกล่องรวม} = \\sum_{i \\geq 0} B_1[i] \\geq 5 + 5 + 4 + 3 + 2 + 1 = 20\n   $$\n- มีวิธีที่ใช้กล่อง 20 ใบที่สอดคล้องกับเงื่อนไขดังกล่าว คือกล่องที่ซ้อนเรียงกัน 5 ชุด \n   - ชุด #1 มีกล่อง 2 ใบ ซ้อนต่อเรียงกัน \n   - ชุด #2 มีกล่อง 3 ใบ ซ้อนต่อเรียงกัน \n   - ชุด #3 มีกล่อง 4 ใบ ซ้อนต่อเรียงกัน \n   - ชุด #4 มีกล่อง 5 ใบ ซ้อนต่อเรียงกัน \n   - ชุด #5 มีกล่อง 6 ใบ ซ้อนต่อเรียงกัน","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F62e38518-044c-4d30-93a8-b0dc64de5966%2Fnested-boxes.png?alt=media&token=5aa22971-e696-4e26-a49c-89c5ac2b59b5","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F62e38518-044c-4d30-93a8-b0dc64de5966%2Fnested-boxes-inverted.png?alt=media&token=7aee1b90-b846-4154-ba3b-63c8cf89c60d"],"tags":["math-puzzle","20-sec"],"createdAt":{"_seconds":1538237949,"_nanoseconds":547000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1538645413,"_nanoseconds":504000000},"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false},"round":{"audition":false,"national":false,"regional":true},"statement":"โจทย์ข้อนี้ เรากำหนดให้มีกล่องจำนวนหนึ่งวางอยู่บนโต๊ะ ซึ่งกล่องบางใบอาจจะถูกซ้อนอยู่ภายในกล่องใบอื่นก็ได้ และมีเงื่อนไขเพื่อความชัดเจนว่า\n\n- **ถ้า**กล่อง X ถูกซ้อนในกล่อง Y **และ**กล่อง Y ถูกซ้อนในกล่อง Z **แล้ว**กล่อง X จะถือว่าถูกซ้อนในกล่อง Z ด้วย\n- **ถ้า**กล่อง X ถูกซ้อนในกล่อง Y **แล้ว**กล่อง Y จะไม่ถูกซ้อนในกล่อง X\n\n**นิยาม:** หาก $B$ คือหนึ่งรูปแบบของการจัดวางกล่องบนโต๊ะตามเงื่อนไขที่กำหนดให้ แล้วสัญลักษณ์ $B[n]$ จะหมายถึง “จำนวนของกล่องทั้งหมดบนโต๊ะที่มีกล่องอื่น ๆ จำนวน $n$ ใบซ้อนอยู่ภายใน”\n\n### ตัวอย่าง\n\nสมมติว่า $B_0$ คือการจัดวางกล่อง 5 ใบบนโต๊ะรูปแบบหนึ่ง ดังที่แสดงในรูปข้างล่างนี้\n\n![][d]\n\nเราสามารถบอกได้ว่า $B_0[1] = 2$ (กล่องสีฟ้า), $B_0[2] = 0$, $B_0[3] = 0$ และ $B_0[4] = 1$ (กล่องสีเหลือง) ฯลฯ\n\n### โจทย์\n\nจงหาว่าสำหรับการจัดวางกล่อง $B_1$ ใด ๆ ที่สอดคล้องกับเงื่อนไข $B_1[1] = 5$ และ $B_1[2] = 4$ และ $B_1[3] = 3$ และ $B_1[4] = 2$ และ $B_1[5] = 1$ จะต้อง**มีจำนวนกล่องรวม**ทั้งหมดอย่างน้อยกี่ใบ?\n\n[d]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F62e38518-044c-4d30-93a8-b0dc64de5966%2Fnested-boxes.png?alt=media&token=5aa22971-e696-4e26-a49c-89c5ac2b59b5","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false}},"6500d584-33af-45c4-ad07-eb6b5e60c766":{"note":"- **Author:** เพลน\n- Based on the idea of Linear Temporal Logic (Software Verification)\n- Verified by Eak","updatedAt":{"_seconds":1537790410,"_nanoseconds":222000000},"format":{"ponder":true,"quickfire":false,"choices":true,"coding":false},"round":{"audition":true,"national":false,"regional":false},"statement":"ให้พิจารณากราฟที่กำหนดให้ เราจะเขียนโปรแกรมเพื่อเดิน (Traverse) บนกราฟดังกล่าว โดยมีเงื่อนไขดังนี้\n\n- เราจะเริ่มต้นการเดินจากโหนด A\n- จากโหนดหนึ่ง ๆ เราจะเดินไปยังโหนดถัดไปเฉพาะโหนดที่มีลูกศรชี้ไปหาเสมอ ... หากมีลูกศรชี้ไปยังโหนดอื่น ๆ มากกว่า 1 โหนด ให้เลือกโหนดถัดไป_โหนดใดก็ได้_จากตัวเลือกนั้น ๆ (เช่น จากโหนด B เราสามารถเดินไปยังโหนด A หรือ E ได้)\n- เราจะเดินบนกราฟนี้ไปเรื่อย ๆ ไม่มีหยุดอยู่กับที่ (เสมือนว่าโปรแกรมของเรามี infinite loop) \n\nจากการเดินบนกราฟอย่างไม่สิ้นสุดตามคำอธิบายข้างต้น ข้อใดต่อไปนี้ถูกต้องบ้าง?\n\n- **ประพจน์ P** — รับประกันว่าในการเดินดังกล่าว \"เราจะเดินพบโหนด A เป็นจำนวนอนันต์ครั้ง\" หรือไม่เช่นนั้น \"เราจะเดินพบโหนด D เป็นจำนวนอนันต์ครั้ง\"\n- **ประพจน์ Q** — รับประกันว่าในการเดินดังกล่าว \"เราจะเดินพบโหนด B เป็นจำนวนอนันต์ครั้ง\" หรือไม่เช่นนั้น \"เราจะเดินพบโหนด E เป็นจำนวนอนันต์ครั้ง\"\n- **ประพจน์ R** — รับประกันว่าในการเดินดังกล่าว \"เราจะเดินพบโหนด C เป็นจำนวนอนันต์ครั้ง\" หรือไม่เช่นนั้น \"เราจะเดินพบโหนด F เป็นจำนวนอนันต์ครั้ง\"\n\n1. ประพจน์ P เท่านั้น\n2. ประพจน์ Q เท่านั้น\n3. ประพจน์ R เท่านั้น\n4. ประพจน์ P และ Q\n5. ประพจน์ P และ R\n6. ประพจน์ Q และ R\n7. ถูกต้องทั้ง P และ Q และ R\n8. ผิดทั้ง P และ Q และ R","archived":true,"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"Answer: 4. ประพจน์ P และ Q จริง แต่ R ไม่จริง (เดิน BED วนไป)","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F6500d584-33af-45c4-ad07-eb6b5e60c766%2Finfinite-paths.png?alt=media&token=6b821d7f-49f3-4085-962e-6a4b7d24f7ab"],"tags":["algorithms","math-puzzle","propose-central-audition"],"createdAt":{"_seconds":1535352791,"_nanoseconds":45000000}},"65bbed88-955b-4346-b3b5-8c7e2cd48831":{"format":{"coding":true,"ponder":false,"quickfire":false,"choices":false},"round":{"regional":true,"audition":false,"national":false},"statement":"# polymer-chain\n\n### Background\n\nในห้องปฏิบัติการวิจัยเคมีแห่งหนึ่ง มีการทดลอง Simulation การเปลี่ยนแปลงโครงสร้างสาย Polymer ชื่อ Polymer $K$ ซึ่งประกอบไปด้วยอะตอมหลากหลายชนิดเรียงตัวเป็นเส้นตรง\n\nในคอมพิวเตอร์ เราจะแทนอะตอมแต่ละชนิดด้วยอักขระ `\"A\"` ถึง `\"Z\"` และเราจะแทน Polymer $K$ ที่มีความยาว $N$ ด้วยสตริงที่ประกอบไปด้วยอักขระ `\"A\"` ถึง `\"Z\"` ความยาว $N$ ตัว\n\nในห้องปฏิบัติการดังกล่าว ยังมีเครื่องจัดเรียง Polymer ที่มีชื่อว่า $manipulate\\_polymer\\_once(K[0 \\ldots N-1], p)$ ซึ่งมี Specification ในการทำงานดังต่อไปนี้\n\n- หาก input string $K$ ของฟังก์ชัน $manipulate\\_polymer\\_once$ คือลำดับของอักขระ $K[0], K[1], \\ldots, K[N-1]$ ตามลำดับ และ $p$ คือ index ของสตริง $K$ โดยที่ $0 \\leq p \\leq N-1$ แล้ว ฟังก์ชันนี้จะ return ค่าสตริงซึ่งประกอบด้วยอักขระต่อไปนี้ตามลำดับ \n   $$\n   \\underbrace{K[p-1], K[p-2], \\ldots, K[1], K[0]}_\\text{exists if $p > 0$}, K[p], \n   \\underbrace{K[N-1], K[N-2], \\ldots, K[p+2], K[p+1]}_\\text{exists if $p < N-1$}\n   $$\n\n- ยกตัวอย่างเช่น ถ้า input ของ $manipulate\\_polymer\\_once$ ได้แก่ $K = \\mathtt{\"ASDFGHJKL\"}$ และ $p=3$   \n  - จะได้ output string เป็น $\\mathtt{\"\\textcolor{red}{DSA}F\\textcolor{green}{LKJHG}\"}$    \n  - สังเกตว่า $\\mathtt{F}$ จะอยู่ในตำแหน่งเดิมไม่เปลี่ยนแปลง แต่สตริงย่อยที่อยู่ข้างหน้าและข้างหลังจะถูกเรียงกลับหลัง\n\nในการทำการทดลอง Simulation จริง เราจะนำ Polymer สายหนึ่งมาจัดเรียงใหม่ไปเรื่อย ๆ อย่างต่อเนื่องเป็นจำนวน $M$ ครั้ง โดยปรับเปลี่ยน Parameter ไปเรื่อย ๆ เช่น ถ้า Polymer ตั้งต้นคือ $K = \\mathtt{\"ASDFGHJKL\"}$ และค่า Parameter ของการจัดเรียง $M = 3$ ครั้งอย่างต่อเนื่องคือ $p_1 = 3, p_2 = 6, p_3 = 0$ เราจะได้ Polymer ผลลัพธ์เป็น\n\n```pseudocode\nASDFGHJKL → DSAFLKJHG → KLFASDJGH → KHGJDSAFL\n```\n\n### Problem Statement\n\nจงเขียนโปรแกรมเพื่อทำ Simulation ของการจัดเรียง Polymer สายหนึ่งด้วยลำดับของพารามิเตอร์ที่กำหนดให้ แล้วหาว่า Polymer ผลลัพธ์สุดท้ายมีหน้าตาเป็นอย่างไร\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มสองจำนวน $N$ และ $M$ คั่นด้วยช่องว่าง\n- บรรทัดที่ 2: มีสตริงความยาว $N$ ซึ่งระบุข้อมูลสาย Polymer เริ่มต้นก่อนการทดลอง\n- อีก $M$ บรรทัดถัดมา บรรทัดที่ $i+2$ จะมีค่า $p_i$ ซึ่งเป็น Parameter ของคำสั่งการจัดเรียง Polymer คำสั่งที่ $i$ ที่ต้องกระทำดับ Polymer $K$ ตามลำดับ\n$$\n\\begin{aligned}\n& N \\;\\; M \\\\\n& K[0 \\ldots N-1] \\\\\n& p_1 \\\\\n& p_2 \\\\\n& \\vdots \\\\\n& p_M\n\\end{aligned}\n$$\n\n#### Output Format\n\n- คำตอบประกอบตัวสตริง 1 ตัว ซึ่งก็คือสาย Polymer สุดท้ายหลังจากจัดเรียง Polymer ตามคำสั่งทั้งหมด $M$ ตามที่กำหนดให้ใน input\n\n### Example #1\n\n#### Input\n\n```plaintext\n9 3\nASDFGHJKL\n3\n6\n0\n```\n\n#### Output\n\n```plaintext\nKHGJDSAFL\n```\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า ความยาว Polymer จะสอดคล้องกับเงื่อนไข $1 \\leq N \\leq 300$ และจำนวนครั้งที่เรียกใช้งานเครื่องจัดเรียง Polymer สอดคล้องกับเงื่อนไข $0 \\leq M \\leq 30,\\!000$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า ความยาว Polymer จะสอดคล้องกับเงื่อนไข $1 \\leq N \\leq 300,\\!000$ และจำนวนครั้งที่เรียกใช้งานเครื่องจัดเรียง Polymer สอดคล้องกับเงื่อนไข $0 \\leq M \\leq 300,\\!000$","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"There is a solution which takes $O(M+N)$ running time.","imageUrls":[],"tags":["list-processing","insightful"],"createdAt":{"_seconds":1533106839,"_nanoseconds":0},"note":"- **Category:** List processing\n- **Author:** เพลน\n- **Difficulty:** Hard. Requires a lot of deep thought and observational skills.","updatedAt":{"_seconds":1541173510,"_nanoseconds":91000000}},"6b8c6e46-8b59-43cf-98ef-25a691091bc8":{"updatedAt":{"_seconds":1537780467,"_nanoseconds":710000000},"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":false,"audition":true,"national":false},"statement":"**Definition:** Proper binary tree คือต้นไม้ทวิภาคที่ทุกโหนดมีโหนดลูกเป็นจำนวน 0 หรือ 2 โหนดเท่านั้น  \n(กล่าวคือทุกโหนดที่เป็น Internal/Non-leaf node จะต้องมีโหนดลูก 2 โหนดพอดี)\n\nสมมติว่าเรามี Library ตัวหนึ่งที่เอาไว้สำหรับจัดการข้อมูลที่มีโครงสร้างเป็น Proper binary tree ซึ่งมีรายละเอียดดังต่อไปนี้\n\n- **Data type.** โหนดแต่ละโหนดของ Proper binary tree จะมี Data type ที่มีชื่อว่า `Node` ซึ่งแบ่ง Subtype ได้ 2 แบบย่อย ดังนี้\n    - `Leaf[value: Integer]` … เป็น Leaf node ซึ่งประกอบด้วยข้อมูล 1 อย่าง ซึ่งก็คือจำนวนเต็มภายในโหนด\n    - `Internal[left: Node, right: Node, value: Integer]` … เป็น Non-leaf node ซึ่งประกอบด้วยข้อมูลทั้งสิ้น 3 อย่าง ได้แก่ \n        (a) Subtree ทางซ้าย (b) Subtree ทางขวา และ (c) ข้อมูลจำนวนเต็มภายในโหนด ตามลำดับ\n\n- **Library function.** กำหนดให้ฟังก์ชัน `compute` รับข้อมูลต้นไม้ประเภท `Node` และฟังก์ชันอื่น ๆ อีก 2 ฟังก์ชัน (ดูโค้ดด้านล่างประกอบ) เพื่อประมวลผลข้อมูลต้นไม้ดังกล่าว ซึ่งสามารถเขียนเป็น Pseudocode ได้ดังต่อไปนี้\n   ```pseudocode\n   function compute(tree: Node,\n                    leaf_transformer: function,      # function(Integer) → T\n                    internal_transformer: function)  # function(T, T, Integer) → T\n       if tree matches Leaf[value] then:\n           return leaf_transformer(value)\n       else if tree matches Internal[left, right, value] then:\n           return internal_transformer(compute(left), compute(right), value)\n       end\n   end\n   ```\n\nหากกำหนดเรามีข้อมูล Proper binary tree ภายในตัวแปรชื่อ `data` แล้วโปรแกรมใดต่อไปนี้จะนับจำนวนโหนดทั้งหมดภายในต้นไม้ (รวมทั้ง Leaf และ Internal/Non-leaf) ภายในตัวแปร `data` ดังกล่าวได้ถูกต้อง?\n\n(**หมายเหตุ:** ยกตัวอย่าง Syntax ของฟังก์ชันนิรนาม เช่น `lambda(x, y) → (x + y)/2` คือฟังก์ชันที่หาค่าเฉลี่ยของตัวเลข input argument สองตัว)\n\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r)\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r) * 2 + 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r) * 2 - 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r + v)\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r + v) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r + v) * 2 + 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → v, lambda(l, r, v) → l + r + v) * 2 - 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 1, lambda(l, r, v) → l + r) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 1, lambda(l, r, v) → l + r) * 2 + 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 1, lambda(l, r, v) → l + r) * 2 - 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 1, lambda(l, r, v) → l + r + 1) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 1, lambda(l, r, v) → l + r - 1) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 0, lambda(l, r, v) → l + r) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 0, lambda(l, r, v) → l + r) * 2 + 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 0, lambda(l, r, v) → l + r) * 2 - 1\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 0, lambda(l, r, v) → l + r + 1) * 2\n   ```\n1. ```pseudocode\n   compute(data, lambda(v) → 0, lambda(l, r, v) → l + r - 1) * 2\n   ```\n","archived":true,"region":{"central":true,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"Answer: `compute(data, lambda(v) → 1, lambda(l, r, v) → l + r) * 2 - 1`\n\n(ขยายความ: `compute(data, lambda(v) → 1, lambda(l, r, v) → l + r)` คือจำนวน leaf node ทั้งหมด และจำนวน non-leaf จะน้อยกว่า leaf อยู่ 1 สำหรับกราฟที่เป็น proper binary tree","imageUrls":[],"tags":["data-structure","functional-programming","cs-knowledge"],"createdAt":{"_seconds":1537734048,"_nanoseconds":899000000},"note":"- **Author:** เพลน\n- Verified by Eak"},"6bc4f0a2-8058-4b28-a20d-3d8f04d5d5bd":{"note":"- **Author:** เพลน\n- should be paired with [nested array indexing problem](/questions/5c0f744d-24eb-4fdd-bc50-eaba08e56461)","updatedAt":{"_seconds":1541045721,"_nanoseconds":975000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"audition":false,"national":true,"regional":false},"statement":"โจทย์ข้อนี้เราจะสนใจระบบการถ่ายเทพลังงานในระบบห่วงโซ่อาหารของสัตว์กลุ่มหนึ่ง โดยที่สัตว์ทุกตัวในกลุ่มนี้มีโอกาสเป็นทั้งผู้ล่าและเหยื่อกับสัตว์ตัวอื่น ๆ ได้ทุกตัว\n\n- สมมติว่าก่อนการจับเหยื่อเป็นอาหาร สัตว์แต่ละตัวมีพลังงานสะสมเริ่มต้น 1,000,000 Calories\n- เมื่อเกิดจากจับเหยื่อขึ้น หากสัตว์ A รับประทานสัตว์ B แล้วพบว่า B จะตายไป และ A จะได้พลังงานสะสมครึ่งหนึ่งจาก B  \n   (**หมายเหตุ:** เราสมมติว่าสัตว์แต่ละตัวจะไม่เสียพลังงานใด ๆ กับกิจกรรมอื่น ๆ เลย พลังงานจะหายไปจากระบบจากการที่เหยื่อถูกบริโภคเท่านั้น)\n- สัตว์ทุกตัวจะจับเหยื่อตัวอื่น ๆ เป็นอาหารได้ไม่เกิน 3 ตัว\n\nอยากทราบว่าหากมีสัตว์ในกลุ่มทั้งสิ้น 1,000 ตัว เมื่อสัตว์เหล่านี้ล่ากันเองจนเหลือเพียงตัวเดียว สัตว์ตัวนี้จะมีพลังงานสะสมตอน้ทาย**อย่างน้อยที่สุด**กี่ Calories และ**อย่างมากที่สุด**กี่ Calories? (มี 2 คำถาม และให้ตอบเป็นจำนวนเต็มโดย**ปัดเศษทิ้ง**)","archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"Answer: $e_{\\max} = 30,\\!718,\\!750$, $e_{\\min} \\approx 1,\\!999,\\!999$\n\n- มองกราฟของ food chain เป็น tree เพราะตามเงื่อนไขของโจทย์บอกว่าจะต้องมีสัตว์เหลือตัวเดียว\n- พลังงานของสัตว์แต่ละตัวจะถูกถ่ายเทไปยังสัตว์ที่อยู่บนสุดของห่วงโซ่อาหาร ยิ่ง depth น้อย พลังงานที่สูญเสียจากการถ่ายเทยิ่งน้อยตามไปด้วย","imageUrls":[],"tags":["tree-structure","insight","used"],"createdAt":{"_seconds":1540460643,"_nanoseconds":192000000}},"6be4a4f9-0d09-4cb0-a9fc-971bf88f5ecc":{"round":{"regional":false,"audition":false,"national":true},"statement":"$$\n\\begin{bmatrix} ? & ? & ? & ? \\\\ ? & ? & ? & ? \\\\ ? & ? & ? & ? \\\\ ? & ? & ? & ? \\end{bmatrix}\n$$\n\nจงเติมตัวเลข $1$ ถึง $16$ ลงในตารางขนาด $4 \\times 4$ โดยมีเงื่อนไขว่า\n- จำนวนในแต่ละช่องต้องไม่ซ้ำกัน\n- จำนวนในแต่ละแถว จะต้องเรียงลำดับจากน้อยไปมาก จากซ้ายไปขวา\n- จำนวนในแต่ละคอลัมน์ จะต้องเรียงลำดับจากน้อยไปมาก จากบนลงล่าง\n- สำหรับ $i = 1, 2, 3, 4$ นั้น ผลรวมจำนวนในแถวที่ $i$ (นับจากบน) จะต้องเท่ากับผลรวมจำนวนในคอลัมน์ที่ $i$ (นับจากซ้าย)\n\nจงแสดงคำตอบมา 1 คำตอบ พร้อมทั้งคำนวณผลรวมในแต่ละแถว/คอลัมน์ด้วย","archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"คำตอบมี 2 รูปแบบ (up to reflecting symmetry)\n- $$\\begin{bmatrix} 1 & 2 & 4 & 10 \\\\ 3 & 5 & 9 & 11 \\\\ 6 & 8 & 12 & 14 \\\\ 7 & 13 & 15 & 16 \\end{bmatrix}$$\n- $$\\begin{bmatrix} 1 & 2 & 6 & 8 \\\\ 3 & 5 & 7 & 13 \\\\ 4 & 10 & 12 & 14 \\\\ 9 & 11 & 15 & 16 \\end{bmatrix}$$\n- หนึ่งวิธีในการหาคำตอบ\n   ```python\n   from itertools import combinations\n   \n   def generate_sorted_tables(size=2):\n       current_groups = []\n       def rec_add_group(remainders):\n           if not remainders:\n               yield current_groups\n               return\n           min_r = min(remainders)\n           other_remainders = [r for r in remainders if r != min_r]\n           for others in combinations(other_remainders, size-1):\n               new_group = [min_r] + sorted(others)\n               if (current_groups and \n                       any(p >= q for p, q in zip(current_groups[-1], new_group))):\n                   continue\n               new_remainders = [r for r in remainders if r not in new_group]\n               current_groups.append(new_group)\n               yield from rec_add_group(new_remainders)\n               current_groups.pop()\n       yield from rec_add_group(list(range(1, 1+size**2)))\n   \n   \n   for table in generate_sorted_tables(4):\n       if all(sum(table[t]) == sum(table[i][t] for i in range(4))\n              for t in range(4)):\n           print(table)\n   ```","imageUrls":[],"tags":["small-coding","math-puzzle","used"],"createdAt":{"_seconds":1540800690,"_nanoseconds":882000000},"note":"- **Author:** เพลน\n- should be paired with [3-term arithmetic progression problem](/questions/a6d5188e-f135-4a85-ab5a-3f9c2e2e0647)","updatedAt":{"_seconds":1541045746,"_nanoseconds":912000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false}},"7359fafa-9469-48d0-a977-a057a581db86":{"archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"ได้หมดตั้งแต่ 1 ถึง 13 (ตอบไม่มีข้อถูก)","imageUrls":[],"tags":["logic-puzzle"],"createdAt":{"_seconds":1533106832,"_nanoseconds":0},"note":"- **Category:** Dynamic Programming / Counting\n- **Author:** เอก\n- Verified: Aof\n\n**Related keyword:** Balanced ternary representation","updatedAt":{"_seconds":1537767408,"_nanoseconds":142000000},"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"audition":true,"national":false,"regional":false},"statement":"สมมติว่ามีตาชั่งสองแขน พร้อมกับตุ้มน้ำหนัก 3 ชิ้น ที่มีน้ำหนัก 1 ขีด 3 ขีด และ 9 ขีดตามลำดับ  \n\nข้อใดต่อไปนี้คือน้ำหนักของสิ่งของที่**ไม่สามารถ**ชั่งได้ด้วยตุ้มน้ำหนักชุดนี้\n\n1. 4 ขีด\n2. 7 ขีด\n3. 8 ขีด\n4. 10 ขีด\n5. 12 ขีด\n6. 13 ขีด\n7. ไม่มีข้อใดถูก"},"75909482-1ac3-4785-b70a-b732eb4acf59":{"imageUrls":[],"tags":["code-peeking","60-sec"],"createdAt":{"_seconds":1534931951,"_nanoseconds":107000000},"note":"- 60 วินาที\n- Verified by อัท\n- ภาคใต้ตอบถูก 0/7 ทีม","updatedAt":{"_seconds":1535330097,"_nanoseconds":662000000},"format":{"choices":false,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":true,"audition":false,"national":false},"statement":"จากโปรแกรมต่อไปนี้\n\n```pseudocode\ninput: array of integers, A[0...n-1]\n\nfor i := 0 to n-1\n    for j := n downto i + 1\n        swap values between A[i] and A[j]\n    end\nend\n```\n\nจงหา array ความยาว 4 และประกอบด้วยตัวเลข 1-4 ซึ่งไม่ซ้ำกัน ที่เมื่อป้อนเป็น input ให้โปรแกรมดังกล่าว จะได้ output เป็น `[1, 2, 3, 4]`","archived":true,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"Answer: `[4, 1, 3, 2]`"},"75ec5182-fd6f-45a3-b9f1-9ec224db7532":{"updatedAt":{"_seconds":1535330323,"_nanoseconds":843000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"นายเคเป็น Programmer ที่ต้องการสำรวจเส้นทางเดินทางไปแข่งขัน TechJam Code Squad.\nโดยหมู่บ้านที่เคอาศัยอยู่มีรูปแบบผังเมืองที่เป็นระเบียบ ถนนและอาคารต่างๆวางผังเมืองเป็นรูปสี่เหลี่ยมจัตุรัส ขนาด 5x5 ดังภาพ\n\nนายเค __ต้องการทราบว่ามีกี่เส้นทางที่สามารถเดินทางจากบ้านไปแข่งขัน TechJam ได้__ โดยมีเงื่อนไขต่อไปนี้\n* จะไม่มีการเดินย้อน หรือเดินอ้อม จะเดินไปหาจุดหมายด้วยระยะทางที่สั้นที่สุดเท่านั้น\n* นายเคไม่สามารถเดินทะลุตึกได้\n* นายเคพบว่ามีการก่อสร้างถนนในบางจุด ทำให้นายเคไม่สามารถเดินผ่านได้ ดังรูป","archived":true,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"132","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F-LKJnHFWdwqv262bYl3_?alt=media&token=156d9248-7c43-4fff-b0b6-0623149111f7"],"tags":["counting","dynamic-programming"],"createdAt":{"_seconds":1533106854,"_nanoseconds":0},"note":"Verified by เอก จิ\n- ภาคใต้ตอบถูก 0/7 ทีม"},"774aadc9-a485-4aee-95ed-00d80d8e6488":{"updatedAt":{"_seconds":1540528456,"_nanoseconds":346000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"regional":false,"audition":false,"national":true},"statement":"ให้พิจารณาตารางขนาด $3 \\times 3$ ที่แต่ละช่องจะเขียนลูกศรได้ 1 ใน 4 แบบ (ชี้ขึ้นบน ลงล่าง ไปทางซ้าย หรือไปทางขวา)\n\nตารางดังกล่าวจะถือว่า **“มีอิสระ”** ถ้าหากเราวางหมาก ณ ช่องใด ๆ ในตารางนี้ แล้วเดินตามลูกศรที่เขียนไว้ และสุดท้ายหมากจะเดินออกจากตารางเสมอ\n- เช่น ตารางต่อไปนี้ถือว่าเป็นตารางที่ “มีอิสระ”\n   $$\n   \\begin{bmatrix}\n   \\uparrow & \\leftarrow & \\uparrow \\\\\n   \\downarrow & \\leftarrow & \\downarrow \\\\\n   \\rightarrow & \\downarrow & \\leftarrow\n   \\end{bmatrix}\n   $$\n- แต่ตารางนี้ “ไม่มีอิสระ”\n   $$\n   \\begin{bmatrix}\n   \\uparrow & \\leftarrow & \\uparrow \\\\\n   \\downarrow & \\leftarrow & \\downarrow \\\\\n   \\rightarrow & \\boldsymbol{\\uparrow} & \\leftarrow\n   \\end{bmatrix}\n   $$\n\nจงหาว่าจะมีตารางดังกล่าวที่มีอิสระทั้งหมดกี่รูปแบบ?","archived":false,"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":true,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1540528456,"_nanoseconds":346000000},"note":""},"786febe4-1d25-4040-9083-2d2a4af29d52":{"deleted":false,"solution":"- **Actual path (1):** $[(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (1, 2), (1, 3), (0, 3), (0, 2), (1, 0), (2, 0), (2, 3), (0, 0)]$\n- **Actual path (2):** $[(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (1, 2), (1, 3), (0, 3), (0, 2), (0, 1), (2, 0), (2, 3), (0, 0)]$\n- **Worst distance:** $12 + \\sqrt{5} + \\sqrt{13} \\approx 17.84 > \\dfrac{160}{9}$\n- This path is the only output possibly returned by the greedy algorithm that would yield the distance more than $\\dfrac{160}{9}$ for this graph input.\n\nVerification:\n```python\npoints = [(x, y) for x in range(3) for y in range(4)]\n\ndef dist(p, q): \n    # square of Euclidean distance\n    return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\n\ndef solve(): \n    longest_dist = 12 \n    longest_path = None \n    path = [] \n    def rec_solve(curr_dist=0): \n        nonlocal longest_dist, longest_path, path\n        if len(path) == 12: \n            curr_dist += dist(path[0], path[-1]) ** 0.5 \n            if curr_dist > longest_dist: \n                longest_dist = curr_dist \n                longest_path = list(path) \n            if curr_dist >= 160/9: \n                print(curr_dist, path) \n            return \n        if len(path) == 0: \n            for p in points: \n                path.append(p); rec_solve(0); path.pop() \n            return \n        remainders = [p for p in points if p not in path] \n        next_dist = min(dist(path[-1], p) for p in remainders) \n        next_nodes = [p for p in remainders if dist(path[-1], p) == next_dist]\n        for p in next_nodes: \n            path.append(p); rec_solve(curr_dist + next_dist ** 0.5); path.pop() \n    rec_solve() \n    return longest_dist, longest_path \n```","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-a.png?alt=media&token=f1e787c3-4fe2-4cc1-adf1-0216f0df36c8","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-b.png?alt=media&token=204b604a-c701-42ce-8314-c2a71ef000d5","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-c.png?alt=media&token=e7cb3799-e7e5-4bb4-b103-80941526f43f","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-d.png?alt=media&token=c3c6577c-c37c-423e-9d2e-d4f78bb8e017"],"tags":["used","graph-algorithms"],"createdAt":{"_seconds":1541150620,"_nanoseconds":149000000},"note":"- **Author:** เพลน\n- should be paired with [greedy make-change problem](/questions/ca059b3d-11b9-4648-a628-9cf8221b2b01)","updatedAt":{"_seconds":1541182139,"_nanoseconds":634000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"regional":false,"audition":false,"national":true},"statement":"ปัญหา **Traveling Salesperson Problem** คือปัญหากราฟที่ต้องการ “ค้นหาเส้นทางจากโหนดโหนดหนึ่ง ไปเยือนจุดโหนดอื่น ๆ ทุกโหนด ก่อนกลับมายังโหนดเริ่มต้น โดยใช้ผลรวมระยะทางระหว่างโหนดน้อยที่สุด”\n\nมี greedy algorithm อยู่อันหนึ่ง ซึ่งมีลักษณะเป็น non-deterministic algorithm มีขั้นตอนการทำงานดังนี้\n\n1. เริ่มต้นจากโหนดใดก็ได้\n2. เลือกเดินไปยังโหนดถัดไปที่อยู่ใกล้ที่สุด ที่ยังไม่เคยเดินทางไปเยือน  \n   **หมายเหตุ:** หากมีโหนดที่ใกล้ที่สุดหลายอัน สามารถเดินไปยังโหนดใดก็ได้\n3. เมื่อกระทำตามข้อ 2. จนครบแล้ว ให้เดินกลับไปยังโหนดเริ่มต้น\n\nอย่างไรก็ดี greedy algorithm นี้ไม่ใช่ optimal solution\n\nโจทย์ข้อนี้เราจะพิจารณาหาตัวอย่างค้านที่ greedy algorithm ให้ผลลัพธ์ที่แย่มากเป็นพิเศษ ให้พิจารณา input graph ต่อไปนี้ ซึ่งเป็นจุดบนเรียงเป็นแนวสี่เหลี่ยมผืนผ้า ทั้งสิ้น 3 แถว แถวละ 4 จุด โดยที่แต่ละแถวและแต่ละคอลัมน์ห่างกัน 1 หน่วย\n\n![][blank]\n\n- ถ้าเราโชคดีหน่อย greedy algorithm จะค้นพบเส้นทางนี้ ซึ่งมีระยะทางเท่ากับ $12$ หน่วย ซึ่งเป็น optimal solution  \n   ![][opt]\n- แต่ถ้าโชคไม่ดีหน่อย greedy algorithm มีโอกาสพบเส้นทางเหล่านี้ ซึ่งได้ระยะทางเท่ากับ (a) $14$ หน่วย และ (b) $\\approx 13.236$ หน่วยโดยประมาณ ตามลำดับ  \n   (a) ![][bad1]   \n   (b) ![][bad2]\n\nจงหาเส้นทางที่ greedy algorithm นี้มีโอกาสค้นพบ ที่มีระยะทางมากกว่า $\\dfrac{160}{9}$ หน่วย\n\n[blank]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-a.png?alt=media&token=f1e787c3-4fe2-4cc1-adf1-0216f0df36c8\n[opt]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-b.png?alt=media&token=204b604a-c701-42ce-8314-c2a71ef000d5\n[bad1]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-d.png?alt=media&token=c3c6577c-c37c-423e-9d2e-d4f78bb8e017\n[bad2]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F786febe4-1d25-4040-9083-2d2a4af29d52%2F12-tsp-c.png?alt=media&token=e7cb3799-e7e5-4bb4-b103-80941526f43f","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false}},"78ac47cc-4411-490f-9113-0020666742a7":{"round":{"regional":false,"audition":false,"national":true},"statement":"มีกลุ่มนักเรียน 101 คน สมัครใจจะเล่น Secret Santa กัน (บ้างก็เรียกว่า \"เกมบัดดี้\")  โดยที่นักเรียนแต่ละคนจะต้องจับฉลากเลือกนักเรียนคนอื่นในกลุ่ม 1 คน เพื่อส่งของขวัญให้**โดยไม่เปิดเผยตัวตน** โดยกำหนดว่า\n\n- หากนักเรียน $S$ (Sender) จับฉลากได้นักเรียน $R$ (Receiver) แล้ว $S$ จะต้องส่งของขวัญให้ $R$ โดยที่ไม่ให้ $R$ ทราบว่าผู้ส่งเป็นใคร\n- รับประกันว่าไม่มีนักเรียนคนใดจับฉลากได้ตัวเอง และนักเรียนทุกคนจะได้รับของขวัญ 1 ชิ้นเสมอ (จากเพื่อนที่จับฉลากได้ตนเอง) \n\nสองสัปดาห์ผ่านไป หลังจากที่ทุกคนได้รับของขวัญจากผู้จับฉลากได้ตนเองแล้ว นักเรียนแต่ละคนต้องการ**เขียนการ์ดขอบคุณ**คืนแก่ผู้ให้ของขวัญตนเอง โดยที่ทุกคนยังรักษาตัวตนของผู้ส่ง**ไว้เป็นความลับ**ตลอดไปได้\n\nอาจารย์ท่านหนึ่งคอยสังเกตการณ์เกมนี้มาตลอด จึงเสนอทางออกให้แก่นักเรียนทุกคน โดยให้นักเรียนแต่ละคนทำตาม pseudocode ต่อไปนี้แบบ asynchronously\n\n```pseudocode\n# สำหรับนักเรียน S แต่ละคน (ซึ่งจับฉลากจากได้นักเรียน R)\nให้ S เขียนการ์ดขอบคุณคนที่จับฉลากและได้ให้ของขวัญแก่ตนเอง แล้วเก็บการ์ดนี้ไว้ในมือ\nrepeat 1000 times:\n    ให้ S ส่งการ์ดในมือไปให้ R\n    ให้ S รอรับการ์ดจากคนที่จับฉลากได้ตนเอง มาเก็บไว้ในมือ\nend\n# การ์ดที่อยู่ในมือ S ตอนนี้ เป็นการ์ดขอบคุณที่เขียนโดย R\n```\n\nสังเกตว่าอาจารย์ให้นักเรียนแต่ละคนใช้วิธี \"ส่งต่อ\" การ์ดขอบคุณที่ตนได้รับมา ไปเรื่อย ๆ จนกระทั่งการ์ดทุกใบถูกส่งให้เป้าหมายครบทุกคน … หากข้อเสนอแนะของอาจารย์ทำงานได้ถูกต้องตามเป้าหมาย แล้วถามว่ารับประกันว่านักเรียนแต่ละคนจะพบเจอการ์ดที่ตนเองเขียน ผ่านมือตนเองระหว่างการ \"ส่งต่อ\" ทั้งหมดอย่างน้อยกี่รอบ","archived":false,"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":true,"solution":"12","imageUrls":[],"tags":["math-puzzle"],"createdAt":{"_seconds":1538216989,"_nanoseconds":960000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1538243863,"_nanoseconds":155000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":true}},"79554f3b-b4e8-4ae4-94fd-f8bd36a6ae9c":{"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true},"round":{"audition":true,"national":false,"regional":false},"statement":"กำหนดให้ Binary Search Tree หนึ่งมีตัวเลขตั้งแต่ 1 ถึง 100 ปรากฏอยู่ \n\nหากเราต้องการค้นหาตัวเลข 56 ในต้นไม้ดังกล่าว ลำดับที่เกิดจาก Tree Traversal ข้อใดต่อไปนี้ไม่สามารถเกิดขึ้นได้?\n\n1. 7, 82, 46, 66, 43, 58, 56\n2. 92, 13, 66, 34, 61, 41, 56\n3. 13, 77, 62, 41, 59, 57, 56\n4. 77, 11, 72, 59, 13, 52, 56","archived":true,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"Answer 1. \"7, 82, 46, 66, 43, 58, 56\"","imageUrls":[],"tags":["data-structure"],"createdAt":{"_seconds":1533106803,"_nanoseconds":0},"note":"- **Category:** Data structure\n- **Author:** คูน\n- ควรเพิ่ม choice","updatedAt":{"_seconds":1536575177,"_nanoseconds":370000000}},"79f9245a-db20-4288-a3e7-bafbc9f3ac1f":{"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"27 ใบ","imageUrls":[],"tags":["counting","pigeonhole-principle"],"createdAt":{"_seconds":1533106831,"_nanoseconds":0},"note":"- **Category:** Counting / Pigeonhole Principal\n- **Author:** เอก\n- เปลี่ยนจากธีมการพนันเป็นอื่น\n- 10 sec","updatedAt":{"_seconds":1537254232,"_nanoseconds":87000000},"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false},"round":{"national":false,"regional":true,"audition":false},"statement":"## เวอร์ชันภาษาไทย\n\nสมมติว่ามีไพ่สำรับมาตรฐาน 2 สำรับ สำรับละ 52 ใบ รวมทั้งสิ้น 104 ใบ วางกองไว้รวมกันโดยไม่เรียงลำดับ\n\n**เป้าหมาย.** เราจะต้องหยิบไพ่ในกองดังกล่าวอย่างสุุ่ม**อย่างน้อยกี่ใบ** จึงจะรับประกันว่าในบรรดาไพ่ที่เราหยิบมาจะมีไพ่ตอง\n\n### หมายเหตุ\n- ไพ่ 52 ใบ (1 สำรับ) มีชุดตัวเลขชุดละ 4 ใบทั้งสิ้น 13 ชุด (2, 3, 4, …, 10, J, Q, K, A) \n- **ไพ่ตอง**คือ ไพ่สามใบที่ชุดตัวเลขเหมือนกันเช่น 2, 2, 2 หรือ K, K, K\n\n## English Version\n\nSuppose that we have two standard decks of cards, each with 52 cards for a total of 104 cards. All cards are stacked and arranged in an arbitrary order.\n\n**Our goal.** How many cards (at minimum) do we need to draw randomly from the stack in order to guarantee that the hand will contain at least one \"three of a kind\".\n\n### N.B.\n- One deck of 52 cards consists of 4 different suits, each with 13 different kinds (2, 3, 4, …, 10, J, Q, K, A)\n- A \"three of a kind\" is a set of three cards sharing the same kind (suits may differ).","archived":true},"7e8d1659-eb26-4f86-bd3a-c28c50a09767":{"format":{"ponder":false,"quickfire":false,"choices":false,"coding":true},"round":{"audition":false,"national":false,"regional":true},"statement":"# island-counting\n\n### Background\n\nในเกมย้อนยุคเกมหนึ่ง มีการวาดแผนที่ด้วย ASCII Art โดยประกอบไปด้วยอักขระ ASCII ที่เรียงตัวกันเป็นสี่เหลี่ยมผืนผ้าจำนวน $R$ แถว แถวละ $C$ ตัว ... อักขระแต่ละตัวจะแทนช่อง 1 ช่องและมีค่าได้สองแบบ\n\n1. ผืนน้ำ ซึ่งเราจะขอแทนด้วย `.`\n2. ผืนดิน ซึ่งเราจะขอแทนด้วย `#`\n\nนอกจากนี้ เราจะสมมติว่า รอบนอกสี่เหลี่ยมผืนผ้านี้จะมีแต่น้ำทะเลอันกว้างใหญ่ไพศาลและไม่มีผืนดินอยู่เลย\n\nเช่น นี่คือตัวอย่างของแผนที่ $Map$ ขนาด $R = 6$ และ $C=18$\n\n```plain\n................##\n..#####...##......\n.##...##..##...###\n.#..#..#.......#..\n.#....##..#.#..#.#\n.######....#...#.#\n```\n\n#### What is an island?\n\n- หากเราเริ่มต้นจากตำแหน่งผืนดินใด ๆ ในแผนที่ แล้วสามารถเดินทางไปยังผืนดินอื่น ๆ ข้างเคียงได้ด้วยการเดิน ขึ้น-ลง-ซ้าย-ขวา ไปเรื่อย ๆ ได้ ให้ถือว่าผืนดินที่เดินไปถึงทั้งหมดเหล่านั้นเป็นส่วนหนึ่งของเกาะเดียวกัน\n- มากไปกว่านั้น จากการเดินข้างต้น หากเราเริ่มเดินจนวกกลับมาที่ผืนดินเริ่มต้น ให้ถือว่าบริเวณที่ถูกรายล้อมด้วยการเดินข้างต้นเป็นส่วนหนึ่งของเกาะเดียวกันเช่นกัน\n    - สังเกตว่าอาจมีทะเลสาบที่ถูกรายล้อมด้วยผืนดินของเกาะเกาะหนึ่ง ซึ่งผืนน้ำดังกล่าวจะถูกนับไปส่วนหนึ่งของเกาะนั้นด้วย\n    - ไม่เพียงแค่นั้น ผืนดินที่ซ้อนอยู่ภายในทะเลสาบดังกล่าว ก็ยังถือว่าเป็นส่วนของเกาะภายนอกด้วย ไม่นับเป็นเกาะแยกต่างหาก\n\nจากตัวอย่างแผนที่ข้างบน เราสามารถเขียนใหม่โดยส่วนของเกาะเดียวกันเขียนด้วยตัวอักษรเดียวกันได้ดังนี้\n\n```plain\n................AA\n..BBBBB...CC......\n.BBBBBBB..CC...DDD\n.BBBBBBB.......D..\n.BBBBBBB..E.F..D.G\n.BBBBBB....H...D.G\n```\n(แผนที่ข้างต้นมีทั้งสิ้น 8 เกาะ)\n\n### Problem Statement\n\nจากแผนที่ภายในเกมที่กำหนดให้ มีเกาะทั้งสิ้นกี่เกาะ?\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n- บรรทัดที่ 1: มีจำนวนเต็มสองตัว $R, C$ คั่นด้วยช่องว่าง\n- อีก $R$ บรรทัดถัดมา บรรทัดที่ $i+1$ จะมีสตริงความยาว $C$ ที่ประกอบไปด้วย `.` หรือ `#` (ซึ่งบอกข้อมูลแถวนั้น ๆ ของแผนที่)  \n\n$$\n\\begin{aligned}\n& R\\; C \\\\\n& \\mathit{M\\!ap}[1, 1 \\ldots C] \\\\\n& \\mathit{M\\!ap}[2, 1 \\ldots C] \\\\\n& \\vdots \\\\\n& \\mathit{M\\!ap}[R, 1 \\ldots C]\n\\end{aligned}\n$$\n\n(หมายเหตุ อาร์เรย์สองมิติ $M\\!ap$ ข้างต้น คือแผนที่ซึ่งเขียนในรูปของ one-indexing)\n\n#### Output Format\n\n- คำตอบประกอบด้วยจำนวนเต็มตัวเดียว ซึ่งระบุจำนวนเกาะในแผนที่ที่กำหนดให้\n\n### Example #1 \n\n#### Input\n\n```plain\n6 18\n................##\n..#####...##......\n.##...##..##...###\n.#..#..#.......#..\n.#....##..#.#..#.#\n.######....#...#.#\n```\n#### Output\n\n```plain\n8\n```\n\n### Example #2\n\n#### Input\n\n```plain\n7 7\n.......\n..####.\n.#...#.\n.#.#.#.\n.#...#.\n.#####.\n.......\n```\n#### Output\n\n```plain\n2\n```\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า $1 \\leq R, C \\leq 200$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า $1 \\leq R, C \\leq 3000$","archived":true,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"https://drive.google.com/drive/folders/1tPwSqsRU3jp5M-Akib0_8tc8p0AHhtkO","imageUrls":[],"tags":["graph-algorithms"],"createdAt":{"_seconds":1534940487,"_nanoseconds":952000000},"note":"- trick into stack overflow by causing deep recursion (spiral shape, maybe?)","updatedAt":{"_seconds":1537376282,"_nanoseconds":631000000}},"81c382af-cd0e-4505-8632-45f96c45553d":{"round":{"audition":false,"national":false,"regional":true},"statement":"ธนาคารกสิกรจัดประเพณีวิ่งควายที่จังหวัดชลบุรี มีควายร่วมเข้าประกวดวิ่งจำนวน 9 ตัว แต่ภายในงานมีลู่ให้ควายวิ่งได้แค่รอบละ 3 ตัวเท่านั้น\n\nหากธนาคารต้องการหาควายที่วิ่งเร็วที่สุด 2 ตัว จะต้องจัดการแข่งขันอย่างน้อยกี่รอบ\n\n(สมมติว่าควายวิ่งด้วยอัตราเร็วเท่าเดิมตลอดทุกรอบ โดยไม่สามารถใช้นาฬิกาจับเวลาได้)","archived":true,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"5","imageUrls":[],"tags":["counting","10-sec"],"createdAt":{"_seconds":1533106846,"_nanoseconds":0},"note":"- คุ้นๆไหมครับ - ให้เวลา 10 วิ\n- Verified\n- ภาคใต้ตอบถูก 1/7 ทีม","updatedAt":{"_seconds":1535329824,"_nanoseconds":131000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false}},"85446b4c-3b18-4930-ba22-b0e7d661d5d7":{"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"3. แสดงตัวเลขฟีโบนักชี n ตัวแรก","imageUrls":[],"tags":["code-peeking","data-structure","propose-north-audition"],"createdAt":{"_seconds":1533106808,"_nanoseconds":0},"note":"- **Category:** Using data structure to achieve other tasks\n- **Author:** คูน","updatedAt":{"_seconds":1536565701,"_nanoseconds":922000000},"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"audition":true,"national":false,"regional":false},"statement":"Pseudocode ต่อไปนี้ทำงานอะไร\n\n```pseudocode\ninput: a positive integer n\n\nQ := empty queue\nQ.enqueue(0)\nQ.enqueue(1)\nfor i := 0 to n-1\n    a := q.dequeue()\n    b := q.dequeue()\n    q.enqueue(b)  # แก้จาก q.enqueue(a)\n    q.enqueue(a+b)\n    print(a)\nend\n```\n\n1. แสดงตัวเลข 0 ทั้งหมด n ครั้ง\n2. แสดงตัวเลข 1 ทั้งหมด n ครั้ง\n3. แสดงตัวเลข 0, 1, 0, 1, ... สลับกัน รวมทั้งสิ้น n ตัว\n4. แสดงตัวเลข 1, 0, 1, 0, ... สลับกัน รวมทั้งสิ้น n ตัว\n5. แสดงตัวเลขจาก 0 ถึง n-1 \n6. แสดงตัวเลขจาก n-1 ถึง 0\n7. แสดงตัวเลขฟีโบนักชี n ตัวแรก\n8. แสดงตัวเลขฟีโบนักชี n ตัวแรกจากหลังมาหน้า\n9. แสดงตัวเลขในลำดับสามเหลี่ยม n ตัวแรก (0, 0+1, 0+1+2, …)\n10. แสดงตัวเลขในลำดับสามเหลี่ยม n ตัวแรก จากหลังมาหน้า","archived":true},"85c71d19-2439-429a-a072-432363ae7e87":{"deleted":false,"solution":"Answer: \"19\"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F85c71d19-2439-429a-a072-432363ae7e87%2Frecursion-depth-1.png?alt=media&token=5da57c57-363e-41f6-b96d-41baf1d6d29b","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F85c71d19-2439-429a-a072-432363ae7e87%2Frecursion-depth-2.png?alt=media&token=8b1b5898-1be4-4fc1-a01f-5398b2601428"],"tags":["algorithms","graph-algorithms"],"createdAt":{"_seconds":1533106817,"_nanoseconds":0},"note":"- **Author:** คูน","updatedAt":{"_seconds":1537254224,"_nanoseconds":51000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"## เวอร์ชันภาษาไทย\n\n**ตัวอย่าง:** พิจารณากราฟที่มีลักษณะเป็น Grid $3 \\times 3$ ดังรูปข้างล่าง หากเราใช้อัลกอริทึม Depth-first search (DFS) กับกราฟนี้โดยเริ่มต้นจากโหนดใดก็ได้ เราจะได้ Maximum recursion depth เท่ากับ 9 ดังที่แสดงด้วยเส้นสีฟ้า\n\n![][diagram1]\n\nจงหา Maximum recursion depth ที่เป็นไปได้ หากเราสามารถใช้อัลกอริทึม Depth-first search จากโหนดใดก็ได้ในกราฟต่อไปนี้\n\n![][diagram2]\n\n## English Version\n\n**Example:** Consider the following graph in the form of $3 \\times 3$ grid. Upon the application the depth-first search (DFS) algorithm on this graph beginning at an arbitrary node, the maximum recursion depth would be 9 (as shown by a blue line). \n\n(Image)\n\nWhat is the maximum recursion depth when applying depth-first search algorithm to another graph show below.\n\n(Image)\n\n[diagram1]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F85c71d19-2439-429a-a072-432363ae7e87%2Frecursion-depth-1.png?alt=media&token=5da57c57-363e-41f6-b96d-41baf1d6d29b\n[diagram2]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F85c71d19-2439-429a-a072-432363ae7e87%2Frecursion-depth-2.png?alt=media&token=8b1b5898-1be4-4fc1-a01f-5398b2601428\n","archived":true,"region":{"central":false,"northeast":false,"south":false,"north":true}},"86df8824-1ebf-4268-aa84-3b841472c12f":{"archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":true,"solution":"$\\sum_{k=1}^n \\frac{1}{ \\lfloor n/k \\rfloor }$","imageUrls":[],"tags":[],"createdAt":{"_seconds":1539136882,"_nanoseconds":40000000},"note":"","updatedAt":{"_seconds":1539137530,"_nanoseconds":700000000},"format":{"quickfire":false,"choices":false,"coding":true,"ponder":false},"round":{"audition":false,"national":true,"regional":false},"statement":"Noctis writes the numbers 1, 2, 3, . . . ,$n$ on a chalkboard. Then he erases all the numbers by\nmaking a series of moves; in each move, he chooses a number $k$ uniformly at random from the set\nof all numbers still on the chalkboard, and then erases all of the divisors of $k$ that are still on the\nchalkboard (including $k$ itself). What is the expected number of moves that Noctis must make to erase\nall the numbers?"},"87d11e1b-f2fe-417b-9d2a-1e72876a1835":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"Choice 5:\n\n```\nsort-inplace(L, 150, 249)\nsort-inplace(L, 0, 199)\nsort-inplace(L, 150, 249)\n```","imageUrls":[],"tags":["algorithms","propose-central-audition"],"createdAt":{"_seconds":1533106822,"_nanoseconds":0},"note":"- **Category:** Algorithm\n- **Author:** เพลน\n- Verified by Eak","updatedAt":{"_seconds":1537782114,"_nanoseconds":697000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"regional":false,"audition":true,"national":false},"statement":"สมมติว่ามี Array `L` ซึ่งประกอบด้วยตัวเลข 250 ตัวซึ่งอาจไม่เรียงลำดับ \n\nนอกจากนั้นแล้ว ยังมีฟังก์ชัน `sort-inplace(L, p, q)` ซึ่งจะจัดเรียงจำนวนใน Array L จากน้อยไปมาก **เฉพาะระหว่างตำแหน่ง `p` และ `q`**\n\nชุดคำสั่งข้อใดต่อไปนี้**ไม่รับประกัน**ว่าสามารถเรียงลำดับตัวเลขทั้งหมด 250 ตัวได้?\n\n1.   ```\n    sort-inplace(L, 0, 249)\n    ```\n2.  ```\n    sort-inplace(L, 0, 199)\n    sort-inplace(L, 150, 249)\n    sort-inplace(L, 0, 199)\n    ```\n3.  ```\n    sort-inplace(L, 0, 199)\n    sort-inplace(L, 50, 249)\n    sort-inplace(L, 0, 149)\n    ```\n4.  ```\n    sort-inplace(L, 100, 249)\n    sort-inplace(L, 0, 149)\n    sort-inplace(L, 50, 249)\n    ```\n5.  ```\n    sort-inplace(L, 150, 249)\n    sort-inplace(L, 0, 199)\n    sort-inplace(L, 150, 249)\n    ```","archived":true},"898c6e86-118c-4ec5-a9ee-eb5087221604":{"archived":false,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":true,"solution":"\"3\"","imageUrls":[],"tags":["propose-north-audition"],"createdAt":{"_seconds":1535332374,"_nanoseconds":16000000},"note":"- easy quickfire\n- จิ copy จาก codility","updatedAt":{"_seconds":1536543187,"_nanoseconds":494000000},"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":false,"audition":true,"national":false},"statement":"Given a list of 1000 elements, which of the following numbers is the largest?\n\n1. The number of all possible subsets of a given list\n2. The number of all possible pairs of elements from a given list\n3. The number of all possible permutations of a given list\n4. 10,000,000,000,000,000\n\nถ้ามี List ขนาด 1000 ตัว  จำนวนในข้อใดต่อไปนี้มีขนาดใหญ่ที่สุด\n\n1. จำนวนของ subset ที่เป็นไปได้ทั้งหมดของ List ดังกล่าว\n2. จำนวนของการจับคู่ element จาก List ดังกล่าว 2 elements ที่เป็นไปได้ทั้งหมด\n3. *คิดคำแปล permutation ไม่ออก*\n4. 10,000,000,000,000,000\n"},"8af99f66-870d-4ab3-a54b-a8c78c2ec02e":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-1a.png?alt=media&token=5013468f-3ee4-45f8-8e05-8a55704a37a7","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-1b.png?alt=media&token=a2f95458-e1d1-4844-8580-cd74e99fd02b","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-2a.png?alt=media&token=724681ee-5a44-49aa-923f-c13fdd6706c2","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-2b.png?alt=media&token=340dae85-7ca0-4ce1-b01e-3fd93a4ae2a9"],"tags":["dynamic-programming"],"createdAt":{"_seconds":1538323111,"_nanoseconds":500000000},"note":"","updatedAt":{"_seconds":1538557913,"_nanoseconds":386000000},"format":{"coding":true,"ponder":false,"quickfire":false,"choices":false},"round":{"national":false,"regional":true,"audition":false},"statement":"# Descending Drills\n\n### Background\n\nผืนดินแห่งหนึ่งมีสมบัติซ่อนอยู่ใต้ดินมากมาย เนื่องด้วยเทคโนโลยี Remote Sensing ในปัจจุบัน ทำให้เราสามารถสำรวจมูลค่าของสมบัติที่อยู่ใต้ดินในบริเวณต่าง ๆ ได้ โดยที่เราไม่ต้องขุดสมบัติออกจากดินเพื่อมาตีราคาแต่อย่างใด\n\nเราจะมองชั้นดินที่เต็มไปด้วยสมบัติดังกล่าวเป็นพื้นที่หน้าตัดรูปสี่เหลี่ยมผืนผ้า ซึ่งเราจะแบ่งสี่เหลี่ยมผืนผ้าดังกล่าวเป็นชั้นดินลึก $R$ ชั้น ชั้นละ $C$ ช่อง ดินแต่ละช่องจะมีมูลค่าของสมบัติกำกับไว้ด้วยซึ่งเป็นจำนวนเต็มที่อาจเป็นบวก ลบ หรือศูนย์ก็ได้\n\n(รูปต่อไปนี้คือตัวอย่างข้อมูลของสมบัติในชั้นดินที่มี $R=6$ และ $C=6$)\n\n![][d1a]\n\nเราต้องการจะเจาะผืนดินเพื่อล่าสมบัติที่อยู่ในดินให้ได้ผลรวมมากที่สุด แต่เนื่องด้วยขีดจำกัดของนวัตกรรมการขุดเจาะที่ยังมีราคาแพง ทำให้เรามีโอกาสเดียวเท่านั้นในการขุดเจาะผืนดินดังกล่าว ลักษณะเส้นทางของการขุดดินจะมีเงื่อนไขดังนี้\n\n- เราสามารถเริ่มต้นขุดเจาะจากผิวดิน เหนือช่องคอลัมน์ใดก็ได้\n- ตลอดการขุดเจาะในครั้งนี้ เราสามารถขุดเจาะดินในแนวดิ่ง เผื่อลงไปยังชั้นดินชั้นต่อไปก็ได้ หรือจะขุดเจาะในแนวราบไปทางซ้ายหรือขวาในชั้นดินระดับเดียวกันก็ได้ แต่ไม่สามารถเจาะสวนทางแรงโน้มถ่วงในทิศทางชี้สู่ผิวดินได้\n- สำหรับการขุดเจาะแนวราบนั้น เมื่อเราขุดเจาะลงสู่ชั้นดินหนึ่ง ๆ เครื่องขุดเจาะอาจจะเลือกขุดเจาะไปทางซ้ายหรือทางขวา ทิศทางใดทิศทางหนึ่งเท่านั้น (หรือจะไม่ขยับในแนวราบก็ได้) และการขุดแนวราบดังกล่าว จะขยับจากจุดเริ่มต้นได้ไม่เกิน $K$ ช่อง\n- เครื่องขุดเจาะไม่สามารถเดินถอยหลังไปยังช่องดินที่เคยขุดเจาะไปแล้วได้ ไม่ว่าจะเป็นแนวดิ่งหรือแนวราบก็ตาม\n- การขุดเจาะจะสิ้นสุดที่ช่องใดก็ได้\n\nรูปต่อไปนี้มีเส้นสีแดงแสดงเส้นทางการขุดเจาะชั้นดิน เพื่อล่าสมบัติที่อยู่ในดิน  \n(โดยมีเงื่อนไขว่า $K=2$ สังเกตว่าไม่มีการขยับในแนวราบเกิน 2 ช่องเลยในทุกระดับชั้นดิน)\n\n![][d1b]\n\nมูลค่ารวมของสมบัติที่เก็บสะสมได้ คือผลรวมของมูลค่าของสมบัติทุกช่องที่เครื่องขุดเจาะนี้แทรกผ่าน  \n(จากรูปตัวอย่างข้างต้น หากขุดเจาะตามเส้นสีแดง จะได้สมบัติรวมมูลค่า 63 หน่วย ซึ่งเป็นวิธีที่ดีที่สุด)\n\n### Problem Statement\n\nกำหนดให้มูลค่าของสมบัติในดินเป็นตารางสี่เหลี่ยมผืนผ้าขนาด $R$ แถวและ $C$ คอลัมน์ จงหามูลค่าสมบัติรวมที่มากที่สุดที่เกิดจากการขุดเจาะด้วยโอกาสเพียง 1 ครั้งตามเงื่อนไขข้างต้น \n\n**หมายเหตุ:**  \n- (1) ไม่จำเป็นว่าจะต้องขุดเจาะถึงชั้นผิวดินแถวล่างสุดเสมอไป \n- (2) สมบัติที่มีมูลค่าติดลบที่ค้นพบระหว่างทางจะต้องถูกนำมารวมในผลรวมด้วยเสมอ  \n- (3) หากไม่มีรูปแบบการขุดเจาะที่ทำให้ผลรวมสมบัติเป็นบวกเลย สามารถตอบ `0` ได้\n\n\n### Program Specification \n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มสามตัว $R, C, K$ คั่นด้วยช่องว่าง\n- อีก $R$ บรรทัดถัดมา บรรทัดที่ $i+1$ จะมีจำนวนเต็ม $C$ จำนวน คั่นด้วยช่องว่าง แทนมูลค่าของสมบัติในชั้นดินที่ $i$ เรียงจากซ้ายไปขวา\n\n$$\n\\begin{aligned}\n& R \\;\\; C \\;\\; K \\\\\n& v[1,1] \\;\\; v[1,2] \\;\\; \\ldots \\;\\; v[1,C] \\\\\n& v[2,1] \\;\\; v[2,2] \\;\\; \\ldots \\;\\; v[2,C] \\\\\n& \\vdots \\\\\n& v[R,1] \\;\\; v[R,2] \\;\\; \\ldots \\;\\; v[R,C] \\\\\n\\end{aligned}\n$$\n\n#### Output Format\n\n- คำตอบประกอบด้วยจำนวนเต็มเพียงหนึ่งตัว ซึ่งระบุผลรวมของสมบัติที่มากที่สุดที่สามารถหาได้จากการขุดเจาะเพียงครั้งเดียวตามเงื่อนไขที่กำหนดไว้\n\n### Example #1\n\n#### Input\n\n```plaintext\n6 6 2\n3 -1 1 2 3 7\n4 -2 7 4 4 -5\n6 -5 1 -9 -2 6\n8 7 -9 8 6 -8\n1 9 2 6 -4 1\n4 2 -9 4 -5 -3\n```\n\n#### Output\n\n```plaintext\n63\n```\n\n### Example #2\n\n#### Input\n\n```plaintext\n6 5 1\n-1 -1 -1 -1 -1\n-1 1 1 -1 -1\n-1 -1 -1 -1 -1\n-1 -1 1 1 -1\n-2 -2 -2 -2 -2\n-1 1 -1 1 0\n```\n\n#### Output\n\n```plaintext\n2\n```\n\n#### รูปประกอบตัวอย่างที่ 2\n\n![][d2a] ![][d2b]\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า ขนาดของตารางจะสอดคล้องกับเงื่อนไขที่ว่า $1 \\leq R, C \\leq 200$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า จำนวนช่องในตารางจะสอดคล้องกับเงื่อนไขที่ว่า $1 \\leq RC \\leq 2 \\cdot 10^6$\n- สำหรับทุก test cases จะมีเงื่อนไขว่า จำนวนช่องที่ขยับได้ในแนวราบในแถว ๆ หนึ่งจะสอดคล้องกับเงื่อนไข $0 \\leq K < C$ และมูลค่าสมบัติแต่ละช่องจะมีค่าที่สอดคล้องกับเงื่อนไข $-1000 \\leq v[i,j] \\leq 1000$\n\n[d1a]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-1a.png?alt=media&token=5013468f-3ee4-45f8-8e05-8a55704a37a7\n[d1b]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-1b.png?alt=media&token=a2f95458-e1d1-4844-8580-cd74e99fd02b\n[d2a]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-2a.png?alt=media&token=724681ee-5a44-49aa-923f-c13fdd6706c2\n[d2b]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F8af99f66-870d-4ab3-a54b-a8c78c2ec02e%2Fdescending-drills-2b.png?alt=media&token=340dae85-7ca0-4ce1-b01e-3fd93a4ae2a9\n","archived":true},"8ba8fa54-1b62-4847-98c1-a8609b4721e6":{"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false},"round":{"regional":false,"audition":true,"national":false},"statement":"ธนาคารกสิกรจัดประเพณีวิ่งควายที่จังหวัดชลบุรี มีควายร่วมเข้าประกวดวิ่งจำนวน 25 ตัว แต่ภายในงานมีลู่ให้ควายวิ่งได้แค่รอบละ 5 ตัวเท่านั้น \n\nหากธนาคารต้องการหาควายที่วิ่งเร็วที่สุด 3 อันดับแรก จะต้องจัดการแข่งขันอย่างน้อยกี่รอบ\n\n**หมายเหตุ:** สมมติว่าควายวิ่งด้วยอัตราเร็วเท่าเดิมตลอดทุกรอบ และเราไม่สามารถใช้นาฬิกาจับเวลาได้","archived":false,"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":true,"solution":"7","imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106818,"_nanoseconds":0},"note":"- Question is too well known (Google: `racing`, `25`, `5`, `3`)","updatedAt":{"_seconds":1533106818,"_nanoseconds":0}},"8c843db6-221b-46ab-95d3-060bb5696095":{"imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F-LJnNYDSHhMR6A8uyqPZ?alt=media&token=4e0f4ef1-3b0f-4560-aba0-a4146fdf8e54"],"tags":["algorithms","hard-math"],"createdAt":{"_seconds":1533106827,"_nanoseconds":0},"note":"- **Category:** Counting / Hard Math\n- **Author:** เพลน\n- **Time:** 20 seconds\n - Verified by Ball เดา10วินาที  พิสูจน์1นาที","updatedAt":{"_seconds":1539229968,"_nanoseconds":161000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"national":true,"regional":false,"audition":false},"statement":"### ตัวอย่าง\n\n- พิจารณาห้องภาพในพิพิธภัณฑ์แห่งหนึ่งที่มีลักษณะเป็น **\"ห้าเหลี่ยม\"** เมื่อมองจากด้านบน ในรูปแบบต่าง ๆ (ดูภาพประกอบ)\n- สังเกตได้ว่าหากเราจ้างเจ้าหน้าที่รักษาความปลอดภัย 1 คนไปยืน ณ จุดดำในรูป เขาจะสามารถสอดส่องห้องทั้งห้องได้ทุกซอกทุกมุม\n\n### โจทย์\n\n- อยู่มาวันหนึ่งพิพิธภัณฑ์แห่งนี้เปิดห้องภาพอีกห้องหนึ่งซึ่งมีลักษณะเป็น **\"สิบเหลี่ยม\"** โดยที่เรา ***ไม่ทราบ*** ลักษณะความเว้าหรือนูนของห้องนี้  \n- อยากทราบว่า ในกรณีจะต้องจ้างเจ้าหน้าที่ รปภ. **อย่างน้อย**กี่คนไปยืนประจำการในห้องดังกล่าว  จึงจะ**รับประกัน**ว่าทุกซอกมุมในห้องจะมี รปภ. อย่างน้อยหนึ่งคนมองเห็นเสมอ?\n\n**หมายเหตุ:** สมมติว่า รปภ. จะไม่ขยับจากตำแหน่งที่ตัวเองยืนเลย แต่สามารถมองได้ทุกมุม 360°","archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":true,"solution":"3 คน"},"8fa591a1-b147-406e-99e9-711b2c1f0030":{"imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106819,"_nanoseconds":0},"note":"- Question is too well known (basic logical paradox)","updatedAt":{"_seconds":1533106819,"_nanoseconds":0},"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"audition":false,"national":false,"regional":false},"statement":"สมมติเราติดอยู่ในโลก K PLUS กับ AI ที่ภายนอกเหมือนกันทุกประการ แต่เราสามารถแบ่งแยก AI เป็น 3 ประเภทดังนี้\n\n- KADE เป็น AI ที่พูดความจริงเสมอ\n- FAKE เป็น AI ที่พูดความเท็จเสมอ\n- Normal เป็น AI ที่พูดจริงหรือเท็จก็ได้\n\nวันหนึ่งเราพบ AI ตัวหนึ่งบอกกับเราว่า \"ฉันไม่ใช่ KADE\" \n\nจงหาว่า AI ตัวนี้ เป็น AI ประเภทใดได้บ้าง?\n\n1. KADE เท่านั้น\n2. FAKE เท่านั้น\n3. Normal เท่านั้น\n4. KADE หรือ FAKE\n5. KADE หรือ Normal\n6. FAKE หรือ Normal\n7. เป็นไปได้ทั้งสามประเภท\n8. เป็นไป_ไม่ได้_เลยทั้งสามประเภท","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"3. Normal เท่านั้น"},"910e4bea-3b32-4c49-ac6c-cec58652cc39":{"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"national":false,"regional":true,"audition":false},"statement":"ให้พิจารณาสมการดังต่อไปนี้ โดยสมมติว่า\n- แต่จะพจน์ (term) คือจำนวนเต็มที่เลขโดดแต่ละตัวถูกเขียนแทนที่ด้วยอักขระภาษาอังกฤษ\n- อักขระภาษาอังกฤษตัวเดียวกันแทนเลขโดดเดียวกัน อักขระที่ต่างกันแทนเลขโดดที่ไม่ซ้ำกัน\n- ไม่มีพจน์ใดที่อักขระตัวแรกแทนเลขโดด $0$\n$$\nTEACH + KBTG + TECH = HACKER\n$$\n\nอยากทราบว่าคำว่า $BRACKET$ แทนจำนวนใด?","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"Answer: $6\\,408\\,359$\n\n$TEACH = 95\\,081$, $KBTG = 3\\,692$, $TECH = 9\\,581$, $HACKER = 108\\,354$","imageUrls":[],"tags":["math-puzzle","verbal-arithmetic","cryptarithm"],"createdAt":{"_seconds":1537472564,"_nanoseconds":991000000},"note":"- **Author:** เพลน\n- มี solver ที่เว็บนี้ https://www.dcode.fr/cryptarithm-solver\n- ถ้าถามคำว่า $HEARTBREAKER$ อาจจะโหดร้ายเกินไป 5 5 5 +\n- Verified by Eak - แต่สงสัยว่าทำอย่างอื่นนอกจาก brute force ได้มั้ย ดูแล้วเขียน code brute force ให้ทันใน 5 นาทีได้ยากมาก","updatedAt":{"_seconds":1538369872,"_nanoseconds":722000000}},"914c7d04-f4e2-40c0-85b0-f92f91dbdb0c":{"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"audition":false,"national":true,"regional":false},"statement":"Find the number\nof 6-tuples $(S_1, S_2, . . . , S_6)$ of subsets $S_i$ of {1, 2, . . . , 6} satisfying\n$S_1 ⊆ S_2 ⊇ S_3 ⊆ S_4 ⊇ S_5 ⊆ S_6$ .","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"$21^6$","imageUrls":[],"tags":[],"createdAt":{"_seconds":1539137275,"_nanoseconds":36000000},"note":"","updatedAt":{"_seconds":1539333498,"_nanoseconds":721000000}},"919cb80d-1751-46f4-b72c-9618ce16742f":{"note":"- Recycled","updatedAt":{"_seconds":1536575565,"_nanoseconds":724000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true},"round":{"audition":true,"national":false,"regional":false},"statement":"มีไพ่ 8 ใบเรียงอยู่บนโต๊ะดังนี้\n\n    2, 9, 3, 5, King, Ace, 6, 7\n\nเราต้องการเรียงลำดับใหม่จากน้อยไปมาก โดย Ace สามารถเป็นได้ ทั้งไพ่ใบแรกสุด (มีค่าน้อยที่สุด) หรือไพ่ใบสุดท้าย (มีค่ามากที่สุด) ก็ได้\n\nวิธีการย้ายไพ่ ในครั้งแรกเลือกไพ่ 1 ใบ แล้วย้ายไปวางไว้ขวาสุด ครั้งที่ 2 เลือกไพ่ 1 ใบแล้วย้ายไปวางไว้ซ้ายสุด สลับอย่างนี้ไปเรื่อย ๆ\n\nถ้าต้องการเรียงไพ่โดยย้ายไพ่น้อยครั้งที่สุด ครั้งแรกจะย้ายไพ่ใบใด?\n\n1. 2\n2. 9\n3. 3\n4. 5\n5. King\n6. Ace\n7. 6\n8. 7","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false},"deleted":false,"solution":"\"9\"","imageUrls":[],"tags":["logic-puzzle"],"createdAt":{"_seconds":1535292574,"_nanoseconds":787000000}},"93a092f1-0417-4bd1-8e2a-1528d4e22600":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F93a092f1-0417-4bd1-8e2a-1528d4e22600%2Fsample-1.png?alt=media&token=917623be-1b7f-4d91-8f37-66fb0d5436a5"],"tags":["graph-algorithms","shortest-path"],"createdAt":{"_seconds":1538475316,"_nanoseconds":877000000},"note":"","updatedAt":{"_seconds":1538648300,"_nanoseconds":912000000},"format":{"coding":true,"ponder":false,"quickfire":false,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"# Lobbying Tollway\n\n### Background\n\nบริษัทขนส่งสินค้าแห่งหนึ่ง จำเป็นต้องวางแผนการลำเลียงส่งสินค้าระหว่างเมืองสองเมืองในดินแดนที่มีเมืองทั้งสิ้น $N$ เมือง และมีโครงข่ายของถนน $M$ สายที่เชื่อมเมืองเหล่านี้ให้เดินทางไปมาหาสู่กันได้ทั้งหมด เมืองแต่ละเมืองจะมีหมายเลข $1$ ถึง $N$ ส่วนถนนแต่ละสายจะมีหมายเลข $1$ ถึง $M$ ตามลำดับ\n\nสำหรับแต่ละ $i=1,2,\\ldots,M$ ถนนสายที่ $i$ จะเป็นถนนวิ่งทางเดียว (one-way road) ที่เชื่อมการเดินทางจากเมือง $u_i$ ไปยังเมือง $v_i$ เสมอ ($1 \\leq u_i, v_i \\leq N$) นอกจากนั้นอาจจะมีค่าผ่านทาง $p_i$ บาทที่คนใช้ถนนสายนี้ต้องจ่ายเพื่อใช้งาน ($p_i \\geq 0$) นอกจากนั้น กำหนดว่าถ้าถนนสายไหนไม่มีค่าผ่านทาง นั่นแปลว่า $p_i = 0$\n\nพึงทราบว่า อาจมีถนนวิ่งทางเดียวที่เชื่อมจากเมืองหนึ่งไปยังอีกเมืองหนึ่ง มากกว่า 1 สายก็ได้ นอกจากนั้นอาจมีถนนที่เชื่อมระหว่างเมืองสองเมือง ไป-กลับ โดยที่ถนนเหล่านี้เก็บค่าผ่านทางที่ไม่เท่ากันก็ได้\n\nโดยปกตินั้น บริษัทนี้ได้สำรวจเส้นทางทั้งหมดที่เป็นไปได้ เพื่อใช้ลำเลียงสินค้าจากเมืองหมายเลข $1$ ไปยังเมืองหมายเลข $N$ โดยเส้นทางเหล่านี้ล้วนแต่เป็นเส้นทางที่เสียค่าผ่านทางรวมน้อยที่สุดทั้งสิ้น\n\nในเวลาต่อมา บริษัทนี้ต้องการเปิดเส้นทางการลำเลียงสินค้าเพิ่มขึ้นอย่างน้อย 1 เส้นทาง โดยมีเงื่อนไขต่อไปนี้\n\n1. บริษัทจะไปล็อบบี้กับผู้บริหารของเครือข่ายถนน เพื่อให้ลดค่าผ่านทางของถนนเพียง 1 สายเท่านั้น\n2. ค่าผ่านทางใหม่นั้นจะติดลบไม่ได้\n3. ค่าผ่านทางใหม่นั้นจะต้องลดลงจากค่าผ่านทางเดิม เป็นปริมาณเงินน้อยที่สุดเท่าที่เป็นไปได้\n4. เส้นทางการลำเลียงสินค้าเดิมที่เคยสำรวจไว้จะต้องไม่กระทบ กล่าวคือเส้นทางเดิมแต่ละเส้นทางจะยังคงใช้งานได้เช่นเดิม และมีค่าผ่านทางรวมเท่าเดิม ไม่เพิ่มขึ้นหรือลดลง\n5. จะต้องมีเส้นทางใหม่การลำเลียงสินค้าเกิดขึ้นอย่างน้อย 1 เส้นทาง และจะต้องไม่ซ้ำกันเส้นทางเดิมที่บริษัทเคยสำรวจไว้ และราคาค่าผ่านทางรวมของเส้นทางใหม่นี้จะต้องเท่ากับราคาค่าผ่านทางรวมของเส้นทางเดิมอื่น ๆ ของบริษัทด้วย\n\n### Problem Statement\n\nจงรับข้อมูลเครือข่ายถนนในดินแดนแห่งหนึ่ง รวมถึงค่าผ่านทางของถนนแต่ละสาย แล้วหาว่าบริษัทนี้จะต้องไปล็อบบี้เพื่อลดค่าผ่านทางของถนนสายใด 1 สาย และเป็นปริมาณเงินลดลงน้อยที่สุดเท่าใด จึงจะสามารถเปิดเส้นทางใหม่เพื่อใช้ลำเลียงสินค้าจากเมือง $1$ ไปเมือง $N$ ได้ โดยเส้นทางใหม่ที่เกิดขึ้นนี้จะมีค่าผ่านทางรวมถูกที่สุด และถูกเท่า ๆ กับเส้นทางอื่น ๆ ที่เคยมีการสำรวจมาก่อนหน้านี้แล้ว\n\nหากมีถนนที่เป็นไปได้หลายสายที่สามารถล็อบบี้ให้ลดราคาลงเป็นปริมาณที่น้อยที่สุดได้ ให้ตอบหมายเลขของถนนทุกสายด้วย\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มสองจำนวน $N$ และ $M$ คั่นด้วยช่องว่าง\n- อีก $M$ บรรทัดถัดมา บรรทัดที่ $i+1$: จะมีจำนวนเต็มสามจำนวน $u_i, v_i, p_i$ (คั่นด้วยช่องว่าง) ระบบข้อมูลของถนนหมายเลข $i$ ซึ่งเป็นถนนวิ่งทางเดียวจากเมืองหมายเลข $u_i$ ไปยังเมืองหมายเลข $v_i$ และเก็บค่าผ่านทาง $p_i$ บาท\n\n$$\n\\begin{aligned}\n& N \\;\\; M \\\\\n& u_1 \\;\\; v_1 \\;\\; p_1 \\\\\n& u_2 \\;\\; v_2 \\;\\; p_2 \\\\\n& \\vdots \\\\\n& u_M \\;\\; v_M \\;\\; p_M \\\\\n\\end{aligned}\n$$\n\n**หมายเหตุ:** ข้อมูล Input จะรับประกันว่า มีเส้นทางที่เชื่อมจากเมืองหมายเลข $1$ ไปเมืองหมายเลข $N$ เสมอ\n\n#### Output Format\n\n- บรรทัดที่ 1: จะต้องเขียนจำนวนเต็มสองจำนวน $D$ และ $K$ คั่นด้วยช่องว่างหนึ่งช่อง โดยที่ $D$ จะระบุปริมาณค่าผ่านทางที่ลดลงน้อยที่สุดที่เป็นไปได้ และ $K$ คือจำนวนถนนทั้งหมดที่สามารถล็อบบี้ให้ลดค่าผ่านทางได้\n- อีก $K$ บรรทัดถัดมา แต่ละบรรทัดจะมีจำนวนเต็ม 1 จำนวน ซึ่งแต่ละจำนวนจะระบุหมายเลขถนนที่สามารถล็อบบี้ได้ นอกจากนั้น หมายเลขถนนทั้งหมดจะต้องเรียงจากน้อยไปมาก \n\n**หมายเหตุ:** ในกรณีที่บริษัทไม่สามารถใช้วิธีล็อบบี้ใด ๆ เพื่อเปิดเส้นทางใหม่ได้เลย ให้ตอบว่า $D=0$ และ $K=0$ เป็นกรณีพิเศษ\n\n### Example #1\n\n#### Input\n\n```plaintext\n7 10\n1 2 8\n1 3 6\n1 4 6\n1 5 3\n1 6 12\n2 7 8\n3 7 5\n4 7 7\n5 7 8\n6 7 1\n```\n\n#### Output\n\n```plaintext\n2 3\n3\n5\n8\n```\n\n- จากตัวอย่างข้อมูลนี้ พบว่าจะมีเส้นทางลำเลียงที่ใช้ค่าผ่านทางรวมน้อยที่สุด 11 บาท ซึ่งมี 2 เส้นทาง ได้แก่ (1) เส้นทางที่ใช้ถนนหมายเลข $2 \\,\\&\\, 7$ และอีกเส้นทางที่ใช้ถนนหมายเลข $4 \\,\\&\\, 9$\n- หากเราล็อบบี้ให้มีการลดค่าผ่านทาง 2 บาท ให้แก่ถนน 1 สายในบรรดาถนน 3 สาย สายได้ก็ได้ (ซึ่งได้แก่ถนนหมายเลข $3$, $5$ และ $8$) แล้วจะทำให้มีเส้นทางลำเลียงสินค้าเส้นทางใหม่ที่ใช้เงินรวม 11 บาทเช่นกัน\n\n### Example #2\n\n#### Input\n\n```plaintext\n4 5\n1 2 2\n1 3 3\n2 3 1\n2 4 3\n3 4 2\n```\n\n#### Output\n\n```plaintext\n0 0\n```\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า จำนวนเมืองทั้งหมดจะสอดคล้องกับเงื่อนไข $3 \\leq N \\leq 50$ และจำนวนถนนทั้งหมดจะสอดคล้องกับเงื่อนไข $1 \\leq M \\leq 2,\\!000$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า จำนวนเมืองทั้งหมดจะสอดคล้องกับเงื่อนไข $3 \\leq N \\leq 100,\\!000$ และจำนวนถนนทั้งหมดจะสอดคล้องกับเงื่อนไข $1 \\leq M \\leq 200,\\!000$\n- สำหรับทุก test cases จะมีเงื่อนไขว่า ค่าผ่านทางเริ่มต้นของถนนทุกสายจะสอดคล้องกับเงื่อนไข $0 \\leq p_i \\leq 5,\\!000$\n\n[d1]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F93a092f1-0417-4bd1-8e2a-1528d4e22600%2Fsample-1.png?alt=media&token=917623be-1b7f-4d91-8f37-66fb0d5436a5","archived":true},"949af6e0-8dfc-4dc8-b55f-a84d57bcb544":{"round":{"national":false,"regional":false,"audition":true},"statement":"สมมติว่ามีเหรียญบาทอยู่เหรียญหนึ่ง เมื่อโยนแต่ละครั้งแล้วจะให้ผลลัพธ์เป็นหัวด้วยความน่าจะเป็น 49% และเป็นก้อยด้วยความน่าจะเป็น 51%\n\nเป้าหมายของเราคือ เราจะใช้เหรียญบาทดังกล่าวในการเขียนโปรแกรมเพื่อสุ่มตัวเลข 0 หรือ 1 อย่างเที่ยงธรรมที่สุดเท่าที่เป็นไปได้ (นั่นคือโอกาสในการออกหัวหรือก้อยต้องเท่ากัน หรือใกล้เคียงกันให้มากที่สุด) โดยโปรแกรมดังกล่าวจะมีอินเตอร์เฟสที่ต่อเข้าถึงการโยนเหรียญบาทข้างต้น (ด้วยการเรียกใช้ฟังก์ชัน `toss()` ซึ่งจะคืนค่าสตริง `\"head\"` หรือ `\"tail\"` เท่านั้น)\n\nจงเรียงลำดับความยุติธรรมของโปรแกรมต่อไปนี้ จากยุติธรรมมากที่สุดไปยังน้อยที่สุด\n\n- **โปรแกรม A** \n    ```pseudocode\n    repeat until terminate\n        count_heads := 0\n        for i := 1 to 100 do\n             if toss() == \"head\" then count_heads := count_heads + 1\n        end\n        if count_heads < 49 then\n            output 0 and terminate\n        else if count_heads > 49\n            output 1 and terminate \n        end\n    end\n    ```\n- **โปรแกรม B**\n    ```pseudocode\n    repeat until break\n        result := toss()\n        if result == \"tail\" then\n            break  # break from loop\n        end\n    end\n    if toss() := \"head\" then\n        output 0\n    else \n        output 1 \n    end\n    terminate\n    ```\n- **โปรแกรม C**\n    ```pseudocode\n    repeat until terminate\n        count_heads := 0\n        if toss() == \"head\" then count_heads := count_heads + 1\n        if toss() == \"head\" then count_heads := count_heads + 1\n        if count_heads ≠ 1 then\n            output count_heads/2 and terminate\n        end\n    end\n    ```\n- **โปรแกรม D**\n    ```pseudocode\n    repeat until terminate\n        count_heads := 0\n        if toss() == \"head\" then count_heads := count_heads + 1\n        result := count_heads\n        if toss() == \"head\" then count_heads := count_heads + 1\n        if count_heads == 1 then\n            output result and terminate\n        end\n    end\n    ```\n\n1. A, B, C, D\n2. A, B, D, C\n3. A, C, B, D\n4. A, C, D, B\n5. A, D, B, C\n6. A, D, C, B\n7. B, A, C, D\n8. B, A, D, C\n9. B, C, A, D\n10. B, C, D, A\n11. B, D, A, C\n12. B, D, C, A\n13. C, A, B, D\n14. C, A, D, B\n15. C, B, A, D\n16. C, B, D, A\n17. C, D, A, B\n18. C, D, B, A\n19. D, A, B, C\n20. D, A, C, B\n21. D, B, A, C\n22. D, B, C, A\n23. D, C, A, B\n24. D, C, B, A","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"D > A > B > C\n\n- A. 50.0286% _vs_ 49.9714%\n- B. 49% _vs_ 51%\n- C. 51.9992% _vs_ 48.0008%\n- D. 50% _vs_ 50%","imageUrls":[],"tags":["math-puzzle","probability","algorithms","randomized-algorithms"],"createdAt":{"_seconds":1536686207,"_nanoseconds":3000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1537289023,"_nanoseconds":728000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true}},"95a8c731-8251-4ca4-a22a-310d6c3717dc":{"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1539666920,"_nanoseconds":123000000},"note":"","updatedAt":{"_seconds":1539666920,"_nanoseconds":123000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"national":true,"regional":false,"audition":false},"statement":"ในงานสังสรรค์งานหนึ่ง มีคนทั้งสิ้น 100 คนเล่นเป่า-ยิง-ฉุบโดยพร้อมเพรียงกัน \n\nกล่าวคือคนแต่ละคนจะเลือกออก (1) **ค้อน** (2) **กรรไกร** หรือ (3) **กระดาษ** อย่างใดอย่างหนึ่ง  โดยที่แต่ละคนจะถือว่าเป็น “ผู้ชนะโดยรวม” หากออกอาวุธชนะผู้เล่นอื่น ๆ เป็นจำนวนมากกว่าจำนวนผู้เล่นอื่น ๆ ที่ตนเองแพ้\n\nอยากทราบว่า ... บลา ๆ ๆ","archived":false},"9635de9b-2399-417e-88f2-9f4646b2d21f":{"note":"- เอก\n- Quickfire 20 วิ\n- ถือว่า verified by Plane ไปแล้วละกันนะ","updatedAt":{"_seconds":1536575929,"_nanoseconds":376000000},"format":{"choices":false,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":true,"audition":false,"national":false},"statement":"ถ้าเรามีลำดับเลข Fibonacci ที่มีขนาดเป็นอนันต์\n\nจงหาอัตราส่วนของ **จำนวนเลขคู่ ต่อ จำนวนเลขคี่** ในลำดับเลขนี้","archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":false,"solution":"1 : 2","imageUrls":[],"tags":["math-puzzle","insight"],"createdAt":{"_seconds":1536044856,"_nanoseconds":176000000}},"964f3ec7-55f0-4936-921d-b591326c2d5d":{"deleted":false,"solution":"24920 ตัว","imageUrls":[],"tags":["small-coding","counting"],"createdAt":{"_seconds":1537551126,"_nanoseconds":495000000},"note":"- **Author:** เพลน\n- choice หลอก\n    - 1024 = ใช้แค่เลขโดด 2, 3, 5, 7 สร้างจำนวน 5 หลักทั้งหมด\n    - 8363 = จำนวนเฉพาะ 5 หลักทั้งหมด\n    - 9592 = จำนวนเฉพาะไม่เกิน 5 หลักทั้งหมด\n    - 10610 = คิดเฉพาะกรณีที่มีจำนวนเฉพาะ 2 พจน์พอดีเท่านั้น\n    - 18973 = คิดเฉพาะกรณ๊ที่มีจำนวนเฉพาะไม่เกิน 2 พจน์เท่านั้น\n    - 27461 = เผลออนุญาตให้มี leading zeros ในบางพจน์\n    - 27885 = เผลอคิดรวมเลขรูปงาม < 10,000\n    - 30648 = เผลออนุญาตให้มี leading zeros ในบางพจน์ และคิดรวมเลขรูปงาม < 10,000\n- verified: [Aof], Eak","updatedAt":{"_seconds":1537776331,"_nanoseconds":32000000},"format":{"choices":true,"coding":false,"ponder":true,"quickfire":false},"round":{"regional":false,"audition":true,"national":false},"statement":"**นิยาม:** จำนวนรูปงาม คือจำนวนเต็มที่สามารถเขียนในรูปของ string concatenation ของสตริงย่อย ๆ อย่างน้อยหนึ่งตัวได้ และสตริงย่อยแต่ละตัวจะต้องเป็นจำนวนเฉพาะที่**ไม่ขึ้นต้น**ด้วย `0` เท่านั้น\n\nยกตัวอย่างเช่น\n- จำนวนเฉพาะทุกตัว (`\"2\"`, `\"3\"`, `\"5\"`, `\"7\"`, `\"11\"`, `\"13\"`, ...) เป็นจำนวนรูปงามโดยปริยาย\n- `\"1012\"` เป็นจำนวนรูปงาม เพราะอยู่ในรูปของ `\"101\" + \"2\"` ซึ่งแต่ละพจน์เป็นจำนวนเฉพาะ\n- `\"5932\"` เป็นจำนวนรูปงาม เพราะอยู่ในรูปของ `\"59\" + \"3\" + \"2\"` ซึ่งแต่ละพจน์เป็นจำนวนเฉพาะ\n- `\"7352\"` เป็นจำนวนรูปงาม เพราะอยู่ในรูปของ `\"7\" + \"3\" + \"5\" + \"2\"` ซึ่งแต่ละพจน์เป็นจำนวนเฉพาะ\n- `\"1149\"` ไม่เป็นจำนวนรูปงามเพราะไม่ว่าจะแบ่งสตริงดังกล่าวอย่างไร ก็ไม่สามารถเขียนในรูปของ string concatenation ของจำนวนเฉพาะได้\n- `\"7007\"` ไม่เป็นจำนวนรูปงามเพราะไม่ว่าจะแบ่งสตริงดังกล่าวอย่างไร ก็ไม่สามารถเขียนในรูปของ string concatenation ของจำนวนเฉพาะที่ไม่ขึ้นต้นด้วย 0 ได้\n\nจงหาว่ามีจำนวนเต็ม 5 หลักที่เป็นจำนวนรูปงามทั้งหมดกี่ตัว?\n\n1. 1024 ตัว\n1. 5388 ตัว\n1. 8363 ตัว\n1. 9592 ตัว\n1. 10610 ตัว\n1. 14289 ตัว\n1. 16934 ตัว\n1. 18973 ตัว\n1. 19247 ตัว\n1. 24920 ตัว\n1. 26007 ตัว\n1. 27461 ตัว\n1. 27885 ตัว\n1. 29124 ตัว\n1. 30648 ตัว\n1. 30974 ตัว\n1. 33743 ตัว\n1. 34580 ตัว\n1. 37851 ตัว\n1. 39770 ตัว","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false}},"98e969e9-df56-4725-99a5-ecd274d09dbf":{"region":{"central":false,"northeast":false,"south":true,"north":false},"deleted":false,"solution":"Answer: \"10\"","imageUrls":[],"tags":["logic-puzzle"],"createdAt":{"_seconds":1533106813,"_nanoseconds":0},"note":"- **Category:** Math & logic puzzle\n- **Author:** เอก\n","updatedAt":{"_seconds":1536575396,"_nanoseconds":955000000},"format":{"quickfire":false,"choices":true,"coding":false,"ponder":true},"round":{"audition":true,"national":false,"regional":false},"statement":" มีไพ่ 8 ใบเรียงอยู่บนโต๊ะดังนี้\n\n    2, 10, 3, 5, King, Ace, 6, 9\n\nเราต้องการเรียงลำดับใหม่จากน้อยไปมาก โดย Ace สามารถเป็นได้ ทั้งไพ่ใบแรกสุด (มีค่าน้อยที่สุด) หรือไพ่ใบสุดท้าย (มีค่ามากที่สุด) ก็ได้\n\nวิธีการย้ายไพ่ ในครั้งแรกเลือกไพ่ 1 ใบ แล้วย้ายไปวางไว้ขวาสุด ครั้งที่ 2 เลือกไพ่ 1 ใบแล้วย้ายไปวางไว้ซ้ายสุด สลับอย่างนี้ไปเรื่อย ๆ\n\nถ้าต้องการเรียงไพ่โดยย้ายไพ่น้อยครั้งที่สุด ครั้งแรกจะย้ายไพ่ใบใด?\n\n1. 2\n2. 10\n3. 3\n4. 5\n5. King\n6. Ace\n7. 6\n8. 9","archived":true},"9e967fe9-c404-4aad-a3d2-34d2b6a6a2b8":{"round":{"regional":false,"audition":true,"national":false},"statement":"KBTG จัดประเพณีวิ่งควายขึ้น มีควายร่วมเข้าแข่งวิ่งจำนวน 66 ตัว แต่ภายในงานมีลู่ให้ควายวิ่งได้แค่รอบละ 6 ตัวเท่านั้น\n\nหากต้องการหาควายตัวที่วิ่งเร็วที่สุด \nจะต้องจัดการแข่งขัน อย่างน้อย กี่รอบ?\n\n***หมายเหตุ:***  ควายวิ่งด้วยอัตราเร็วเท่าเดิมเสมอทุกรอบ\nและไม่สามารถใช้นาฬิกาจับเวลาได้\n","archived":true,"region":{"northeast":false,"south":false,"north":true,"central":false},"deleted":false,"solution":"\"13\"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1536540315,"_nanoseconds":479000000},"note":"reuse quickfire NE มาเป็น audition N","updatedAt":{"_seconds":1536540315,"_nanoseconds":479000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false}},"a048fe7d-5b4c-4dc6-a5cb-587437d64350":{"imageUrls":[],"tags":["logic-puzzle","propose-north-audition"],"createdAt":{"_seconds":1533106825,"_nanoseconds":0},"note":"- **Category:** Math / Logical puzzle\n- **Author:** เอก\n- วิธีคิด\n    1. จาก \"BOAT\" & \"RANT\" จะได้ว่า {B, O} ต้องจับคู่กับ {R, N}\n    2. จาก 1. และ \"NODE\" แปลว่า B|N และ O|R","updatedAt":{"_seconds":1536543116,"_nanoseconds":115000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":true},"round":{"audition":true,"national":false,"regional":false},"statement":"นายเค เขียนตัวอักษร 1 ตัว ลงบนแต่ละหน้าของเหรียญ 4 เหรียญโดยไม่มีตัวอักษรซ้ำกัน จากนั้นสุ่มโยนเหรียญทั้ง 4 เหรียญลงบนโต๊ะ แล้วเรียงเหรียญเป็นคำ ทำอย่างนี้ 3 ครั้ง ได้คำดังนี้ \n“BOAT”, “NODE”, “RANT”\n\nคำใดต่อไปนี้ไม่สามารถสร้างได้จากการเรียงเหรียญชุดนี้?\n\n1. BART\n2. DONE\n3. BORE\n4. NEAR\n5. สามารถเรียงคำได้ทุกข้อข้างบน\n6. ไม่สามารถเรียงได้เลยตามข้อ 1. - 4.","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"3. BORE"},"a33d4d89-1378-4ff9-bf13-5520fed6c8fe":{"imageUrls":[],"tags":["optimization"],"createdAt":{"_seconds":1540837631,"_nanoseconds":255000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1541213575,"_nanoseconds":768000000},"format":{"quickfire":false,"choices":false,"coding":true,"ponder":false},"round":{"audition":false,"national":true,"regional":false},"statement":"# Rotate Sort (Optimization Problem)\n\n### Background\n\nกำหนดให้ operation ชื่อว่า $rotate\\_3way$ รับ input argument อยู่ 3 อย่าง ได้แก่\n\n- อาร์เรย์ $A$ ของจำนวนเต็ม\n- ดัชนี $p$ และ $q$ ภายในอาร์เรย์ $A$ ซึ่ง $1 \\leq p \\leq q \\leq |A|$ &nbsp;(เมื่อ $|A|$ คือความยาวของอาร์เรย์ $A$)\n\nเมื่อเรียกใช้งาน $rotate\\_3way(A, p, q)$ จะได้ output value เป็นอาร์เรย์ที่มีลักษณะเป็นดังนี้\n$$\nrotate\\_3way(A, p, q) = \\left[\\underbrace{A[q+1], A[q+2], \\ldots, A[N]}_\\text{can be empty}, A[p], A[p+1],\\ldots,A[q], \\underbrace{A[1], A[2], \\ldots, A[p-1]}_\\text{can be empty}\\right]\n$$\nยกตัวอย่างเช่น\n- $rotate\\_3way([5,2,1,0],2,3) = [0, 2, 1, 5]$\n- $rotate\\_3way([5,2,1,0],2,2) = [1, 0, 2, 5]$\n- $rotate\\_3way([5,2,1,0],1,2) = [1, 0, 5, 2]$\n- $rotate\\_3way([5,2,1,0],1,4) = [5, 2, 1, 0]$\n\n### Problem Statement\n\nโจทย์ข้อนี้ โปรแกรมของผู้เข้าแข่งขันจะได้รับข้อมูลนำเข้าเป็นอาร์เรย์ $X$ ของจำนวนเต็มที่ไม่เรียงลำดับ กำหนดให้ $N = |X|$ คือความยาวของอาร์เรย์ $X$ &nbsp; เป้าหมายของโปรแกรมของผู้เข้าแข่งขันคือ จะต้องเรียงลำดับจำนวนในอาร์เรย์ $X$ โดยเรียกใช้งาน operation $rotate\\_3way$ เป็นจำนวนครั้งให้ได้น้อยที่สุดเท่าที่ผู้เข้าแข่งขันสามารถทำได้\n\nกล่าวคือ เมื่อโปรแกรมของผู้เข้าแข่งขันได้รับข้อมูลอาร์เรย์ $X$ แล้วจะต้องระบุว่าจะเรียกใช้งาน $rotate\\_3way$ ทั้งสิ้นกี่ครั้ง และในแต่ละครั้ง จะกำหนดค่าดัชนี $p$ และ $q$ เท่าใด ตามลำดับ\n\nสำหรับเกณฑ์การให้คะแนนในข้อนี้ โปรดดูหัวข้อ Submission and Scoring\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: จะมีจำนวนเต็มหนึ่งจำนวน ระบุ $N$ ซึ่งเป็นความยาวของอาร์เรย์ $X$\n- อีก $N$ บรรทัดถัดมา บรรทัดที่ $i+1$ จะระบุจำนวน $X[i]$ ของอาร์เรย์ $X$\n$$\n\\begin{aligned}\n& N \\\\\n& X[1] \\\\\n& X[2] \\\\\n& \\vdots \\\\\n& X[N]\n\\end{aligned}\n$$\n\n#### Output Format\n\n- บรรทัดที่ 1: จะมีจำนวนเต็ม $K$ หนึ่งจำนวน ระบุจำนวนครั้งที่ operation $rotate\\_3way$ จะถูกเรียกใช้งาน\n- อีก $K$ บรรทัดถัดมา บรรทัดที่ $j+1$ จะระบุจำนวนเต็มสองจำนวน $p_j$ และ $q_j$ คั่นด้วยช่องว่ง ซึ่งเป็นดัชนี $p$ และ $q$ ของการเรียกใช้งาน operation $rotate\\_3way$ ครั้งที่ $j$\n\n### Example #1\n\n#### Input\n\n```plaintext\n4\n5\n2\n1\n0\n```\n\n#### Possible Output 1A\n\n```plaintext\n3\n2 2\n2 2\n3 4\n```\n\n#### Possible Output 1B\n\n```plaintext\n4\n2 4\n2 4\n3 3\n3 3\n```\n\nสังเกตว่าลำดับของ operation ที่แสดงในทั้งสองคำตอบข้างต้น สามารถทำให้อาร์เรย์ $X$ เรียงลำดับได้ถูกต้อง แต่คำตอบ 1A ใช้จำนวน operation น้อยกว่าคำตอบ 1B\n\n### Submission and Scoring\n\nสำหรับโจทย์ข้อนี้ พึงทราบว่า test case แต่ละอันจะมีคะแนนเต็ม 18 คะแนน นอกจากนั้น คะแนนรวมตอนท้ายสำหรับโจทย์ข้อนี้จะคิดจากค่าเฉลี่ยของคะแนนจากแต่ละ test case จึงทำให้คะแนนรวมสูงสุดที่เป็นไปได้สำหรับข้อนี้คือ 18 คะแนน เช่นกัน (เศษทศนิยมของคะแนนจะถูกปัดทิ้งให้เหลือทศนิยม 6 ตำแหน่ง)\n\n#### Minimum requirement\n\nสำหรับ test case แต่ละอัน โปรแกรมของผู้เข้าแข่งขันจะถือว่าให้ผลลัพธ์ที่ถูกต้อง ก็ต่อเมื่อ\n\n1. โปรแกรมให้ผลลัพธ์ตรงกับ Program Specification ที่โจทย์กำหนดให้\n2. ผลลัพธ์ของโปรแกรมระบุการเรียกใช้งาน operation $rotate\\_3way$ ที่ทำให้อาร์เรย์ $X$ เรียงลำดับจากน้อยไปมากได้ถูกต้อง\n3. ผลลัพธ์ของโปรแกรมระบุการเรียกใช้งาน operation $rotate\\_3way$ ไม่เกิน $100 \\cdot N$ ครั้ง\n\nหากโปรแกรมของคุณให้ผลลัพธ์ไม่ถูกต้อง จะได้ 0 คะแนนทันที  \n**หมายเหตุ:** web interface จะแสดงผลว่า “Wrong Answer” กรณีที่ผลลัพธ์ถือว่าไม่ถูกต้อง\n\n#### Scoring scheme for correct answers\n\nเมื่อโปรแกรมของคุณให้ผลลัพธ์ที่ถูกต้อง กำหนดให้\n\n- โปรแกรมของคุณใช้ operation $rotate\\_3way$ เป็นจำนวน $K$ ครั้งสำหรับ test case นี้\n- ในบรรดาผู้เข้าแข่งขันทั้งหมด จำนวน operation ที่น้อยที่สุดที่มีผู้เข้าแข่งขันทำได้คือ $K^*$ ครั้ง สำหรับ test case เดียวกัน\n\nแล้วคะแนนของคุณสำหรับ test case อันนี้จะคำนวณจากสูตรดังต่อไปนี้\n$$\n\\begin{cases}\n18 &\\quad\\text{if $K = K^*$} \\\\\n6 + 9 \\cdot\\dfrac{K^*}{K} &\\quad\\text{if $K > K^*$}\n\\end{cases}\n$$\n\nสังเกตว่าเมื่อโปรแกรมให้ผลลัพธ์ที่ถูกต้อง รับประกันว่าจะได้คะแนนอย่างน้อย 6 คะแนนสำหรับ test case นั้น ๆ &nbsp; และกำหนดให้เศษที่เกิดขึ้นจากการหาร จะถูกปัดทิ้งให้เหลือทศนิยม 6 ตำแหน่ง\n\n**หมายเหตุ:** จะไม่มีการแสดงคะแนนที่ได้ ในกรณีที่โปรแกรมทำงานได้ถูกต้อง คะแนนจริงจะถูกคำนวณหลังสิ้นสุดการแข่งขันรอบ coding แล้ว\n\n### Constraints\n\nแต่ละ test case จะมีเงื่อนไขดังต่อไปนี้\n- ความยาวของอาร์เรย์ $X$ จะสอดคล้องกับเงื่อนไข $2 \\leq N \\leq 100$\n- จำนวนที่พบในอาร์เรย์ $X$ จะอยู่ในช่วง $0$ ถึง $1000$ ซึ่งอาจมีบางจำนวนซ้ำกันได้\n- โปรแกรมจะมี time limit อยู่ที่ 1 second (baseline) และใช้ memory ไม่เกิน 128 MB\n    - สำหรับภาษา Java และ Go จะมี time limit เท่ากับ baseline × 2\n    - สำหรับภาษา Python และ JavaScript จะมี time limit เท่ากับ baseline × 4\n","archived":false,"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":false,"solution":""},"a6d5188e-f135-4a85-ab5a-3f9c2e2e0647":{"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"Answer: 12 ตัว ($\\{1, 3, 4, 8, 9, 11, 20, 22, 23, 27, 28, 30\\}$)\n\n- faster solution\n   ```python\n   def largest_no_3tap_subset(candidates):  \n       best_answer = {}  \n       def selections(chosen, remained):  \n           nonlocal best_answer  \n           if not remained: \n               if len(chosen) > len(best_answer):  \n                   best_answer = set(chosen)  \n                   print(sorted(best_answer))  \n               return  \n           n = remained.pop()  \n           selections(chosen, remained)   \n           new_remained = [  \n               r for r in remained  \n               if (2*n-r) not in chosen and (2*r-n) not in chosen  \n               ] \n           chosen.add(n) \n           selections(chosen, new_remained) \n           chosen.remove(n)  \n           remained.append(n)  \n       selections(set(), list(candidates))  \n       return best_answer\n   \n   largest_no_3tap_subset(range(1,31))\n   ```\n- slower solution\n   ```python\n   from itertools import permutations, combinations\n   def exists_3tap(values): \n       return any(p+r == 2*q for p, q, r in permutations(sorted(values), 3))\n   for chosen in combinations(range(1, 31), 12): \n       if not exists_3tap(chosen): \n           print(chosen)\n   ```","imageUrls":[],"tags":["math","small-coding","used"],"createdAt":{"_seconds":1540441113,"_nanoseconds":589000000},"note":"- **Author:** เพลน\n- should be paired with [4 by 4 grid puzzle](/questions/6be4a4f9-0d09-4cb0-a9fc-971bf88f5ecc)","updatedAt":{"_seconds":1541045715,"_nanoseconds":391000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"audition":false,"national":true,"regional":false},"statement":"ชุดของจำนวนชุดหนึ่งจะมี **“3-term arithmetic progression”** หากมีจำนวน 3 จำนวนกลุ่มหนึ่งในชุดดังกล่าวที่เรียงเป็นลำดับเลขคณิต\n- เช่น ชุดของจำนวน $\\{1, 2, 4, 5 , 7, 11\\}$ จะมี **3-term arithmetic progression** เพราะมีจำนวน $1, 4, 7$ เป็นลำดับเลขคณิต\n- ส่วนชุดของจำนวน $\\{1, 2, 5, 7, 10, 11\\}$ นั้นไม่มี **3-term arithmetic progression** อยู่เลย\n\nจงหาชุดของจำนวนเต็มจากจำนวนเต็ม 1 ถึง 30 ที่มีจำนวนสมาชิกมากที่สุด และไม่มี **3-term arithmetic progression** อยู่เลย","archived":false},"ae696ad0-57e5-412f-a328-b55d3ac3e64b":{"updatedAt":{"_seconds":1541219505,"_nanoseconds":501000000},"format":{"choices":false,"coding":true,"ponder":false,"quickfire":false},"round":{"regional":false,"audition":false,"national":true},"statement":"# Intercept Meteor\n\n### Background\n\nองค์การบริหารการบินและอวกาศแห่งโลกได้ตรวจพบอุกกาบาตขนาดใหญ่ที่กำลังพุ่งชนโลก จึงได้เตรียมแผนการรับมือโดยการส่งนักขุดเจาะฝีมือดีขึ้นไปวางระเบิดที่แกนของอุกกาบาตเพื่อระเบิดอุกกาบาตออกเป็นชิ้นเล็กๆก่อนจะตกลงสู่พื้นโลก จากการคาดการณ์ เศษอุกกาบาตส่วนใหญ่จะตกลงสู่ทะเล มีเพียงเกาะโคะเกาะเดียวเท่านั้นที่มีคนอาศัยอยู่และได้รับผลกระทบจากเศษอุกกาบาต \n\nเพื่อปกป้องเกาะโคะที่มีอารยธรรมโบราณอันมีคุณค่า องค์การบริหารการบินและอวกาศแห่งโลกจึงได้ติดตั้งฐานยิงจรวดมิสไซล์ไว้ที่เกาะโคะเพื่อยิงเศษอุกกาบาตก่อนจะตกถึงพื้น ข้อเสียของการใช้จรวดมิสไซล์คือ การยิงเศษอุกกาบาตแต่ละครั้งจะสร้างมลพิษสู่ชั้นบรรยากาศเป็นจำนวนมาก องค์การบริหารการบินและอวกาศแห่งโลกจึงต้องการยิงเศษอุกกาบาตให้น้อยที่สุด โดยจะยิงเฉพาะเศษอุกกาบาตที่มีจุดตกอยู่บนพื้นเกาะโคะเท่านั้น \n\nความพิเศษของเกาะโคะคือมีลักษณะเป็น convex polygon (เป็นรูปหลายเหลี่ยม และ ทุกคู่จุดใดๆบนเกาะสามารถเดินเป็นเส้นตรงถึงกันได้โดยไม่มีทะเลมาขวาง)\n\n### Problem Statement\n\nองค์การบริหารการบินและอวกาศแห่งโลกต้องการให้คุณเขียนโปรแกรมช่วยคำนวนว่าจากจุดตกของเศษอุกกาบาตแต่ละลูก มีลูกไหนตกบนพื้นเกาะโคะ, ตกตรงขอบเกาะโคะ และ ตกนอกเกาะโคะบ้าง\n\nให้พิจารณาเฉพาะ**จุด**ตกเท่านั้น ไม่ต้องสนใจขนาดของเศษอุกกาบาต\n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดแรก เป็นจำนวนเต็มบวก $N$ แทนจำนวนมุมของ convex polygon $C$ ที่แสดงขอบเขตของเกาะโคะ\n- $N$ บรรทัดต่อมา แต่ละบรรทัดเป็นจำนวนเต็ม $x$ $y$ คั่นด้วยช่องว่าง แทนพิกัดจุดมุมแต่ละจุดของ C เรียงตามเข็มนาฬิกา โดยเริ่มจากจุดที่มีค่า $x$ น้อยที่สุด หากมีจุดที่มีค่า $x$ น้อยที่สุดมากกว่าหนึ่งจุดจะเริ่มต้นจากจุดที่มีค่า $y$ น้อยที่สุด (รับประกันว่าไม่มีพิกัดใดซ้ำกันเลย และ ไม่มี 3 จุดมุมใดๆที่เรียงต่อเนื่องกันเป็นเส้นตรง)\n- บรรทัดต่อมา เป็นจำนวนเต็มบวก $K$ แทนจำนวนเศษอุกกาบาตที่ต้องการตรวจสอบ\n- $K$ บรรทัดต่อมา แต่ละบรรทัดเป็นจำนวนเต็ม $x$ $y$ คั่นด้วยช่องว่าง แทนพิกัดของจุดตกของเศษอุกกาบาตที่ต้องการตรวจสอบแต่ละลูก\n\n#### Output Format\n\nสำหรับเศษอุกกาบาตที่ต้องการตรวจสอบแต่ละลูก ให้แสดงข้อความในหนึ่งบรรทัด โดยข้อความจะเป็น \n- \"`Inside`\" หากจุดตกอยู่ภายในเกาะโคะ หรือ\n- \"`Outside`\" หากจุดตกอยู่ภายนอกเกาะโคะ หรือ \n- \"`On the boundary`\" หากจุดตกอยู่บนเส้นรอบรูปของเกาะโคะพอดี (อยู่บนขอบหรืออยู่ที่จุดมุมก็ได้)\n\n### Example #1\n\n#### Input\n\n```plaintext\n7\n-5 1\n0 6\n6 10\n10 11\n10 9\n5 4\n0 2\n6\n0 5\n-4 9\n5 4\n10 10\n10 3\n5 5\n```\n\n#### Output\n\n```plaintext\nInside\nOutside\nOn the boundary\nOn the boundary\nOutside\nInside\n```\n\nจากตัวอย่างที่ 1 จะได้ convex polygon C ดังภาพ\n\n![][meteor_ex1]\n\nมี 6 คำถาม ได้แก่\n- คำถามแรก จุด (0, 5) อยู่ภายใน C ตอบว่า \"`Inside`\"\n- คำถามที่สอง จุด (-4, 9) อยู่ภายนอก C ตอบว่า \"`Outside`\"\n- คำถามที่สาม จุด (5, 4) เป็นจุดมุม ตอบว่า \"`On the boundary`\"\n- คำถามที่สี่ จุด (10, 10) อยู่บนขอบ ตอบว่า \"`On the boundary`\"\n- คำถามที่ห้า จุด (10, 3) อยู่ภายนอก C ตอบว่า \"`Outside`\"\n- คำถามที่หก จุด (5, 5) อยู่ภายใน C ตอบว่า \"`Inside`\"\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า จำนวนมุมของ convex polygon ที่แสดงขอบเขตของเกาะโคะสอดคล้องกับเงื่อนไข $3 \\leq N \\leq 1,\\!000$ และจำนวนเศษอุกกาบาตที่ต้องการตรวจสอบสอดคล้องกับเงื่อนไข $1 \\leq K \\leq 1,\\!000$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า จำนวนมุมของ convex polygon ที่แสดงขอบเขตของเกาะโคะสอดคล้องกับเงื่อนไข $3 \\leq N \\leq 10^5$ และจำนวนเศษอุกกาบาตที่ต้องการตรวจสอบสอดคล้องกับเงื่อนไข $1 \\leq K \\leq 10^5$\n- สำหรับทุก test cases จะมีเงื่อนไขว่า พิกัดจุดมุมของ convex polygon ที่แสดงขอบเขตของเกาะโคะ และ พิกัดจุดตกของเศษอุกกาบาตสอดคล้องกับเงื่อนไข $-10^9 \\leq x,y \\leq 10^9$\n\n\n- สำหรับแต่ละ test case โปรแกรมจะต้องใช้เวลาไม่เกิน 1 second (baseline) และใช้ memory ไม่เกิน 128 MB\n   - สำหรับภาษา Java และ Go จะมี time limit เท่ากับ baseline × 2\n   - สำหรับภาษา Python และ JavaScript จะมี time limit เท่ากับ baseline × 4\n\n[meteor_ex1]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fae696ad0-57e5-412f-a328-b55d3ac3e64b%2Fmeteor_ex1.png?alt=media&token=ba29b617-b32a-41a7-86ec-019b06354dd6\n\n","archived":false,"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fae696ad0-57e5-412f-a328-b55d3ac3e64b%2Fmeteor_ex1.png?alt=media&token=ba29b617-b32a-41a7-86ec-019b06354dd6"],"tags":["used"],"createdAt":{"_seconds":1541173439,"_nanoseconds":496000000},"note":""},"b2bdb2ea-3ea1-4c33-9b50-5eb9d72f7011":{"archived":false,"region":{"south":false,"north":true,"central":true,"northeast":true},"deleted":true,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106852,"_nanoseconds":0},"note":"- **Author:** เอก","updatedAt":{"_seconds":1534936934,"_nanoseconds":391000000},"format":{"quickfire":false,"choices":false,"coding":true,"ponder":false},"round":{"audition":false,"national":false,"regional":true},"statement":"ภัตตาคารแห่งหนึ่งมีโต๊ะอยู่ N โต๊ะ และมีลูกค้าเข้ามาพร้อมกัน M กลุ่ม ให้หาวิธีในการจัดที่นั่งให้ลูกค้า โดยทำให้ยังเหลือที่นั่งไว้รองรับลูกค้าใหม่ได้จำนวนมากที่สุด\n\nกำหนดให้ Array S แสดงจำนวนที่นั่งของแต่ละโต๊ะ ทั้งหมด N โต๊ะ และ Array C แสดงจำนวนลูกค้าในแต่ละกลุ่ม ทั้งหมด M กลุ่ม \n\nให้เขียนโปรแกรมที่ return จำนวนลูกค้าใหม่สูงสุดที่ภัตตาคารจะรอบรับได้หลังจากจัดที่นั่งให้ลูกค้าทั้ง M กลุ่มตามวิธีดังกล่าวเรียบร้อยแล้ว \n\nถ้าภัตตาคารไม่สามารถรอบรับลูกค้าทั้ง M กลุ่มได้ ให้ return -1\n\n**เงื่อนไขการจัดที่นั่ง**\n-\tโต๊ะทั้งหมดเป็นโต๊ะนั่งเรียงหน้ากระดานแถวเดียว\n-\tลูกค้าหลายกลุ่มสามารถนั่งรวมกันได้ในโต๊ะเดียว แต่จะต้องคั่นลูกค้าแต่ละกลุ่มด้วยที่นั่งว่าง 1 ที่เสมอ\n-\tลูกค้ากลุ่มเดียวกันจะไม่ยอมแยกนั่งหลายโต๊ะ\n\n**Condition**\n- $1 \\leq S[i] \\leq 10,000,000$ เมื่อ $0 \\leq i < N \\leq 10,000,000$ (สังเกตุว่า N > 0 เสมอ)\n- $1 \\leq C[j] \\leq 10,000,000$ เมื่อ $0 \\leq j < M \\leq 10,000,000$ (สังเกตุว่า M > 0 เสมอ)\n\n**Input**\n````\nN M\nS[0] S[1] … S[N-1]\nC[0] C[1] … C[M-1]\n````\n**ตัวอย่างที่ 1**\n\nInput: \n````\n5 4\n9 2 4 6 2\n1 5 5 1\n````\nOutput: 8\n\nจัดให้ 3 กลุ่มที่มี 5 คน, 1 คน และ 1 คน นั่งโต๊ะขนาด 9 ที่นั่งได้พอดีไม่มีที่เหลือ กลุ่มสุดท้าย 5 คนนั่งโต๊ะขนาด 6 ที่นั่งโดยไม่มีที่เหลือ (เพราะไม่สามารถจัดลูกค้าใหม่มานั่งได้ตามกฎการจัดที่นั่ง) ที่นั่งที่เหลือคือโต๊ะขนาด 2,4,2 ที่นั่ง นั่นคือรองรับได้อีกสูงสุด 8 คน ทั้งนี้อาจจะจัดวิธีอื่นได้อีกเช่นกัน แต่ก็ยังได้ผลลัพธ์ที่สูงสุดไม่เกิน 8 \n\n**ตัวอย่างที่ 2**\n\nInput: \n````\n4 5\n2 4 3 6\n4 1 2 5 2\n````\nOutput: -1\n\nจัดที่นั่งไม่ได้"},"b38816d8-5b70-473e-945a-b638b6e5114e":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":true,"solution":"$O(n)$","imageUrls":[],"tags":["big-o-analysis"],"createdAt":{"_seconds":1533106830,"_nanoseconds":0},"note":"- **Category:** Time-complexity analysis\n- **Author:** คูน\n- [เอก] สงสัยว่าจะ infinite loop มั้ย เพราะ foo(i) i น่าจะไม่มีวันมีค่าน้อยกว่า 1\n- [เพลน] superceded by https://kbtg-techjam-code-questions.firebaseapp.com/questions/d121de7b-5655-481f-afcd-c1f3ab7068fb","updatedAt":{"_seconds":1537547713,"_nanoseconds":544000000},"format":{"choices":true,"coding":false,"ponder":true,"quickfire":false},"round":{"regional":false,"audition":true,"national":false},"statement":"จงคำนวณหา Time complexity ของโปรแกรมต่อไปนี้\n\n```pseudocode\nfunction: foo\ninput: integer n\noutput: an integer\n\n    if n ≤ 1 then return 0\n    else\n        i := random an integer between 1 and n-1 (inclusive)\n        return foo(i)  + foo(n - 1 - i)\n    end\nend\n```\n\n1. $O(1)$\n2. $O(\\log n)$\n3. $O(n)$\n4. $O(n \\log n)$\n5. $O(n^2)$","archived":false},"b4b72fe4-cdd2-4753-b37b-e1726df83569":{"note":"- Verified by เอก","updatedAt":{"_seconds":1536575996,"_nanoseconds":435000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"regional":true,"audition":false,"national":false},"statement":"นางอรุณานั่งเขียนโปรแกรมหนึ่ง ตั้งแต่เวลา \n16:00 น. ถึง 18:45 น. \n\nอยากทราบว่าในช่วงเวลาดังกล่าวจะมีเวลาที่เข็มสั้น และเข็มยาวของนาฬิกา ตั้งฉากกันพอดี ทั้งหมดกี่ครั้ง ?\n\n\n*หมายเหตุ*: กำหนดให้เข็มสั้น และเข็มยาว ขยับอย่างต่อเนื่องตลอดเวลา\n","archived":true,"region":{"northeast":true,"south":false,"north":false,"central":false},"deleted":false,"solution":"5","imageUrls":[],"tags":["counting","edge-cases"],"createdAt":{"_seconds":1536055514,"_nanoseconds":924000000}},"b693ea2f-a522-42f7-ae4e-ab96d2aab5d2":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"71 ตารางหน่วย","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-1a.png?alt=media&token=4497c7e7-f367-47c0-a5ca-266a883527f3","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-1b.png?alt=media&token=da59f736-12a1-43b9-876e-3509f4d691cc","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-2.png?alt=media&token=c84005b2-a716-4abe-8b0b-8d000d0ea792","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-1a-inverted.png?alt=media&token=cafa77b3-3a2a-428d-a2cd-5b12d8008984","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-1b-inverted.png?alt=media&token=d862cdd6-7d0b-48fc-aead-b39a3b902f78","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-2-inverted.png?alt=media&token=49388bbc-2a44-4143-af04-7e6f765aa0b3"],"tags":["counting","insight","geometry","30-sec"],"createdAt":{"_seconds":1537898870,"_nanoseconds":269000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1538644629,"_nanoseconds":632000000},"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false},"round":{"national":false,"regional":true,"audition":false},"statement":"![][d1a] &emsp; ![][d1b]\n\nจาก**ตัวอย่างรูป**ทางซ้ายมือ มีโครงสร้างเรขาคณิตที่เรียงตัวเป็นสามเหลี่ยมด้านเท่าย่อย ๆ หลายรูปประกอบกัน โดยที่สามเหลี่ยมย่อยแต่ละรูปมีพื้นที่รูปละ 1 ตารางหน่วย\n\nเราจะพยายามลากเส้นภายในโครงสร้างที่กำหนดให้ข้างต้น โดยมีเงื่อนไขว่า\n- เราจะต้องลากเส้นเพียงเส้นเดียว ผ่านจุดยอดให้ครบทุกจุด แล้วกลับมายังจุดเริ่มต้น กลายเป็นรูปปิด\n- จุดยอดแต่ละจุดจะต้องถูกเยือน 1 ครั้งพอดี ไม่ขาด-ไม่เกิน\n- เส้นทุกเส้นที่ลากผ่านจะต้องมีเค้าโครงเดิมจากเส้นสีเทาที่กำหนดให้จากรูปดั้งเดิม\n- รูปปิดที่เกิดขึ้นจะต้องมีพื้นที่ภายในมากที่สุดเท่าที่เป็นไปได้\n\nรูปตัวอย่างทางขวามือข้างต้น แสดงรูปปิดด้วยเส้นสีแดงที่สอดคล้องกับเงื่อนไขทั้งหมด ซึ่งจะได้พื้นที่ภายในรวม 8 ตารางหน่วย (อาจมีวิธีลากเส้นวิธีอื่น ๆ ที่ทำให้ได้พื้นที่ขนาดเท่ากัน)\n\nจงหาว่าในรูปต่อไปนี้ เราจะลากเส้นสร้างรูปปิดตามเงื่อนไขเดียวกันให้ได้พื้นที่ภายในมากที่สุด จะได้พื้นที่เท่าใด?\n\n![][d2]\n\n\n[d1a]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-1a.png?alt=media&token=4497c7e7-f367-47c0-a5ca-266a883527f3\n[d1b]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-1b.png?alt=media&token=da59f736-12a1-43b9-876e-3509f4d691cc\n[d2]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fb693ea2f-a522-42f7-ae4e-ab96d2aab5d2%2Fhamiltonian-2.png?alt=media&token=c84005b2-a716-4abe-8b0b-8d000d0ea792","archived":true},"b74852c9-ff92-413f-893d-5ceab44ba365":{"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"regional":false,"audition":false,"national":true},"statement":"จงหาว่า list ของจำนวนเฉพาะที่เรียงติดกันที่ยาวที่สุด ที่ให้ผลรวมเท่ากับ 1,000,000 พอดี มีความยาวเท่าใด? จำนวนเฉพาะตัวแรกและตัวสุดท้ายของ list ดังกล่าวคืออะไร?","archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false},"deleted":false,"solution":"- **Length of list:** 174\n- **First prime:** 4999\n- **Last prime:** 6491\n\n```python\ndef consecutive_prime_sum(target_sum): \n    from itertools import count \n    from bisect import bisect_left \n    primes = [] \n    prefix_sums = [0] \n    acc = 0 \n    for n in count(2): \n        if any(n % p == 0 for p in primes): \n            continue \n        primes.append(n) \n        acc += n \n        idx = bisect_left(prefix_sums, acc-target_sum) \n        if prefix_sums[idx] == acc-target_sum: \n            return primes[idx:] \n        prefix_sums.append(acc)      \n```","imageUrls":[],"tags":["small-coding","data-structure","used"],"createdAt":{"_seconds":1540381042,"_nanoseconds":141000000},"note":"- **Author:** เพลน\n- should be paired with [tetris boundary problem](/questions/04fb423b-0612-40d7-86d5-01b8aec03b0c)","updatedAt":{"_seconds":1541045707,"_nanoseconds":719000000}},"c16a5890-9bce-4624-91e7-54ee805e270f":{"updatedAt":{"_seconds":1535383593,"_nanoseconds":83000000},"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"audition":true,"national":false,"regional":false},"statement":"โปรดพิจารณาโปรแกรมต่อไปนี้ที่เขียนขึ้นเพื่อนับจำนวนคู่ในช่วงตั้งแต่จำนวนเต็ม `m` ถึงจำนวนเต็ม `n` (สมมติว่ากำหนดให้ `m ≤ n`) \n โปรแกรมนี้จะให้ผลลัพธ์ที่ถูกต้องภายใต้เงื่อนไขใด\n\n\n```pseudocode\ninput: integers m and n such that m ≤ n\noutput: an integer\n\ncount := 0\nfor i := m; i ≤ n; i += 2\n    count := count + 1\nend\nreturn count\n```\n\n1. โปรแกรมถูกต้องสำหรับทุกจำนวนเต็ม `m` และ `n`\n2. โปรแกรมผิดเมื่อ `m` และ `n` เป็นจำนวนคู่\n3. โปรแกรมผิดเมื่อ `m` เป็นจำนวนคี่ `n` เป็นจำนวนคู่\n4. โปรแกรมผิดเมื่อ `m` เป็นจำนวนคู่ `n` เป็นจำนวนคี่\n5. โปรแกรมผิดเมื่อ `m` และ `n` เป็นจำนวนคี่","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false},"deleted":false,"solution":"5. โปรแกรมผิดเมื่อ `m` และ `n` เป็นจำนวนคี่","imageUrls":[],"tags":["code-peeking"],"createdAt":{"_seconds":1533106802,"_nanoseconds":0},"note":"- **Author:** คูน\n- **Revised:** 27/08 เวลา 22:02"},"c3e897d6-4e25-4565-9676-b98cb94c3cf1":{"updatedAt":{"_seconds":1536572767,"_nanoseconds":714000000},"format":{"ponder":true,"quickfire":false,"choices":true,"coding":false},"round":{"audition":true,"national":false,"regional":false},"statement":"ในเลขตั้งแต่ 1 ถึง 1000 ให้หาว่ามีเลขจำนวนกี่ตัว ? \nที่ผลรวมเลขโดดไม่มีเลข 1 อยู่ในผลรวมนั้น\n\nตัวอย่าง \n- เลข 123 ได้ผลรวมคือ 1+2+3=6 ไม่มีเลข 1 อยู่ใน 6\n- เลข 67 ได้ผลรวมคือ 6+7=13 มีเลข 1 อยู่ใน 13\n\nChoices\n\n0. 78\n1. 92\n2. 113\n3. 160\n4. 230\n5. 250\n6. 255\n7. 308\n8. 556\n9. 652\n10. 667\n11. 728\n12. 883\n13. 943","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"\"308\"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1536544422,"_nanoseconds":536000000},"note":"reuse regional S to Audition N"},"c60c712b-7e6e-4fc9-ba1c-1b9169bd39ec":{"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"national":false,"regional":true,"audition":false},"statement":"- ให้แบ่งกลุ่มของจำนวนเต็ม $1, 2, 3, \\ldots, 12$ ออกเป็นสองกลุ่ม โดยแต่ละกลุ่มจะต้องมีจำนวนเต็มอย่างน้อยหนึ่งจำนวน\n- จากนั้นให้หาผลคูณของจำนวนในแต่ละกลุ่ม\n- ผลต่างของผลคูณทั้งจากทั้งสองกลุ่ม มีค่าต่างกันน้อยที่สุดเท่าใด?","archived":true,"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"Answer: 576\n\n```python\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import mul\n\ndef min_diff_bipartition_product(data):\n    big_product = reduce(mul, data)\n    products = (\n        reduce(mul, grp)\n        for size in range(1, 1+len(data)//2)\n        for grp in combinations(data, size)\n        )\n    return min(\n        abs(p - big_product // p)\n        for p in products\n        )\n```","imageUrls":[],"tags":["optimization","combinatorics","small-coding"],"createdAt":{"_seconds":1538392836,"_nanoseconds":653000000},"note":"- **Author:** เพลน\n- **Verified** Aof","updatedAt":{"_seconds":1538550537,"_nanoseconds":138000000}},"c78c8708-bd4a-48ee-a4ca-83e645b9dcc2":{"round":{"national":true,"regional":false,"audition":false},"statement":"มีจำนวนเต็มขนาดใหญ่ $X$ อยู่จำนวนหนึ่ง ซึ่งในจำนวนเต็ม 1-30 นั้น มีถึง 28 จำนวนที่หารจำนวน $X$ นี้ลงตัว และอีก 2 จำนวนที่หาร $X$ ไม่ลงตัวนั้น เป็นจำนวนเต็มที่อยู่ติดกันพอดี\n\nอยากทราบว่า จำนวนเต็ม 2 จำนวนดังกล่าวที่หาร $X$ ไม่ลงตัว คือจำนวนเต็มใดบ้าง?","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"16 & 17","imageUrls":[],"tags":["math-puzzle","30-sec"],"createdAt":{"_seconds":1538240215,"_nanoseconds":58000000},"note":"- **Author:** พี่เอก\n- Verified by Ju ใช้ 3 นาที (เดาคำตอบ)\n- Verified by Ball ใช้ 20 วินาที","updatedAt":{"_seconds":1539080684,"_nanoseconds":222000000},"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false}},"ca059b3d-11b9-4648-a628-9cf8221b2b01":{"deleted":false,"solution":"Answer: ธนบัตรชนิดราคา 10,012 บาท\n- **naïve approach:** เขียน greedy solution & dynamic programming (opt) solution และไล่หาเคสที่ใส่เงินตรามูลค่าสูงสุดที่ทำให้จำนวนเงินตรา greedy > opt สำหรับบาง target change\n- **better approach:** ใช้เงื่อนไขพิเศษ\n   ```python\n   from bisect import bisect\n   def greedy(target, denominations=(1, 2, 5, 10, 20, 50, 100, 500, 1000)):\n       tally = 0\n       for coin in sorted(denominations, reverse=True):\n           tally += target // coin\n           target %= coin\n       return tally\n   \n   # based on condition in paper\n   breaker = []\n   for coin in range(1001, 50000):\n       m = (1000 - 1 + coin) // 1000  # only need to check up to m = 11\n       target = m * 1000\n       if greedy(target, (1, 2, 5, 10, 20, 50, 100, 500, 1000, coin)) > m:\n           breaker.append(coin)\n           \n   print(max(breaker))\n   ```\n   เงื่อนไขเป็นไปตามที่พบในเปเปอร์ https://faculty.math.illinois.edu/~west/regs/coinset.html และ http://www.cse.yorku.ca/~andy/courses/3101/lecture-notes/CoinChange.pdf","imageUrls":[],"tags":["greedy-algorithm","dynamic-programming","used"],"createdAt":{"_seconds":1541011357,"_nanoseconds":624000000},"note":"- **Author:** เพลน (adapted from a classic problem in algorithms)\n- should be paired with [tsp 4x3 problem](/questions/786febe4-1d25-4040-9083-2d2a4af29d52)","updatedAt":{"_seconds":1541150672,"_nanoseconds":55000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"regional":false,"audition":false,"national":true},"statement":"ปัจจุบันในประเทศไทย เรานิยมใช้เหรียญหรือธนบัตรชนิดราคา 1 บาท, 2 บาท, 5 บาท, 10 บาท, 20 บาท, 50 บาท, 100 บาท, 500 บาท, และ 1000 บาท ตามลำดับ\n\nเป็นที่น่าสังเกตว่า หากเรามียอดหนี้ที่ต้องชำระ $d$ บาท ซึ่งต้องการใช้เหรียญหรือธนบัตร (รวมเรียกว่า “เงินตรา”) เป็นจำนวน**น้อยที่สุด** เราสามารถใช้ **Greedy Algorithm** เพื่อตอบคำถามนี้ได้ ไม่ว่ายอดหนี้ $d$ จะมีมูลค่าเท่าใดก็ตาม (“Greedy is optimal”) &nbsp; กล่าวคือ “เราจะเลือกเหรียญหรือธนบัตรที่มีมูลค่ามากที่สุดที่เป็นไปได้ที่ไม่เกินยอดหนี้ นำไปหักจากยอดหนี้ ทำเช่นนี้ไปเรื่อย ๆ จนกว่ายอดหนี้จะลดเหลือ 0 บาท”\n- ยกตัวอย่างเช่น หากเราต้องการชำระ $d = 94$ บาท เราสามารถจ่ายด้วยเหรียญหรือธนบัตรเป็นมูลค่า $50+20+20+2+2$ ซึ่งคิดเป็นเงินตราทั้งหมด 5 หน่วย\n\nอย่างไรก็ดี _สมมติ_ว่าวันหนึ่ง ประเทศไทยจะเพิ่มเหรียญหรือธนบัตรชนิดราคาใหม่ 1 ชนิดราคาเข้ามาในระบบ จะพบว่า\n- ถ้าสมมติว่าเราเพิ่มเหรียญชนิดราคา 4 บาทเข้ามาในระบบ แล้ว Greedy algorithm จะไม่ optimal ในบางกรณีอีกต่อไป  \n   (เช่นการชำระเงิน 8 บาท ซึ่ง Greedy algorithm จะใช้ $5+2+1$ บาท แทนการใช้วิธี $4+4$ บาท)\n- แต่ถ้าเราเพิ่มเหรียญชนิดราคา 3 บาท Greedy algorithm จะยังคง optimal อยู่ ไม่ว่ายอดหนี้จะมีมูลค่าเท่าใดก็ตาม\n\n**คำถาม:** จงหาเงินตราที่มีชนิดราคาสูงที่สุด ที่เมื่อใส่เข้ามาในระบบแล้ว จะทำให้ Greedy Algorithm ให้ผลลัพธ์ที่ไม่ optimal ในบางกรณี","archived":false,"region":{"central":false,"northeast":false,"south":false,"north":false}},"ccd2916f-4b00-4f83-8f46-f3540b446b14":{"createdAt":{"_seconds":1533106805,"_nanoseconds":0},"note":"- **Category:** Data structure\n- **Author:** คูน","updatedAt":{"_seconds":1536575196,"_nanoseconds":603000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"audition":true,"national":false,"regional":false},"statement":"ข้อใดถูกต้องเกี่ยวกับการสร้าง stack โดยใช้ linked list?\n\n1. ถ้าสร้างฟังก์ชัน Push โดยเพิ่ม Node เข้าไปที่ Head แล้วต้องลบ Node ที่ Tail ในฟังก์ชัน Pop\n2. ถ้าสร้างฟังก์ชัน Push โดยเพิ่ม Node เข้าไปที่ Tail แล้วต้องลบ Node ที่ Head ในฟังก์ชัน Pop\n3. ถูกทั้ง A และ B\n4. ผิดทั้ง A และ B","archived":true,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"4. ผิดทั้ง A และ B","imageUrls":[],"tags":["data-structure"]},"cd2aa13d-8d6e-4510-b513-1eee2b2eb658":{"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"national":false,"regional":true,"audition":false},"statement":"## เวอร์ชันภาษาไทย\n\nนางอรุณานั่งเขียนโปรแกรมหนึ่ง ตั้งแต่เวลา 16:15 น. ถึง 19:00 น. \n\nอยากทราบว่าในช่วงเวลาดังกล่าวจะมีเวลาที่เข็มสั้น และเข็มยาวของนาฬิกา ตั้งฉากกันพอดี ทั้งหมดกี่ครั้ง?\n\n**หมายเหตุ:** กำหนดให้เข็มสั้น และเข็มยาว ขยับอย่างต่อเนื่องตลอดเวลา แทนที่จะขยับทุกวินาที\n\n## English Version\n\nMrs. Aruna was sitting at her desk writing code, from 16:15 until 19:00. \n\nHow many occurrences during that time does a clock make a right angle between an hour hand and a minute hand?\n\n**N.B.** Assume that each hand moves continuously rather than ticking each second. ","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"5","imageUrls":[],"tags":["20-sec","logic-puzzle"],"createdAt":{"_seconds":1537173930,"_nanoseconds":994000000},"note":"- 20 sec","updatedAt":{"_seconds":1537257231,"_nanoseconds":151000000}},"cd8a656f-963d-4f1e-b542-f4a3ae47ba73":{"deleted":false,"solution":"Answer: \"111\"","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1535292274,"_nanoseconds":1000000},"note":"- Recycled","updatedAt":{"_seconds":1536575577,"_nanoseconds":487000000},"format":{"choices":true,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":true,"national":false,"regional":false},"statement":"ธนาคารกสิกรสาขา TechJam 2018 มี 600 ชั้น ติดเลขไว้ตั้งแต่ 1 ถึง 600 \n\nเจ้าหน้าที่ต้องเตรียมเลขโดด 0 ถึง 9 ไว้เพื่อนำมาติดตามชั้นต่างๆ  เช่นชั้น 10 ต้องเตรียมเลข 1 กับ 0 อย่างละ 1 ตัว\n\nอยากทราบว่าเจ้าหน้าที่ต้องเตรียมเลข 0 กี่ตัว เพื่อนำมาติดให้ครบ 600 ชั้น ?\n\n1. 20\n3. 40\n4. 66\n5. 90\n6. 100\n7. 109\n8. 111\n9. 121\n10. 128\n11. 150\n12. 199\n13. 200\n14. 201\n15. 270\n16. 300\n17. 330\n18. 365\n19. 400\n20. 472","archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true}},"cdfe98ab-ceb5-4b55-9ea0-930da29eb156":{"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"280","imageUrls":[],"tags":[],"createdAt":{"_seconds":1537175022,"_nanoseconds":691000000},"note":"Verify by K.Eak, Aof","updatedAt":{"_seconds":1537290588,"_nanoseconds":785000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"## เวอร์ชันภาษาไทย\n\nกำหนดให้มีนาฬิกา Digital อยู่ตัวหนึ่ง มีรูปแบบการแสดงผลเป็น HH:MM:SS โดยเป็นเวลา ชั่วโมง:นาที:วินาที (แบบ 24 ชั่วโมง)\n\nและกำหนดให้ \"เลขสวย\" คือเวลาที่แสดงผลด้วยตัวเลข ___ไม่เกินสองตัว___ เท่านั้น เช่น\n\n- 13:31:11 เป็นเลขสวย เนื่องจากแสดงผลได้ด้วยเลข 1 และ 3 เพียงสองตัวเท่านั้น\n- 23:00:00 ไม่เป็นเลขสวย เนื่องจากต้องใช้ตัวเลข 3 ตัวในการแสดงผล\n- 11:11:11 เป็นเลขสวย เพราะใช้ตัวเลขเดียว (ยังไม่เกินสองตัว)\n\nจงหาว่า ในช่วงเวลาตั้งแต่ 01:30:00 ถึง 21:00:00 มีเลขสวยทั้งหมดกี่ตัว?\n\n## English Version\n\nSuppose that there is a 24-hour digital clock whose display has the format HH:MM:SS (corresponding to the hour, the minute, and the second, respectively).\n\nA particular time will be considered **beautiful** if its display on this clock contains at most two distinct digits. For example,\n\n- 13:31:11 is beautiful because it consists of only two distinct digits, specifically 1 and 3\n- 23:00:00 is _not_ beautiful because there are three distinct digits on display\n- 11:11:11 is beautiful since it contains one distinct digit (not yet exceeding two)\n\nHow many occurrences of time between 01:30:00 and 21:00:00 are considered beautiful?","archived":true},"cf440842-c946-4233-a691-10a12f017e25":{"note":"","updatedAt":{"_seconds":1533106850,"_nanoseconds":0},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"national":false,"regional":true,"audition":false},"statement":"### Place Holder : หาวิธีเดินจากบ้านไปโรงเรียน บนตาราง 5x5 โดยมีสี่แยกหนึ่งซ่อมถนนอยู่ ==> รอทำรูป","archived":false,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":true,"solution":"132","imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106850,"_nanoseconds":0}},"d121de7b-5655-481f-afcd-c1f3ab7068fb":{"updatedAt":{"_seconds":1537779869,"_nanoseconds":141000000},"format":{"ponder":true,"quickfire":false,"choices":true,"coding":false},"round":{"national":false,"regional":false,"audition":true},"statement":"([มีอีกข้อที่คล้ายกัน แต่อาจจะซับซ้อนเกินไป](/questions/195117f6-aefb-464c-9b5d-f0388d588ab4))\n\nจงพิจารณาโปรแกรมดังต่อไปนี้แล้ววิเคราะห์หา time complexity ของฟังก์ชัน `foo` โดยกำหนดให้ input argument ของฟังก์ชันดังกล่าวคือ Array ของจำนวนเต็ม $N$ ตัว (**หมายเหตุ:** เลือกตอบข้อที่ให้ข้อมูลถูกต้องมากที่สุด และเป็น tightest bound เท่าที่เป็นไปได้)\n\n```pseudocode\nfunction foo(A):\n    n := A.length()\n    bar(A, 0, n-1)\nend\n\nfunction bar(A, lo, hi):\n    if hi - lo ≤ 31 then:\n        return spin(A, lo, hi)\n    end\n    mid := uniformly random an integer strictly between lo and hi\n    return bar(A, lo, mid) + bar(A, mid, hi)\nend\n\nfunction spin(A, lo, hi):\n    count := 0\n    for i := lo to hi-1 do:\n        for j := i + 1 to hi do:\n            if A[i] > A[j] then count := count + 1\n        end\n    end\n    return count\nend\n```\n\n1. $O(1)$\n1. $O(\\log N)$\n1. $O(\\log^2 N)$\n1. $O(\\log\\log N)$\n1. $O(\\sqrt{N})$\n1. $O(N)$\n1. $O(N)$ ในกรณีที่แย่ที่สุด แต่โดยเฉลี่ย (Expected running time) จะเป็น $O(\\log N)$\n1. $O(N \\log N)$\n1. $O(N \\log^2 N)$\n1. $O(N \\log \\log N)$\n1. $O(N \\sqrt{N})$\n1. $O(N^2)$\n1. $O(N^2)$ ในกรณีที่แย่ที่สุด แต่โดยเฉลี่ย (Expected running time) จะเป็น $O(N \\log N)$\n1. $O(N^2 \\log N)$\n1. $O(N^2 \\log^2 N)$\n1. $O(N^2 \\log \\log N)$","archived":true,"region":{"south":false,"north":false,"central":true,"northeast":false},"deleted":false,"solution":"Answer: $O(N)$ (ไม่ว่าจะเป็น Worst-case หรือ Expected-case)","imageUrls":[],"tags":["code-peeking","big-o-analysis"],"createdAt":{"_seconds":1537544097,"_nanoseconds":394000000},"note":"- **Author:** เพลน"},"d267b00b-ba51-4dbb-a6ac-745d4a3f9651":{"deleted":false,"solution":"$O(n \\log^2 n)$","imageUrls":[],"tags":["big-o-analysis"],"createdAt":{"_seconds":1533106814,"_nanoseconds":0},"note":"- **Category:** Time-complexity analysis\n- **Author:** คูน","updatedAt":{"_seconds":1536575424,"_nanoseconds":556000000},"format":{"choices":true,"coding":false,"ponder":true,"quickfire":false},"round":{"national":false,"regional":false,"audition":true},"statement":"จงคำนวณหา Time complexity ของโปรแกรมต่อไปนี้\n\n```pseudocode\n# declare integers: i, j, k, sum\ninput: a positive integer n\noutput: sum\n\ni = 1\nwhile i < n\n    j := n\n    while j > 0\n        k := j\n        while k < n\n            sum := sum + i + j + k\n            k := k + 2\n        end\n        j := floot(j / 2)  # Math's floor function\n    end\n    i := i * 2\nend\n\nreturn sum\n```\n\n1. $O(n^3)$\n2. $O(n^2 \\log n)$\n3. $O(n^2 \\log^2 n)$\n4. $O(n \\log n^3)$\n5. $O(n \\log n^2)$\n6. $O(n \\log^3 n)$\n7. $O(n \\log^2 n)$\n8. $O(n \\log n)$\n9. $O(\\log^3 n)$\n\n**หมายเหตุ:** $\\log^k n = (\\log n)^k$","archived":true,"region":{"central":false,"northeast":false,"south":true,"north":false}},"d2e43cda-faaa-4920-80fd-8cb4dad419f8":{"region":{"central":false,"northeast":false,"south":true,"north":false},"deleted":false,"solution":"- https://drive.google.com/drive/folders/1cG692jVp1CozXRzObvSlDjl0a1crfttQ\n- **Reference:** IEEEXtreme2008\n- $O(n \\log n)$ running time (mostly due to sorting)","imageUrls":[],"tags":["sweep-line-algorithm","sorting","list-processing"],"createdAt":{"_seconds":1533106844,"_nanoseconds":0},"note":"- **Author:** จิ\n- **Difficulty:** Easy. Not sure can google questions in internet.\n- **Test cases provided by:** เพลน & อัท","updatedAt":{"_seconds":1536738287,"_nanoseconds":766000000},"format":{"choices":false,"coding":true,"ponder":false,"quickfire":false},"round":{"audition":false,"national":false,"regional":true},"statement":"# firewall-rules\n\n### Background\n\nคุณทำงานในบริษัทที่พัฒนาระบบเครือข่ายที่มีการตั้งค่า Network Firewall Allowed IP White-list Rules เพื่อให้เฉพาะผู้ใช้งานที่มีหมายเลข IP อยู่ใน White-list ดังกล่าวสามารถเข้าถึงระบบได้\n\n#### นิยาม\n\n- IP White-list หนึ่งจะประกอบด้วย**กลุ่ม**ของ \"ช่วงของไอพี\" (IP range) **หนึ่งหรือหลาย**ช่วงรวมกัน\n- IP range แต่ละช่วงจะถูกกำหนดด้วยหมายเลข IPv4 จำนวนสองตัว คั่นด้วยขีด เช่น `10.10.0.0-10.10.2.255` ซึ่งหมายถึงช่วงของหมายเลข IP ทั้งหมดตั้งแต่ `10.10.0.0` ไปจนถึง `10.10.2.255`\n- หมายเลข IP หนึ่ง ๆ จะประกอบไปด้วยจำนวนเต็มในช่วง 0-255 จำนวนสี่ตัว คั่นด้วยจุด (เช่น `10.10.0.0` คือตัวอย่างของ IP)\n- หมายเลข IP \"$a.b.c.d$\" จะ**มาก่อน** IP \"$w.x.y.z$\" ก็ต่อเมื่อ\n    - $a < w$ หรือ \n    - $a = w, b < x$ หรือ\n    - $a = w, b = x, c < y$ หรือ\n    - $a = w, b = x, c = y, d < z$\n-  หมายเลข IP $i$ จะอยู่ใน IP Range $s\\text{-}t$ เมื่อ $i$ **มิได้มาก่อน** $s$ และ $t$ **มิได้มาก่อน** $i$\n- ผู้ใช้งานจะเข้าถึงระบบได้หากมี IP ที่อยู่ในช่วง IP range อย่างน้อยอันใดอันหนึ่งในกลุ่มของ IP range หลาย ๆ อันใน IP White-list ข้างต้น\n\n### Problem Statement\n\nในการตั้งค่า White-list นั้นอาจมีการตั้งค่าด้วยกลุ่มของ IP range ได้หลายรูปแบบที่ให้ผลลัพธ์ในแง่ความปลอดภัยเหมือน ๆ กัน (**ตัวอย่าง:** การตั้งค่าทั้งสองแบบต่อไปนี้ให้ security ที่เท่ากัน\n\n```plain\n10.10.0.0-10.10.2.255\n```\n\n```plain\n10.10.0.0-10.10.1.255\n10.10.1.0-10.10.2.255\n```\n\nแต่การตั้งค่าแบบแรกจะประหยัดพื้นที่ในการเก็บข้อมูลมากกว่าแบบที่สอง \n\n#### Main Goal\n\nหน้าที่ของคุณก็คือ Optimize Firewall White-list Rules จากการตั้งค่าเก่าที่กำหนดให้ โดยเปลี่ยนการตั้งค่าใหม่ให้ใช้จำนวน IP range ที่น้อยที่สุด แต่ยังได้ security ที่เหมือนเดิมทุกประการ \n\n### Program Specification\n\nโปรแกรมทั้งหมดจะต้องอ่านข้อมูลจาก Standard Input และเขียนคำตอบลง Standard Output โดยข้อมูลจะมีฟอร์แมตดังต่อไปนี้\n\n#### Input Format\n\n- บรรทัดที่ 1: มีจำนวนเต็มหนึ่งตัว $N$ บอกจำนวน IP range ที่ปรากฏในการตั้งค่าแบบเก่า\n- อีก $N$ บรรทัดถัดมา บรรทัดที่ $i+1$ จะมี IP range หนึ่งช่วงในฟอร์แมตที่กำหนดในนิยามข้างต้น\n\n$$\n\\begin{aligned}\n& N \\\\\n& \\mathit{I\\!Prange}_1 \\\\\n& \\mathit{I\\!Prange}_2 \\\\\n& \\vdots \\\\\n& \\mathit{I\\!Prange}_N\n\\end{aligned}\n$$\n\n#### Output Format\n\nระบุ Firewall White-list Rules ใหม่ที่ ใช้จำนวนช่วง IP range น้อยที่สุด โดยมีฟอร์แมตเหมือนกับ Input Format และต้องเรียงลำดับจากก่อนไปหลัง (ตามนิยามก่อน-หลัง)\n\n### Example #1\n\n#### Input \n\n```plain\n2\n10.10.0.0-10.10.1.255\n10.10.1.0-10.10.2.255\n```\n\n#### output \n\n```plain\n1\n10.10.0.0-10.10.2.255\n```\n\n### Example #2\n\n#### Input \n\n```plain \n7\n10.10.200.0-10.255.255.255\n9.15.0.0-9.100.1.1\n9.9.9.0-9.101.0.0\n192.168.1.0-192.168.1.245\n192.168.2.0-192.168.3.0\n192.168.1.247-192.168.2.5\n10.5.0.0-10.100.100.100\n```\n\n#### output \n\n```plain\n4\n9.9.9.0-9.101.0.0\n10.5.0.0-10.255.255.255\n192.168.1.0-192.168.1.245\n192.168.1-247-192.168.3.0\n```\n\n### Constraints\n\nโปรแกรมของคุณจะถูกทดสอบกับ test cases สองชุด (เรียกว่าชุดเล็ก และชุดใหญ่)\n- test cases ชุดเล็กจะมีเงื่อนไขว่า จำนวน IP range ที่ปรากฎในข้อมูลนำเข้าจะอยู่ในช่วง $1 \\leq N \\leq 3000$\n- test cases ชุดใหญ่จะมีเงื่อนไขว่า จำนวน IP range ที่ปรากฎในข้อมูลนำเข้าจะอยู่ในช่วง $1 \\leq N \\leq 10^5$","archived":true},"d5dd822a-1555-4c6e-8f7f-7a3f62a18932":{"archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1533106826,"_nanoseconds":0},"note":"","updatedAt":{"_seconds":1533106826,"_nanoseconds":0},"format":{"coding":false,"ponder":false,"quickfire":false,"choices":false},"round":{"audition":false,"national":false,"regional":false},"statement":"Testing"},"d6f7969f-23f0-4b9e-ac3d-0e5d5808e67f":{"region":{"northeast":false,"south":false,"north":false,"central":true},"deleted":false,"solution":"7 ชั่วโมง","imageUrls":[],"tags":["hard-math","competitive-analysis"],"createdAt":{"_seconds":1533106838,"_nanoseconds":0},"note":"- **Category:** Algorithms / Hard Math\n- **Author:** เพลน","updatedAt":{"_seconds":1537784289,"_nanoseconds":555000000},"format":{"choices":true,"coding":false,"ponder":true,"quickfire":false},"round":{"regional":false,"audition":true,"national":false},"statement":"สมมติว่านาย A มี Program ที่เขียนขึ้นมาเองอันหนึ่งเพื่อใช้คำนวณข้อมูลขนาดใหญ่มหาศาล \n- ซึ่งอาจจะต้องใช้เวลาทำงานต่อเนื่องหลายชั่วโมง \n- และไม่อาจคาดเดาได้ว่า Program นี้จะใช้เวลาประมวลผลกี่ชั่วโมง (จนกว่า Program จะรันเสร็จสิ้นเท่านั้น)\n\nนาย A ตัดสินใจใช้บริการ Cloud แห่งหนึ่งเพื่อรัน Program ของตัวเอง โดยคิดค่าบริการดังนี้\n- หากเช่าเป็นชั่วโมง คิดชั่วโมงละ 1,200 บาท\n- นาย A สามารถเลือกอัปเกรดบริการ Cloud ให้เป็นแบบ Flat Rate เมื่อใดก็ได้ ระหว่างที่ Program รันด้วยอัตราค่าเช่ารายชั่วโมงอยู่นั้น   \n    โดยคิดเหมาจ่ายในราคา 10,000 บาท แต่จะไม่ได้ค่าเช่ารายชั่วโมงก่อนหน้านั้นคืน\n\n**ตัวอย่าง:** \n- สมมติว่านาย A นำ Program นี้ไปรันใน Cloud นี้ … เมื่อเวลาผ่านไป 4 ชั่วโมงพบว่า Program นี้ยังประมวลผลไม่เสร็จ นาย A จึงตัดสินใจเลือกอัปเกรดเป็น Flat Rate … แต่จากนั้นเมื่อเวลาผ่านไปอีก 2 ชั่วโมงโปรแกรมจึงรันเสร็จสิ้น\n\n    เท่ากับว่าค่าใช้จ่ายที่ถูกที่สุดที่เป็นไปได้ (optimal cost) ในกรณีนี้คือ 7,200 บาท แต่นาย A ต้องเสียเงินไป 14,800 บาท (actual cost) คิดเป็น 2.056 เท่าของ optimal cost\n\n- ในอีกเหตุการณ์หนึ่ง สมมติว่านาย A รัน Program ดังกล่าวจนครบ 6 ชั่วโมง พบว่ายังประมวลผลไม่เสร็จสิ้น จึงลองเสี่ยงอัปเกรดเป็น Flat Rate ดู แต่สุดท้ายแล้วโปรแกรมนี้ใช้เวลาถึง 20 ชั่วโมงในการรันจนเสร็จสิ้น \n\n    เท่ากับว่านาย A ใช้จ่ายไป 17200 บาท ซึ่งคิดเป็น 1.72 เท่าของ optimal cost ที่เกิดจากการเหมาจ่ายตั้งแต่แรกที่ 10000 บาท\n\nสังเกตว่าปัญหามีอยู่ 2 ส่วนคือ (1) นาย A ไม่สามารถคาดเดาระยะเวลาที่ Program จะใช้ประมวลผลได้ล่วงหน้า และ (2) ถ้าเราอัปเกรดเร็วหรือช้าเกินไป ค่าใช้จ่ายในกรณี worst-case อาจจะสูงเกินกว่าที่ควรจะเป็น อันเนื่องมาจากสาเหตุข้อแรก\n\nสำหรับโจทย์ข้อนี้ นาย A ไม่อยากรู้สึกว่าถูกเอาเปรียบ จึงต้องคิดวางแผนการ (strategy) เพื่อใช้บริการ Cloud ดังกล่าวโดยให้ค่าใช้จ่ายจริง (actual cost) มีปริมาณน้อยที่สุด เมื่อ**เทียบอัตราส่วน**กับค่าใช้จ่ายที่ถูกที่สุดที่เป็นไปได้ (optimal cost) … กล่าวคือ นาย A จะต้องตัดสินใจว่าจะเลือกเช่าบริการ Cloud เป็นเวลามากที่สุดกี่ชั่วโมง (และหลังจากนั้นจึงเลือกอัปเกรดเป็น Flat Rate หาก Program ยังรันไม่เสร็จ) จึงจะทำให้ actual to optimal cost ratio มีค่าน้อยที่สุดในกรณี worst-case?\n\n1. ควรอัปเกรดทันที่โดยไม่มีการเช่า\n2. ควรเช่าเป็นเวลาไม่เกิน 1 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 2 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 3 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 4 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 5 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 6 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 7 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 8 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 9 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 10 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 11 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 12 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 13 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 14 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 15 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 16 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 17 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 18 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 19 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 20 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 21 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 22 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 23 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าเป็นเวลาไม่เกิน 24 ชั่วโมง แล้วจึงอัปเกรดหากโปรแกรมยังรันไม่เสร็จ\n2. ควรเช่าตลอดไป ไม่ควรอัปเกรด","archived":true},"d87668bd-d21a-4896-8cea-6b7deda541fa":{"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"A= 3,215,863 (ถ้าไม่ปัดเศษหลักหน่วย จะได้ 3,215,862 ซึ่งผิด)\nB= 0\nC= 1,512,310 ","imageUrls":[],"tags":["small-coding"],"createdAt":{"_seconds":1533106849,"_nanoseconds":0},"note":"-**Author:** เอก\n-**Verified by** Aof\n- ภาคใต้ตอบถูก 0/7 ทีม","updatedAt":{"_seconds":1535330237,"_nanoseconds":779000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"regional":true,"audition":false,"national":false},"statement":"ในจานเพาะเลี้ยงแบคทีเรียจานหนึ่ง มีแบคทีเรีย 3 สายพันธุ์ A B และ C สายพันธุ์ละ 1 ล้านตัว\n\nทุกๆ 1 ชั่วโมงต่อจากนี้จะเกิดลำดับเหตุการณ์ดังนี้\n- แบคทีเรียทั้ง 3 สายพันธุ์จะขยายจำนวนขึ้นเป็นเท่าตัว \n- จากนั้นสายพันธุ์ B จะกินสายพันธุ์ A โดย B ทุกๆ 10 ตัวจะกิน A 1 ตัว\n- จากนั้นสายพันธุ์ C จะกินสายพันธุ์ B โดย C ทุกๆ 10 ตัวจะกิน B 1 ตัว\n- จากนั้นสายพันธุ์ A (ที่เหลืออยู่) จะกินสายพันธุ์ C โดย A ทุกๆ 10 ตัวจะกิน C 1 ตัว\n\nเป็นอย่างนี้ไปเรื่อยๆ \n\n_(ตัวอย่างของการกิน เช่น ถ้ามี B 19 ตัวจะกิน A แค่ 1 ตัว แต่ถ้า B 20 ตัวจะกิน A 2 ตัว)_\n\n**ให้หาจำนวนแบคทีเรียแต่ละสายพันธุ์ หลังจากผ่านไป 24 ชั่วโมง** โดยตอบเป็นหน่วย **ล้านตัว** ที่ปัดเศษทศนิยมทิ้ง","archived":true},"dd07a7b3-3729-4f82-aa46-2c7529bf9979":{"deleted":true,"solution":"((rand7() + rand7()) mod 11) + 1","imageUrls":[],"tags":["code-peeking","probability","proposed-north-audition"],"createdAt":{"_seconds":1533106828,"_nanoseconds":0},"note":"- **Author:** คูน","updatedAt":{"_seconds":1536573774,"_nanoseconds":904000000},"format":{"ponder":false,"quickfire":true,"choices":true,"coding":false},"round":{"national":false,"regional":false,"audition":true},"statement":"กำหนดให้ฟังก์ชัน `rand7()` เป็น randomized function ซึ่ง\n- ฟังก์ชัน `rand7()` ให้ output เป็นจำนวนเต็มในช่วงตั้งแต่ 1 ถึง 7 เท่านั้น\n- จำนวนเต็มในช่วงตั้งแต่ 1 ถึง 7 ทุกตัวมีโอกาสที่จะเป็น output ของฟังก์ชัน `rand7()` ทั้งสิ้น\n\nหากเราต้องการนำฟังก์ชันข้างต้นมาสร้างเป็นนิพจน์ (expression) ที่ให้ผลลัพธ์สุดท้ายเป็นจำนวนเต็มในช่วงตั้งแต่ 1 ถึง 11 เท่านั้น และจำนวนเต็มทุกตัวในช่วงดังกล่าวมีโอกาสเป็นผลลัพธ์สุดท้ายของ expression นี้ \n\nนิพจน์ข้อใดต่อไปนี้เป็นไปตามความต้องการที่กำหนดไว้ข้างต้น\n\n1. ```pseudocode \n    ((11 * rand7()) mod 7) + 1\n    ```\n2. ```pseudocode\n    ((7 * rand7()) mod 11) + 1\n    ```\n3. ```pseudocode\n    rand7() * 2 - 3\n    ```\n4. ```pseudocode\n    ((rand7() + rand7()) mod 11) + 1\n    ```\n5. ```pseudocode\n    ((rand7() mod 6) * 2)  + 1\n    ````\n\n**หมายเหตุ:** กำหนดให้เครื่องหมาย \"`/`\" คือการหารแบบปัดเศษทิ้ง (Integer division) และ \"`mod`\" คือการหารเอาเฉพาะเศษ (Modulo)","archived":false,"region":{"south":false,"north":false,"central":true,"northeast":false}},"dd205c86-dfa6-4bee-adde-0622e8c1f686":{"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"Answer: `[4, 1, 3, 2]`","imageUrls":[],"tags":["code-peeking"],"createdAt":{"_seconds":1536570204,"_nanoseconds":174000000},"note":"","updatedAt":{"_seconds":1536570553,"_nanoseconds":124000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":true},"round":{"national":false,"regional":false,"audition":true},"statement":"จากโปรแกรมต่อไปนี้\n\n```pseudocode\ninput: array of integers, A[0...n-1]\n\nfor i := 0 to n-1\n    for j := n downto i + 1\n        swap values between A[i] and A[j]\n    end\nend\n```\n\nจงหา array ความยาว 4 และประกอบด้วยตัวเลข 1-4 ซึ่งไม่ซ้ำกัน ที่เมื่อป้อนเป็น input ให้โปรแกรมดังกล่าว จะได้ output เป็น `[1, 2, 3, 4]`\n\n1. `[1,2,3,4]`\n1. `[1,2,4,3]`\n1. `[1,3,2,4]`\n1. `[1,3,4,2]`\n1. `[1,4,2,3]`\n1. `[1,4,3,2]`\n1. `[2,1,3,4]`\n1. `[2,1,4,3]`\n1. `[2,3,1,4]`\n1. `[2,3,4,1]`\n1. `[2,4,1,3]`\n1. `[2,4,3,1]`\n1. `[3,1,2,4]`\n1. `[3,1,4,2]`\n1. `[3,2,1,4]`\n1. `[3,2,4,1]`\n1. `[3,4,1,2]`\n1. `[3,4,2,1]`\n1. `[4,1,2,3]`\n1. `[4,1,3,2]`\n1. `[4,2,1,3]`\n1. `[4,2,3,1]`\n1. `[4,3,1,2]`\n1. `[4,3,2,1]`","archived":true},"de0f9638-30ef-4674-86fe-834b18f757de":{"region":{"central":false,"northeast":true,"south":false,"north":false},"deleted":false,"solution":"A =  5,947,554,816 ตัว\n\nB =  0 ตัว (ตายหมด)","imageUrls":[],"tags":["small-coding"],"createdAt":{"_seconds":1536057627,"_nanoseconds":269000000},"note":"- Recycled\n- Verified: Aof","updatedAt":{"_seconds":1536576122,"_nanoseconds":707000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"regional":true,"audition":false,"national":false},"statement":"ในจานเพาะเลี้ยงแบคทีเรียจานหนึ่ง มีแบคทีเรีย 2 สายพันธุ์ A และ B สายพันธุ์ละ 1,000 ตัว\nทุกๆ 1 ชั่วโมงต่อจากนี้จะเกิดเหตุการณ์ต่อไปนี้ตามลำดับ \n- แบคทีเรียทั้งสองสายพันธุ์ จะขยายจำนวนขึ้นเป็นเท่าตัว \n- แบคทีเรียสายพันธุ์ A จะกินสายพันธุ์ B โดย A ทุกๆ 8 ตัว จะกิน B 1 ตัว\n(เช่นถ้ามี A 15 ตัวจะกิน B ได้แค่ 1 ตัว แต่ถ้ามี A 16 ตัวจะกิน B 2 ตัว)\n- แบคทีเรียสายพันธุ์ B ที่เหลืออยู่ จะกินสายพันธุ์ A โดย B ทุกๆ  8 ตัว จะกิน A 1 ตัว\n\nให้หาจำนวนแบคทีเรียแต่ละสายพันธุ์ หลังจากผ่านไป 24 ชั่วโมง\nโดยตอบเป็นหลัก ล้านตัว ที่ปัดเศษทศนิยมทิ้ง\n\n\nตัวอย่าง ชั่วโมงที่ 1 จะเกิดเหตุการณ์ดังนี้ \n- แบคทีเรียทั้งสองสายพันธุ์ จะเพิ่มเป็นสายพันธุ์ละ 2,000 ตัว\n- แบคทีเรีย A 2,000 ตัว จะกิน B ไป 250 ตัว จึงเหลือ B 1,750 ตัว\n- แบคทีเรีย B 1,750 ตัว จะกิน A ไป 218 ตัว จึงเหลือ A  1,782 ตัว","archived":true},"debc2de1-726f-4ece-a386-1e712f817e60":{"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"audition":true,"national":false,"regional":false},"statement":"ถ้า x เป็น 16 แล้วค่าของ y หลังจากรันโปรแกรมต่อไปนี้เป็นเท่าไร?\n\n```pseudocode\ny := 1\nwhile y ≤ x\n    y := y * 2\nend\n```\n\n1. 1\n2. 2\n3. 4\n4. 8\n5. 16 \n6. 32","archived":true,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"Answer: \"32\"","imageUrls":[],"tags":["code-peeking"],"createdAt":{"_seconds":1533106801,"_nanoseconds":0},"note":"- **Author:** คูน","updatedAt":{"_seconds":1535292020,"_nanoseconds":470000000}},"df05c65f-3736-42ba-a8e6-7544768cf30e":{"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"7 ครั้ง\n\n```pseudocode\n(0 1 1) := (0 1 0) + (0 0 1)  # _1 = b + c\n(0 1 2) := (0 1 1) + (0 0 1)  # _2 = _1 + c\n(0 1 3) := (0 1 2) + (0 0 1)  # _3 = _2 + c \n(1 1 1) := (1 0 0) + (0 1 1)  # _4 = a + _1\n(1 2 3) := (0 1 2) + (1 1 1)  # _5 = _2 + _4\n(1 3 6) := (1 2 3) + (0 1 3)  # _6 = _5 + _3\n(1 4 9) := (1 3 6) + (0 1 3)  # _7 = _6 + _3\n```","imageUrls":[],"tags":["hard-math","optimization","logic-puzzle"],"createdAt":{"_seconds":1533106841,"_nanoseconds":0},"note":"- **Category:** Algorithm (Optimization) / Logic puzzle\n- **Author:** เพลน\n- Verified by อัท\n- ภาคใต้ตอบถูก 1/7 ทีม","updatedAt":{"_seconds":1535330152,"_nanoseconds":811000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"national":false,"regional":true,"audition":false},"statement":"กำหนดให้\n- มี input มาสามจำนวนคือ $a, b, c$ \n- และกำหนดให้ **\"การบวก\"**  คือการนำจำนวน**ที่มีอยู่ 2 จำนวน**มารวมกัน และเก็บค่าไว้ใช้ในการคำนวณต่อไปได้\n\nสมมติว่าเราต้องการคำนวณ $a + 2b + 3c$ เราอาจคำนวณโดยใช้สมการ `a + b + b + c + c + c` ซึ่งมีการบวกทั้งสิ้น 5 ครั้ง  \nแต่หากเราเขียนโปรแกรมโดยใช้ขั้นตอนวิธีดังต่อไปนี้ จะใช้จำนวนครั้งในการบวกเพียงแค่ 4 ครั้ง (ซึ่งน้อยที่สุดที่เป็นไปได้ในกรณีนี้)\n```pseudocode\ninput: a, b, c\ntemp_1 := b + c\ntemp_2 := temp1 + temp1  # 2b + 2c\ntemp_3 := temp_2 + c     # 2b + 3c\ntemp_4 := temp_3 + a     # a + 2b + 3c\nreturn temp_4\n```\n\n### โจทย์\nหากเราต้องการคำนวณหา $a + 4b + 9c$ จาก input $a, b, c$  ด้วยการเขียนโปรแกรมแล้ว จำนวนครั้งในการบวกที่น้อยที่สุดที่ทำได้คือกี่ครั้ง","archived":true},"df07e460-66d8-4a2c-bf19-2064c3d9bf83":{"createdAt":{"_seconds":1533106821,"_nanoseconds":0},"note":"- **หาภาพประกอบเพิ่มด้วย**\n- **Category:** Counting & corner cases\n- **Author:** เพลน\n- **Time-limit:** 20 วินาที\n- Verified\n- ภาคใต้ตอบถูก 0/7 ทีม","updatedAt":{"_seconds":1535329920,"_nanoseconds":161000000},"format":{"quickfire":true,"choices":false,"coding":false,"ponder":false},"round":{"national":false,"regional":true,"audition":false},"statement":"ธนาคารกสิกรไทยสาขาหนึ่งมีเวลาเปิดให้บริการตั้งแต่ 8:30 น. ถึง 15:30 น. \n\nอยากทราบว่าในช่วงเวลาดังกล่าวจะมีเวลาที่เข็มสั้นและเข็มยาวของนาฬิกา **ตั้งฉากกันพอดี** ทั้งหมดกี่ครั้ง\n\n**หมายเหตุ:** กำหนดให้เข็มสั้นและเข็มยาวขยับอย่างต่อเนื่องตลอดเวลา","archived":true,"region":{"south":true,"north":false,"central":false,"northeast":false},"deleted":false,"solution":"12 ครั้ง","imageUrls":[],"tags":["counting","edge-cases"]},"e45c3b12-951b-4ecc-b38e-d76943551f58":{"updatedAt":{"_seconds":1537350061,"_nanoseconds":852000000},"format":{"coding":true,"ponder":false,"quickfire":false,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"[โจทย์ภาษาไทยคลิกที่นี่](/questions/1cfa4a37-94f7-4102-816d-d06308bfade4)\n\n# max-perimeter [English Version]\n\n### Background\n\nSuppose that you are a woodworker. You are given an order to recycle some of the wooden sticks at disposal to construct one decoration in the shape of a triangle. There are a few constraints.\n\n- The triangular decoration must be made from 3 wooden sticks from a set of leftover sticks. Naturally, each stick cannot be used more than once.\n- The triangular decoration must have a nonzero area (i.e. the triangle should not be degenerated into a flat structure).\n\n#### Example\n\n- A triangle made of wood sticks of length $3$, $4$, and $5$ has the area of 6 units (a valid decoration).\n- A triangle made of wood sticks of length $1$, $1$, and $2$ has the area of 0 units (not a valid decoration).\n\n### Problem Statement\n\nWrite a program which computes the largest **perimeter** of any triangular decoration which can be built from a pile of $N$ wooden sticks. If it is impossible to form a valid triangle, the output should be $-1$.\n\n### Program Specification\n\nThe program you write must read the input data from standard input, and the answer should be written to standard output. The data has the following format.\n\n#### Input Format\n\n- Line #1: there is one integer $N$ representing the total number of wooden sticks at disposal.\n- Line #2: there are $N$ integers separated by spaces; each integer $L_i$ is the length of a particular wooden stick.\n$N$\n$$\n\\begin{aligned}\n& N \\\\\n& L_1\\; L_2\\; \\ldots\\; L_N  \\\\\n\\end{aligned}\n$$\n\n#### Output Format\n\n- The output should be a single integer describing the maximum perimeter of a triangular decoration which could be formed from the remaining wooden sticks (or $-1$ if it is impossible).\n\n## Example #1\n\n#### Input\n```plaintext\n5\n1 2 4 8 16\n```\n\n#### Output\n```plaintext\n-1\n```\n(N.B. The answer must be $-1$ since a valid triangle cannot be formed.) \n\n### Example #2\n\n#### Input\n```plaintext\n5\n1 2 3 4 5\n```\n\n#### Output\n```plaintext\n12\n```\n(N.B. The answer is $12$ which is the perimeter of a triangle whose sides are $3$, $4$, and $5$.) \n\n### Example #3\n\n#### Input\n```plaintext\n7\n180 3 42 4 20 21 4\n```\n\n#### Output\n```plaintext\n45\n```\n(N.B. The answer is $45$ which is the perimeter of a triangle whose sides are $4$, $20$, and $21$.)\n\n### Constraints\n\nYour program will be run against two sets of test cases: \"small\" and \"large\".\n- For test cases in group \"small\", the value $N$ satisfies $1 \\leq i \\leq N \\leq 100$\n- For test cases in group \"large\", the value $N$ satisfies $1 \\leq i \\leq N \\leq 200,\\!000$\n- The length of each wooden stick $L_i$ is within the range $0 < L_i \\leq 10^6$","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"","imageUrls":[],"tags":["sorting","insight"],"createdAt":{"_seconds":1537333370,"_nanoseconds":700000000},"note":""},"e4dfe753-a158-477c-b81c-dba2d30b247d":{"note":"- [เอก] ได้ 538\n- [เพลน] ได้ 538 ลองทำทั้งคำนวณเลข และใช้ Excel","updatedAt":{"_seconds":1537467963,"_nanoseconds":223000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"regional":true,"audition":false,"national":false},"statement":"## เวอร์ชันภาษาไทย\n\nณ หมู่บ้านแห่งหนึ่ง มีการวางผังอย่างเป็นระเบียบ กล่าวคือมีการวางถนนที่ตีเป็น Grid ประกอบด้วยถนนในแนวตั้งและแนวนอนอย่างละ 7 เส้น ดังที่แสดงในรูป\n\nนายเคเป็นผู้เข้าแข่งขัน TechJam Code Squad เขากำลังสำรวจเส้นทางการเดินทางจากบ้านของเขา (ซึ่งอยู่มุมบนซ้ายสุดของหมู่บ้าน) ไปยังสถานที่จัดการแข่งขัน TechJam (ซึ่งอยู่มุมล่างขวาสุดของหมู่บ้าน) อยากทราบว่าจะมีกี่เส้นทางที่นายเคสามารถเดินทางไปแข่งขัน TechJam ได้ โดยมีเงื่อนไขว่า\n\n- ไม่มีการเดินย้อนหรือเดินอ้อม จะเดินไปหาจุดหมายด้วยระยะทางที่สั้นที่สุดเท่านั้น\n- ไม่สามารถเดินทะลุบ้านได้\n- สี่แยก 2 แห่งมีสุนัขดุมาก (แสดงด้วยจุดกากบาทในรูป) นายเคจะไม่เดินผ่านสี่แยกดังกล่าว\n\n## English Version\n\nThere is a village with a decent city planning. Specifically, all roads are arranged in a grid pattern with 7 horizontal roads and 7 vertical roads, as seen in the picture.\n\nMr. K is a contestant in TechJam Code Squad. He is outlining his route from his home (locating at the top-left corner of the village) to TechJam contest site (locating at the bottom-right corner of the village). How many different routes are there that Mr. K may choose to take, subjecting to the following conditions?\n\n- He will never take a detour nor backtrack from a road he has already taken.  \n    In other words, he will always take a shortest route.\n- He cannot walk across any land nor through any houses off the road.\n- There are very ferocious dogs at 2 particular intersections in this village (marked with crosses in the image). Mr. K is avoiding these intersections without hesitation.","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"Answer: 538","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fe4dfe753-a158-477c-b81c-dba2d30b247d%2Fgrid-two-cross.png?alt=media&token=655f3c58-f98e-4b72-881e-9b74d3b7cb1f"],"tags":["counting","dynamic-programming"],"createdAt":{"_seconds":1537296309,"_nanoseconds":583000000}},"e54ea00f-f350-46bc-9b8b-c61804a67c21":{"format":{"coding":false,"ponder":false,"quickfire":true,"choices":true},"round":{"regional":false,"audition":true,"national":false},"statement":"ธนาคารกสิกรจัดประเพณีวิ่งควายที่จังหวัดชลบุรี มีควายร่วมเข้าประกวดวิ่งจำนวน 99 ตัว แต่ภายในงานมีลู่ให้ควายวิ่งได้แค่รอบละ 8 ตัวเท่านั้น\n\nหากธนาคารต้องการหาควายที่วิ่งเร็วที่สุด 1 ตัว จะต้องจัดการแข่งขันอย่างน้อยกี่รอบ?\n\n(สมมติว่าควายวิ่งด้วยอัตราเร็วเท่าเดิมตลอดทุกรอบ โดยไม่สามารถใช้นาฬิกาจับเวลาได้)\n\n1. 11\n2. 12\n3. 13\n4. 14\n5. 15\n6. 16\n7. 17\n8. 18\n9. 19\n10. 20\n11. 21\n12. 22\n13. 23\n14. 24\n15. 25","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false},"deleted":false,"solution":"Answer: \"14 รอบ\"","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1535292104,"_nanoseconds":798000000},"note":"- Recycled","updatedAt":{"_seconds":1535292907,"_nanoseconds":679000000}},"e5bddade-c90d-4867-8616-a91575ef8b2c":{"updatedAt":{"_seconds":1536576149,"_nanoseconds":329000000},"format":{"ponder":true,"quickfire":false,"choices":false,"coding":false},"round":{"regional":true,"audition":false,"national":false},"statement":"นายเคเข้าร่วมในงานประมูลทะเบียนรถหมวด ฮฮ ซึ่งมีการเปิดประมูลเลขทะเบียนรถตั้งแต่ 1 จนถึง 9999\n\nนายเคได้ยินจากหมอดูหลายท่านว่า หากต้องการทำให้ชีวิตมั่งคั่งร่ำรวย จะต้องมี **\"ผลรวมเลขโดดสุดท้าย\"** เป็น 8  \nเช่น ป้ายทะเบียน 7595 เป็นป้ายทะเบียนมั่งคั่ง เพราะ $7 + 5 + 9 + 5 = 26 \\Rightarrow 2 + 6 = 8$  \nแต่ป้ายทะเบียน 7777 ไม่มั่งคั่ง เพราะ $7 + 7 + 7 + 7 = 28 \\Rightarrow 2 + 8 = 10 \\Rightarrow 1 + 0 = 1 \\neq 8$\n\nจงคำนวณว่า ในบรรดาป้ายทะเบียนในเปิดประมูลในวันนี้ จะมีป้ายทะเบียนมั่งคั่งทั้งหมดกี่ป้าย?","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false},"deleted":false,"solution":"1111 ป้าย","imageUrls":[],"tags":["math-puzzle","small-coding","insight"],"createdAt":{"_seconds":1536058867,"_nanoseconds":146000000},"note":"- Verified by เอก"},"e6f41955-2f70-4e54-ad1e-280751c52f03":{"format":{"choices":false,"coding":false,"ponder":false,"quickfire":true},"round":{"audition":false,"national":false,"regional":true},"statement":"### ตัวอย่าง\n\nจาก**ตัวอย่าง**นิพจน์ (expression) ทางคณิตศาสตร์ต่อไปนี้\n$$\n5 - 2 + 8 - 4 - 3\n$$\n\nหากเราเติมวงเล็บในนิพจน์ดังกล่าวเพื่อ**เปลี่ยนกลุ่มการบวกหรือการลบ** จะทำให้ผลลัพธ์สุดท้ายที่ได้ต่างออกไป เช่น\n- $5 - (2 + 8) - 4 - 3 = -12$\n- $5 - (2 + 8 - 4 - 3) = 2$\n- $5 - (2 + 8 - (4 - 3)) = -4$\n\nแต่วิธีการเติมวงเล็บที่ทำให้ผลลัพธ์สุดท้ายที่ค่ามากที่สุดคือ $5 - 2 + 8 - (4 - 3) = 10$\n\n### คำถาม\n\nจากนิพจน์ต่อไปนี้ จะเติมวงเล็บให้ผลลัพธ์สุดท้ายมีค่ามากที่สุด จะได้ค่าเท่าใด?\n$$\n10 - 9 - 8 - 7 - 6 + 5 - 4 - 3 - 2 - 1 \n$$\n\n**หมายเหตุ** ไม่อนุญาตให้มีการคูณเกิดขึ้นจากการเติมวงเล็บในนิพจน์ที่กำหนดให้","archived":true,"region":{"northeast":true,"south":false,"north":false,"central":false},"deleted":false,"solution":"ตอบ 37  \n(ได้จาก $10 - (9 - 8 - 7 - (6 + 5) - 4 - 3 - 2 - 1) = 37$","imageUrls":[],"tags":["60-sec","math-puzzle"],"createdAt":{"_seconds":1536055652,"_nanoseconds":749000000},"note":"","updatedAt":{"_seconds":1536576036,"_nanoseconds":822000000}},"e77a21c8-7c22-4759-ad6b-9a664251f70c":{"updatedAt":{"_seconds":1536541008,"_nanoseconds":313000000},"format":{"choices":true,"coding":false,"ponder":false,"quickfire":true},"round":{"regional":false,"audition":true,"national":false},"statement":"### ตัวอย่าง\n\nจาก**ตัวอย่าง**นิพจน์ (expression) ทางคณิตศาสตร์ต่อไปนี้\n$$\n5 - 2 + 8 - 4 - 3\n$$\n\nหากเราเติมวงเล็บในนิพจน์ดังกล่าวเพื่อ**เปลี่ยนกลุ่มการบวกหรือการลบ** จะทำให้ผลลัพธ์สุดท้ายที่ได้ต่างออกไป เช่น\n- $5 - (2 + 8) - 4 - 3 = -12$\n- $5 - (2 + 8 - 4 - 3) = 2$\n- $5 - (2 + 8 - (4 - 3)) = -4$\n\nแต่วิธีการเติมวงเล็บที่ทำให้ผลลัพธ์สุดท้ายที่ค่ามากที่สุดคือ $5 - 2 + 8 - (4 - 3) = 10$\n\n### คำถาม\n\nจากนิพจน์ต่อไปนี้ จะเติมวงเล็บให้ผลลัพธ์สุดท้ายมีค่ามากที่สุด จะได้ค่าเท่าใด?\n$$\n10 - 9 - 8 - 7 - 6 + 5 - 4 - 3 - 2 - 1 \n$$\n\n**หมายเหตุ** ไม่อนุญาตให้มีการคูณเกิดขึ้นจากการเติมวงเล็บในนิพจน์ที่กำหนดให้\n\nChoice\n\n1. -27\n2. -24\n3. -10\n4. -11\n5. -1\n6. 0\n7. 4\n8. 7\n9. 9\n10. 11\n11. 13\n12. 15\n13. 17\n14. 19\n15. 23\n16. 29\n17. 37","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"ตอบ 37  \n(ได้จาก $10 - (9 - 8 - 7 - (6 + 5) - 4 - 3 - 2 - 1) = 37$","imageUrls":[],"tags":[],"createdAt":{"_seconds":1536541008,"_nanoseconds":313000000},"note":"reuse regional NE to audition N"},"ec868bd3-7015-4a6c-988b-1479adf43673":{"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"regional":false,"audition":true,"national":false},"statement":"พิจารณา pseudocode ต่อไปนี้\n\nข้อมูลในข้อใดต่อไปนี้ทำให้ psudocode แสดงค่า \"balanced\"\n\n```pseudocode\ninput: character stream I\n\nS := empty stack\nfor each character c in stream I \n   if c == ‘(‘\n      S.push(‘(‘)\n   else if c == ‘)’ and stack S is not empty\n      S.pop()\n   else \n      print(“unbalanced”) and exit\n\nprint(“balanced”)\n```\n\n1. ()()()())\n2. (())(())(\n3. ((((())))))\n4. )()(\n5. (()))()","archived":true,"region":{"south":false,"north":false,"central":false,"northeast":true},"deleted":false,"solution":"\"2\" (())(())(","imageUrls":[],"tags":["code-peeking","data-structure"],"createdAt":{"_seconds":1535372172,"_nanoseconds":235000000},"note":"","updatedAt":{"_seconds":1536575766,"_nanoseconds":888000000}},"ef0c2e61-988b-42a8-ae6e-e96edf72621c":{"region":{"northeast":false,"south":false,"north":true,"central":false},"deleted":false,"solution":"","imageUrls":[],"tags":[],"createdAt":{"_seconds":1537333599,"_nanoseconds":759000000},"note":"","updatedAt":{"_seconds":1537376278,"_nanoseconds":609000000},"format":{"quickfire":false,"choices":false,"coding":true,"ponder":false},"round":{"regional":true,"audition":false,"national":false},"statement":"[โจทย์ภาษาไทยคลิกที่นี่](/questions/7e8d1659-eb26-4f86-bd3a-c28c50a09767)\n\n# island-counting [English Version]\n\n### Background\n\nThere is a retro game in which maps are drawn with ASCII Art. Particularly, a map is a rectangular collection of ASCII characters in $R$ rows and $C$ columns. Each character represents a cell in the map and it could be one of two possible values:\n\n1. Water cell, which is represented by `.`  \n2. Land cell, which is represented by `#`\n\nAdditionally, we assume that the area surrounding but not shown on the map is the vast ocean (without any land cells).\n\nFor example, the following is one possible map of size $R=6$ and $C=18$.\n```plain\n................##\n..#####...##......\n.##...##..##...###\n.#..#..#.......#..\n.#....##..#.#..#.#\n.######....#...#.#\n```\n\n#### What is an island?\n\n- Suppose that we are initially locating at a land cell. If we could reach all other land cells through a sequence of _horizontal_ or _vertical_ moves (also called a trail) without ever touching water, then those land cells are considered part of the same island.\n- Furthermore, if this trail results in us returning to the initial cell, then all of the cells surrounded by the trail are also part of the same island.\n    - Observe that, as a result of these definitions, there could be \"a lake\" which is completed surrounded by land cells. This lake is considered part of the island inside which it is located.\n    - Also, a piece of land cells within this lake is considered part of the same island surrounding the said lake; it is not a separate island.\n\nFor illustrative purpose only, based on the example given previously, the map could be redrawn so that parts of the same island is represented by the same alphabet. This new map is as shown here.\n```plain\n................AA\n..BBBBB...CC......\n.BBBBBBB..CC...DDD\n.BBBBBBB.......D..\n.BBBBBBB..E.F..D.G\n.BBBBBB....H...D.G\n```\n(This map contains 8 islands.)\n\n### Problem Statement\n\nA map inside the game will be provided. How many islands are there in the map according to the given definition.\n\n### Program Specification\n\nThe program you write must read the input data from standard input, and the answer should be written to standard output. The data has the following format.\n\n#### Input Format\n\n- Line #1: there are two integers $R$ and $C$ separated by spaces\n- For the next $R$ lines, each line will contain a string of $C$ characters (which are either `.` or `#`) representing its respective row of the map.\n\n$$\n\\begin{aligned}\n& R\\; C \\\\\n& \\mathit{M\\!ap}[1, 1 \\ldots C] \\\\\n& \\mathit{M\\!ap}[2, 1 \\ldots C] \\\\\n& \\vdots \\\\\n& \\mathit{M\\!ap}[R, 1 \\ldots C]\n\\end{aligned}\n$$\n\n(N.B. $M$ is a 1-indexed, 2-dimensional array representing the map.)\n\n#### Output Format\n\n- The output should be a single integer representing the number of islands in a given map.\n\n\n### Example #1 \n\n#### Input\n\n```plain\n6 18\n................##\n..#####...##......\n.##...##..##...###\n.#..#..#.......#..\n.#....##..#.#..#.#\n.######....#...#.#\n```\n#### Output\n\n```plain\n8\n```\n\n### Example #2\n\n#### Input\n\n```plain\n7 7\n.......\n..####.\n.#...#.\n.#.#.#.\n.#...#.\n.#####.\n.......\n```\n#### Output\n\n```plain\n2\n```\n\n### Constraints\n\nYour program will be run against two sets of test cases: \"small\" and \"large\".\n- For test cases in group \"small\", the values $R$ and $C$ satisfy $1 \\leq R, C \\leq 200$\n- For test cases in group \"large\", the values $R$ and $C$ satisfy $1 \\leq R, C \\leq 3000$","archived":true},"ef2e476f-7753-4586-88a6-e237aebb7d2b":{"region":{"south":false,"north":true,"central":false,"northeast":false},"deleted":false,"solution":"$O(n^2 \\log n)$","imageUrls":[],"tags":["big-o-analysis","propose-north-audition"],"createdAt":{"_seconds":1533106829,"_nanoseconds":0},"note":"- **Category:** Time-complexity analysis\n- **Author:** คูน","updatedAt":{"_seconds":1536543097,"_nanoseconds":875000000},"format":{"choices":true,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":true,"national":false,"regional":false},"statement":"จงคำนวณหา Time complexity ของโปรแกรมต่อไปนี้\n\n```pseudocode\n# declare integers: i, j, k\ninput: a positive integer n\n\ni := 1\nwhile i ≤ n\n    j := 0\n    while j < i\n        k := 0\n        while k < n\n            print \"Hello World\"\n            k := k + 2\n        end\n        k := 1\n        while k < n\n            print \"Hello World again!\"\n            k := k * 2\n        end\n        j := j + 1\n    end\n    i := i * 2\nend\n```\n\n1. $O(n^3)$\n2. $O(n^2 \\log n)$\n3. $O(n^2 \\log^2 n)$\n4. $O(n \\log n^3)$\n5. $O(n \\log n^2)$\n6. $O(n \\log^3 n)$\n7. $O(n \\log^2 n)$\n8. $O(n \\log n)$\n9. $O(\\log^3 n)$","archived":true},"f052e095-5ec4-436d-8b6b-451db9950c70":{"deleted":true,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2F-LJwIAVGoXXJdr06ZV01?alt=media&token=b590b296-6b82-4e86-b8f6-f730a43ec963"],"tags":["dynamic-programming"],"createdAt":{"_seconds":1533106840,"_nanoseconds":0},"note":"- **Category:** Dynamic Programming\n- **Author:** เพลน","updatedAt":{"_seconds":1538305468,"_nanoseconds":201000000},"format":{"ponder":false,"quickfire":false,"choices":false,"coding":true},"round":{"regional":true,"audition":false,"national":false},"statement":"# treasure-hunter\n\n### Background\n\nณ สถานที่แห่งหนึ่ง บนพื้นมีกระเบื้องขนาด $1$ หน่วย $\\times$ $1$  เรียงตัวกันเป็นสี่เหลี่ยมผืนผ้าเป็นจำนวน $R$ แถว แถวละ $C$ แผ่น นอกจากนั้น บนกระเบื้องแต่ละแผ่นจะมีตัวเลขเขียนกำกับไว้อีกด้วย (ตัวอย่างในรูปซ้าย: เป็นกระเบื้อง 6 แถว แถวละ 6 ชิ้น กระเบื้องแต่ละชิ้นมีหมายเลขกำกับอยู่ เช่นแถวที่สามมีตัวเลข $2, 4, -9, 8, 6, 4$ เป็นต้น) \n\nเราจะเล่นเกมเก็บแต้มจากการเดินบนกระเบื้องดังกล่าว จากขอบซ้ายไปขอบขวา โดยเริ่มจากแถวใดของขอบซ้ายก็ได้ และสิ้นสุดในแถวใดของขอบขวาก็ได้ นอกเหนือจากนั้น เราสามารถเลือกเดินได้สามแบบเท่านั้นคือ (1) เดินไปทางขวา (2) เดินขึ้นบน และ (3) เดินลงล่าง โดยมีเงื่อนไขเพิ่มเติมว่า เราสามารถเลือกเลี้ยวซ้ายหรือขวา หรือตรงไปได้เท่านั้น เพราะฉะนั้น หากในคอลัมน์ใดผู้เล่นเลือกเดินขึ้นบนแล้วจะหันกลับหลังมาเดินลงล่างไม่ได้อีก (เช่นเดียวกัน หากเลือกเดินลงล่างแล้วจะเดินขึ้นบนอีกไม่ได้)\n\nเป้าหมายของเราคือเราต้องการเลือกเส้นทางเดินบนกระเบื้องตามเงื่อนไขดังกล่าวที่มี \"แต้มสุดท้าย\" มากที่สุด การคำนวณ \"แต้มสุดท้าย\" ประกอบด้วยสองส่วน ดังนี้\n\n1. ***แต้มรวมตัวตั้ง*** = ผมรวมแต้มบนกระเบื้องที่เดินผ่านทั้งหมด\n2. ***หักออกด้วยบทลงโทษ*** = (จำนวนครั้งที่เลี้ยวซ้าย/ขวา) $\\times$ (คะแนนลงโทษ/penalty factor)\n\n#### ตัวอย่างจากรูปบน\n\n$$\n\\text{แต้มรวม} = (1+7+4-9-2+6-8+1-4+6+4-9+2) - (8 \\times 5) = -41\n$$\n\n### Task Description\n\nหากกำหนดขนาดและตัวเลขของกระเบื้องบนพื้นมาให้ทั้งหมด จงหาผลรวมแต้มที่ดีที่สุดที่เป็นไปได้\n\nค่า $v[i, j]$ จะเก็บตัวเลขกระเบื้องแถวที่ $i$ (นับจากแถวบน) ชิ้นที่ $j$ (นับจากซ้าย) โดยที่ $1 \\leq i \\leq R$ และ $1 \\leq j \\leq C$.\n\n### Program Specification\n\n#### Input Format\n\n$$\n\\begin{aligned}\n& R \\;\\; C \\;\\; P  \\\\\n& v[1,1] \\;\\; v[1,2] \\;\\; \\ldots \\;\\; v[1,C] \\\\\n& v[2,1] \\;\\; v[2,2] \\;\\; \\ldots \\;\\; v[2,C] \\\\\n& \\quad \\vdots \\\\\n& v[R,1] \\;\\; v[R,2] \\;\\; \\ldots \\;\\; v[R,C] \\\\\n\\end{aligned}\n$$\n\n#### Output Format\n\nจำนวนเต็มตัวเดียว บอกแต้มรวมที่มากที่สุด\n\n### Conditions\n\n- ขนาดของพื้นที่โดยรวมคือ $1 \\leq R, C \\leq 1000$\n- ตัวเลขของกระเบื้องแต่ละชิ้นคือ $-1000 \\leq v[i,j] \\leq 1000$ สำหรับ $0 \\leq i < R$ และ $0 \\leq C$ ใด ๆ","archived":false,"region":{"south":false,"north":false,"central":true,"northeast":false}},"f088ada5-25fc-4b91-9684-e691feb40625":{"format":{"ponder":false,"quickfire":true,"choices":false,"coding":false},"round":{"audition":false,"national":false,"regional":true},"statement":"## เวอร์ชันภาษาไทย\n\nมีกล่อง 75 ใบ \n\n- กล่องแต่ละใบถูกล็อกไว้ด้วยแม่กุญแจที่แตกต่างกันทั้งหมด \n- กุญแจสำหรับแม่กุญแจแต่ละอัน ถูกบรรจุซ่อนอยู่ในกล่องใบอื่น ๆ (แปลว่ากุญแจที่จะเปิดกล่อง A จะอยู่ในกล่องอื่นซึ่งไม่ใช่ A)\n- นอกจากนั้น แต่ละกล่องมีกุญแจอยู่ข้างในเพียงดอกเดียว\n- การเปิดกล่องหนึ่งกล่องมีได้สองวิธีคือ (a) ทำลายแม่กุญแจ หรือ (b) ใช้กุญแจไข\n\nหากเราต้องการเปิดกล่องทุกใบออกทั้งหมด โดยที่ทำลายแม่กุญแจให้น้อยที่สุด  \nในกรณีที่__เลวร้ายที่สุด__จะต้องทำลายแม่กุญแจอย่างน้อยกี่กล่องจึงจะเปิดกล่องได้ครบ 75 ใบ?\n\n## English Version\n\nThere are 75 container boxes.\n\n- Each box is locked from outside with a distinct padlock.\n- The key for a particular padlock will be contained inside another box (i.e. the key to open box A will be in a box other than box A).\n- Each box will always contain exactly one key.\n- Two methods to open a box: (a) forcefully breach the padlock, and (2) use a key to unlock the padlock.\n\nWhat is the minimum number of padlocks we need to forcefully breach, in the worst case, in order to guarantee that we would be able to open all of 75 boxes?","archived":true,"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"37 ใบ","imageUrls":[],"tags":["counting","graph-theory"],"createdAt":{"_seconds":1533106835,"_nanoseconds":0},"note":"- **Category:** Counting / Math\n- **Author:** เพลน","updatedAt":{"_seconds":1537254240,"_nanoseconds":698000000}},"f4de7308-a5a8-42a2-b591-81fab4ee3378":{"deleted":false,"solution":"103 วิธี","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1535875111,"_nanoseconds":865000000},"note":"- **Author:** เพลน\n- Verified by Eak","updatedAt":{"_seconds":1537488451,"_nanoseconds":78000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"audition":false,"national":false,"regional":true},"statement":"## เวอร์ชันภาษาไทย\n\nจากชุดของจำนวนเต็มตั้งแต่ 1 ถึง 10 ดังต่อไปนี้\n\n$$\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n$$\n\nจะมีกี่วิธีที่เราเลือกจำนวนเต็มอย่างน้อย 1 ตัวจากชุดจำนวนดังกล่าว ที่ผลรวมจะหารด้วย 10 ลงตัวพอดี?  \n\nตัวอย่างบางวิธีที่ทำได้\n- $10$\n- $1+9$,\n- $1+2+3+4$,\n- $2+5+6+7$\n- และอื่น ๆ อีกมากมาย\n\n## English Version\n\nFrom the following set of integers from 1 through 10,\n\n(equation)\n\nHow many combinations of numbers are there from the set of integers given above whose sum is divisible by 10?\n\nHere are a few examples for such combinations.\n\n- (example)\n- (example)\n- (example)\n- (example)\n- etc.","archived":true,"region":{"south":false,"north":true,"central":false,"northeast":false}},"f4e2fee3-cec3-47bb-b5ff-53258915c9b7":{"imageUrls":[],"tags":["recursion","counting"],"createdAt":{"_seconds":1539664845,"_nanoseconds":711000000},"note":"- **Author:** เพลน","updatedAt":{"_seconds":1539665047,"_nanoseconds":913000000},"format":{"coding":false,"ponder":false,"quickfire":true,"choices":false},"round":{"audition":false,"national":true,"regional":false},"statement":"จงพิจารณาโปรแกรมที่ใช้คำนวณ Fibonacci number ด้วย Recursive function with memoization ดังต่อไปนี้\n\n```pseudocode\nsaved_fibonacci := empty hash table\n\nfunction fibo(n):\n    # n is a non-negative integer\n    if n == 1 or n == 2 then:\n        return 1\n    end\n    if not saved_fibonacci.has_key(n) then:\n        value := fibo(n-1) + fibo(n-2)\n        saved_fibonacci.put_key(n, value)\n    end\n    return saved_fibonacci.get_key(n)\nend\n```\n\nเมื่อมีการเรียกใช้ฟังก์ชัน `fibo(1000)` ครั้งแรก แล้วฟังก์ชัน `fibo(·)` ข้างต้นนี้จะถูกเรียกใช้งานรวมกันทั้งสิ้นกี่ครั้ง?","archived":false,"region":{"south":false,"north":false,"central":false,"northeast":false},"deleted":true,"solution":"Answer: 1997 ครั้ง\n\n- ฟังก์ชัน `fibo(i)` จะถูกเรียก 2 ครั้ง จาก `fibo(i+1)` และ `fibo(i+2)` ยกเว้นกรณีที่ `i = 1, n-1, n`"},"f7769c64-fbec-4f9e-88fe-9e0cd6d19ad6":{"deleted":false,"solution":"10407293750 วิธี","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1535885981,"_nanoseconds":911000000},"note":"- **Author:** เพลน\n- ข้อนี้สามารถเขียนถึก $O(N^3)$ อย่างง่ายดาย \n    ```python\n    sum(int(i + j > k and i + k > j and j + k > i)  # ไล่ทุกกรณ๊\n        for i in range(1, 1+N)\n        for j in range(i+1, 1+N)\n        for k in range(j+1, 1+N))\n    ```\n    แต่ในความเป็นจริง มี $O(N^2)$ ที่ง่ายไม่แพ้กัน แค่ต้องคิดเพิ่มนิดหน่อย \n    ```python\n    sum(min(N, i + j - 1) - j  # นับจำนวน k ที่เป็นไปได้\n        for i in range(1, 1+N)\n        for j in range(i+1, 1+N))\n    ```\n- ถ้าข้อนี้กำหนดให้ $N = 1000$ จะเขียนวิธี $O(N^3)$ ก็จะใช้เวลารันแป๊บเดียว (ซึ่งอาจจะง่ายไป)  \n    แต่ถ้า $N = 5000$ จะทำให้วิธี $O(N^3)$ ไม่ทัน แต่ $O(N^2)$ ยังทันสบาย ๆ\n\n- [เอก] ผมคิดได้ 10407293750 วิธี  ไม่ตรงกับเพลน เลยลองลง python แล้ว run script เพลน ก็ได้คำตอบเท่ากันนะที่ 10407293750L\n- [เอก] แก้คำตอบเป็น 10407293750 วิธี ถือว่า verified แล้วด้วย code สองคน เพลน & เอก","updatedAt":{"_seconds":1536152728,"_nanoseconds":311000000},"format":{"quickfire":false,"choices":false,"coding":false,"ponder":true},"round":{"regional":true,"audition":false,"national":false},"statement":"**CAUTION.** ข้อนี้อาจต้องใช้ 64-bit integer\n\nสมมติว่าเรามีกองแท่งไม้ 5000 แท่ง ซึ่งแต่ละแท่งมีความยาว $1, 2, 3, \\ldots, 5000$ หน่วย\n\nเราจะหยิบแท่งไม้สามแท่งจากกองดังกล่าว ประกอบเป็นสามเหลี่ยมที่มีพื้นที่มากกว่าศูนย์ได้กี่วิธี?\n\n**สังเกตว่า** ผลรวมความยาวของกิ่งไม้สองแท่งใด ๆ ต้องมากกว่าความยาวของกิ่งไม้อีกแท่งเสมอ จึงจะประกอบเป็นสามเหลี่ยมที่มีพื้นที่มากกว่าศูนย์ได้ เช่น\n- กิ่งไม้ความยาว $3,4,5$ สามารถประกอบเป็นสามเหลี่ยมได้\n- กิ่งไม้ความยาว $1,3,5$ ไม่สามารถประกอบเป็นสามเหลี่ยมได้\n- กิ่งไม้ความยาว $1,2,3$ ไม่สามารถประกอบเป็นสามเหลี่ยมที่มีพื้นที่มากกว่าศูนย์ได้","archived":true,"region":{"central":false,"northeast":true,"south":false,"north":false}},"f83d31db-20b1-4cc3-926c-270bf6e5dc2c":{"region":{"central":false,"northeast":false,"south":false,"north":true},"deleted":false,"solution":"รูปทั่วไป: $N^3$\n\nเมื่อ $N = 15,000$ จะได้ $N^3 = 3,\\!375,\\!000,\\!000,\\!000$","imageUrls":[],"tags":["counting","math"],"createdAt":{"_seconds":1536117136,"_nanoseconds":189000000},"note":"- [เอก] sum = N^3 = 8000\n- [เอก] อยากให้โจทย์ใหญ่ขึ้น เพื่อจะได้ทำใน Excel ไม่ไหว เช่น N=2000\n- [Ji] เห็นด้วย แต่ก็อยากให้ excel ทำได้เหมือนกัน  แต่รอจนคอมแฮ๊ง ไรงี๊ แก้เป็น N=16,384 ดีไหม  เพราะเป็น max column ของ excel","updatedAt":{"_seconds":1537467578,"_nanoseconds":633000000},"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"regional":true,"audition":false,"national":false},"statement":"## เวอร์ชันภาษาไทย\n\n**คำเตือน:** คำตอบอาจใหญ่เกินกว่าขอบเขตของ 32-bit integer\n\nกำหนดให้มีตารางของตัวเลขขนาด $15000 \\times 15000$ ดังรูป\n\n$$\n\\begin{bmatrix}\n1 & 2 & 3 & \\cdots & \\cdots & 15000 \\\\\n2 & 3 & 4 & \\cdots & \\cdots & 15001 \\\\\n3 & 4 & 5 & \\cdots & \\cdots & 15002 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & & \\vdots \\\\\n\\vdots & \\vdots & \\vdots & & \\ddots & \\vdots \\\\\n15000 & 15001 & 15002 & \\cdots & \\cdots & 29999 \\\\\n\\end{bmatrix}\n$$\n\nจงหาผลรวมของตัวเลขทุกตัวในตาราง\n\n## English Version\n\n**Warning:** The solution may be larger than 32-bit integer.\n\nSuppose we have the following table of numbers of size $15000 \\times 15000$.\n\n(table)\n\nWhat is the sum of every cell in this table?","archived":true},"f9b7109c-a646-4571-8cf7-bfef20980a5a":{"format":{"quickfire":true,"choices":true,"coding":false,"ponder":false},"round":{"audition":true,"national":false,"regional":false},"statement":"ธนาคารกสิกรจัดประเพณีวิ่งควายที่จังหวัดชลบุรี มีควายร่วมเข้าประกวดวิ่งจำนวน 100 ตัว แต่ภายในงานมีลู่ให้ควายวิ่งได้แค่รอบละ 7 ตัวเท่านั้น\n\nหากธนาคารต้องการหาควายที่วิ่งเร็วที่สุด 1 ตัว จะต้องจัดการแข่งขันอย่างน้อยกี่รอบ?\n\n(สมมติว่าควายวิ่งด้วยอัตราเร็วเท่าเดิมตลอดทุกรอบ โดยไม่สามารถใช้นาฬิกาจับเวลาได้)\n\n1. 11\n2. 12\n3. 13\n4. 14\n5. 15\n6. 16\n7. 17\n8. 18\n9. 19\n10. 20\n11. 21\n12. 22\n13. 23\n14. 24\n15. 25","archived":true,"region":{"northeast":false,"south":true,"north":false,"central":false},"deleted":false,"solution":"Answer: \"17 รอบ\"","imageUrls":[],"tags":["counting"],"createdAt":{"_seconds":1533106816,"_nanoseconds":0},"note":"- **Category:** Math & logical puzzles\n- **Author:** เพลน\n","updatedAt":{"_seconds":1536575525,"_nanoseconds":63000000}},"faa9516c-0147-4808-a735-2d1f26925b8b":{"archived":true,"region":{"central":false,"northeast":false,"south":true,"north":false},"deleted":false,"solution":"\n2. ฟังก์ชัน square-root แต่ปัดเศษทิ้งเป็นจำนวนเต็มเสมอ (round down)","imageUrls":[],"tags":["code-peeking","edge-cases"],"createdAt":{"_seconds":1533106815,"_nanoseconds":0},"note":"- **Category:** Code peeking\n- **Author:** เพลน","updatedAt":{"_seconds":1536575503,"_nanoseconds":948000000},"format":{"quickfire":false,"choices":true,"coding":false,"ponder":true},"round":{"audition":true,"national":false,"regional":false},"statement":"โปรแกรมต่อไปนี้ทำงานอะไร?\n\n```pseudocode\ninput: positive integer N\noutput: unknown?\n\nlb := 0\nub := N\nloop:\n    attempt := floor((lb + ub) / 2)  # Math's floor function\n    if N < attempt²:\n        ub := attempt - 1\n    else if N ≥ (attempt + 1)²:\n        lb := attempt + 1\n    else: \n        return attempt\n```\n\n1. ฟังก์ชัน square-root แต่ปัดเศษเป็นจำนวนเต็มที่ใกล้ที่สุดเสมอ (round to nearest integer)\n2. ฟังก์ชัน square-root แต่ปัดเศษทิ้งเป็นจำนวนเต็มเสมอ (round down)\n3. ฟังก์ชัน square-root แต่ปัดเศษขึ้นเป็นจำนวนเต็มเสมอ (round up)\n4. ฟังก์ชัน square-root แต่เศษอาจถูกปัดขึ้นหรือลงอย่างไรก็ได้ ไม่สามารถคาดเดาได้\n5. ฟังก์ชันติด infinite loop ไม่รู้จบ"},"fcbbcc77-5eb9-45bb-9e9b-98210c34d2bd":{"format":{"coding":false,"ponder":true,"quickfire":false,"choices":false},"round":{"audition":false,"national":false,"regional":true},"statement":"กำหนดตัวเลข 6 ตัว ได้แก่ $1, 2, 5, 6, 7, 9$ ให้นำตัวเลขเหล่านี้มาบวก-ลบ-คูณ-หาร ให้ได้ $258$ จะต้องทำอย่างไร?\n- จะใช้ $+, -, \\times, \\div$ อย่างไรก็ได้ และจะใส่วงเล็บอย่างไรก็ได้\n- จะใช้ตัวเลขในลำดับใดก็ได้ แต่ต้องใช้ตัวเลขทุกตัว ตัวละหนึ่งครั้งพอดี ","archived":true,"region":{"central":false,"northeast":false,"south":true,"north":false},"deleted":false,"solution":"$\\frac{(9\\times5)-2}{\\frac{7}{6}-1}$, $(7\\times5+9-2+1)\\times6$","imageUrls":[],"tags":["math-puzzle","small-coding"],"createdAt":{"_seconds":1534935314,"_nanoseconds":241000000},"note":"- ภาคใต้ตอบถูก 0/7 ทีม","updatedAt":{"_seconds":1536066135,"_nanoseconds":681000000}},"ff755ca3-5396-4194-bb15-0690eb409366":{"region":{"northeast":false,"south":false,"north":false,"central":false},"deleted":false,"solution":"","imageUrls":["https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-1.png?alt=media&token=58be50b1-3ae3-4503-bcc1-54a1e06db767","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-ared.png?alt=media&token=e2011b29-d14a-428c-b272-06509dc31f0e","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-bred.png?alt=media&token=af08ab3c-307b-4373-b5af-52d697e3ce6f","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-cgreen.png?alt=media&token=8e636df1-293c-4b93-bc27-bf4c7140b3c8","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-cred.png?alt=media&token=07fc8f73-5509-4538-a0b4-2ffc25600bbc","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-dgreen.png?alt=media&token=dcdb58d7-38c5-4d26-9e79-f017e8cd301c","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-dred.png?alt=media&token=d8d4da69-4cbe-465b-bd0a-17b9461a1891","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-egreen.png?alt=media&token=96ecb0c1-19c5-4101-affd-f9f5f13ec021","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-ered.png?alt=media&token=400bd09b-1ae5-49ce-95b2-a4ea0ae67d65","https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-fgreen.png?alt=media&token=b8651766-45e5-48b4-87f8-09c982729927"],"tags":["used"],"createdAt":{"_seconds":1540547953,"_nanoseconds":587000000},"note":"- **Author:** เพลน\n- should be paired with [picture hanging problem](/questions/42e9879c-9f26-4db2-874b-a047489f5286)\n- [Eak] ทำใน 2 นาที ใช้ 15-20 วิตีตาราง excel ระบายสี -> ถ้าเราทำกระดาษตีตารางให้แล้วน่าจะช่วยได้","updatedAt":{"_seconds":1541170820,"_nanoseconds":371000000},"format":{"choices":false,"coding":false,"ponder":true,"quickfire":false},"round":{"audition":false,"national":true,"regional":false},"statement":"โจทย์ข้อนี้ เราจะนำกระเบื้องที่เป็น unit squares หลายแผ่นมาปูพื้น เงื่อนไขแรกของการปูกระเบื้อง คือ\n\n1. พื้นกระเบื้องรวมที่ได้จะต้องเป็น**รูปเหลี่ยมอย่างง่าย**ที่**ไม่มีรู**ตรงกลาง และกระเบื้อง 2 แผ่นที่ติดกันจะต้องวางแบบด้านชนด้าน **ไม่เหลื่อมกัน**ด้วย\n   - สังเกตว่ารูป (a) และ (b) ไม่สอดคล้องกับเงื่อนไขข้างต้น แต่รูป (c), (d), (e), (f) นั้นสอดคล้อง\n\n     ![][basic-def]\n\nนอกจากนั้น เรามีนิยามของ **“การเดินบนพื้นกระเบื้อง”** และ **Hamiltonian cycle** ดังนี้ \n\n- **“การเดินบนพื้นกระเบื้อง”** จะต้องเริ่มจากกระเบื้องแผ่นใดแผ่นหนึ่ง แล้วสามารถเดินไปยังแผ่นกระเบื้องถัดไปที่ติดกันในแนว บน-ล่าง-ซ้าย-ขวา เท่านั้น \n- **Hamiltonian cycle** คือการเดินบนพื้นกระเบื้อง โดยที่เริ่มต้นจากกระเบื้องใดกระเบื้องหนึ่ง จากนั้นเราเดินผ่านกระเบื้องแผ่นอื่น ๆ ทุกแผ่น แผ่นละ 1 ครั้ง แล้วกลับมายังจุดเริ่มต้นได้พอดี และในการเดินนี้จะไม่มีการเดินย้อนกลับทิศทางเดิม\n\nการปูกระเบื้องในโจทย์ข้อนี้ มีเงื่อนไขเพิ่มเติมอีก 2 ข้อ คือ\n\n2. การปูกระเบื้องดังกล่าวจะมี Hamiltonian cycle ได้เพียง**แบบเดียว**\n   - สังเกตว่ารูป (c) ไม่สอดคล้องกับเงื่อนไขนี้ แต่รูป (d), (e), (f) สอดคล้อง\n\n3. และมีวิธีแบ่งพื้นกระเบื้องนี้**ออกเป็น 2 ส่วน**ได้**วิธีเดียว** โดยที่พื้นที่ย่อย**แต่ละส่วน**จะมี Hamiltonian cycle ของตัวเองเพียง**แบบเดียว**เช่นกัน\n   - สังเกตว่ารูป (d), (e) ไม่สอดคล้องกับเงื่อนไขนี้ แต่รูป (f) สอดคล้อง\n\nจงหาวิธีปูกระเบื้อง 24 แผ่นด้วยการวาดรูป ที่สอดคล้องกับเงื่อนไขข้างต้นทั้ง 3 ข้อ\n\n[basic-def]: https://firebasestorage.googleapis.com/v0/b/kbtg-techjam-code-questions.appspot.com/o/questions%2Fff755ca3-5396-4194-bb15-0690eb409366%2Fdouble-cycles-1.png?alt=media&token=58be50b1-3ae3-4503-bcc1-54a1e06db767","archived":false}},"users":{"abhabongse@gmail.com":{"activated":true},"aniwat.im@gmail.com":{"activated":true},"auttasak.lapapirojn@gmail.com":{"activated":true},"groupdoll@gmail.com":{"activated":true},"jviriya@gmail.com":{"activated":true},"kuness@gmail.com":{"activated":true},"natthakunk0109@gmail.com":{"activated":true},"piecey.orl@gmail.com":{"activated":true},"rab9877@gmail.com":{"activated":true},"shiratoandroid@gmail.com":{"activated":true},"sukhumarn.a@gmail.com":{"activated":true},"thanachot.coon@gmail.com":{"activated":true},"tinnapat@gmail.com":{"activated":true},"wikanes@gmail.com":{"activated":true},"wutmaster@gmail.com":{"activated":false},"wuttisak.tr@gmail.com":{"activated":true},"yod.pallat@gmail.com":{"activated":true}}}